<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>JAVA 多线程&amp;网络通信初了解</title>
      <link href="2021/06/30/JAVA-%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E5%88%9D%E4%BA%86%E8%A7%A3/"/>
      <url>2021/06/30/JAVA-%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E5%88%9D%E4%BA%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h3 id="更加安全的线程"><a href="#更加安全的线程" class="headerlink" title="更加安全的线程"></a>更加安全的线程</h3><br/><h4 id="线程的加入"><a href="#线程的加入" class="headerlink" title="线程的加入"></a>线程的加入</h4><br/><p>当你打游戏时正嗨，却被npy找的时候（不好意思，我忘了我没有女友</p><p>咳咳，言归正传，线程加入可以使其中一个线程的运行过程中突然加入另一个，从而执行另一个线程（NTR狂喜（bushi）</p><p>线程中可以使用join，来中途加入一个线程</p><br/><pre class="line-numbers language-java" data-language="java"><code class="language-java">package Multiply;import javax.swing.*;import java.awt.*;class JoinTest extends JFrame &#123;    private Thread threadA;    private Thread threadB;    private final JProgressBar bar1 &#x3D; new JProgressBar();&#x2F;&#x2F;创建进度条组件    private final JProgressBar bar2 &#x3D; new JProgressBar();    int countA &#x3D; 0;    int countB &#x3D; 0;    public JoinTest()&#123;        super(&quot;test about the &#39;Join&#39;&quot;);        Container c &#x3D; getContentPane();        c.add(bar1, BorderLayout.NORTH);        c.add(bar2, BorderLayout.SOUTH);        bar1.setStringPainted(true);&#x2F;&#x2F;设置进度条显示数字字符        bar2.setStringPainted(true);        threadA &#x3D; new Thread(() -&gt; &#123;            while (true) &#123;                try &#123;                    Thread.sleep(50);                    threadB.join();&#x2F;&#x2F;在使用join语句之前，两个线程会同步进行操作                &#125; catch (Exception e) &#123;                    e.printStackTrace();                &#125;                bar1.setValue(++countA);                if (countA &#x3D;&#x3D; 100)&#123;                    System.exit(0);                &#125;            &#125;        &#125;);        threadA.start();        threadB &#x3D; new Thread(() -&gt; &#123;            while(true)&#123;                bar2.setValue(++countB);                try &#123;                    Thread.sleep(50);                &#125;catch (Exception e)&#123;                    e.printStackTrace();                &#125;                if (countB &#x3D;&#x3D; 100)&#123;                    break;                &#125;            &#125;        &#125;);        threadB.start();        setSize(500, 500);        setVisible(true);        setLocationRelativeTo(null);        setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);    &#125;&#125;public class Ex_04 &#123;    public static void main(String[] args) &#123;        JoinTest test &#x3D; new JoinTest();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><h4 id="线程的中断"><a href="#线程的中断" class="headerlink" title="线程的中断"></a>线程的中断</h4><br/><p>远古版本的JDK是有stop的，现在已经被废除，不过可以使用boolean类型来代替</p><p>这个取决于在平时代码时的一个循环逻辑，使用while/if进行各种判断就行</p><br/><h4 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h4><br/><p>Thread类中包含的成员变量代表了线程的某些优先级</p><p>如Thread.Min_PRIORITY（常数1）、Thread.MAX_PRIORITY（常数10）、Thread.NORM_PRIORITY（常数5）</p><p>在默认情况下的优先级都是Thread.NORM_PRIORITY</p><br/><pre class="line-numbers language-java" data-language="java"><code class="language-java">import javax.swing.*;import java.awt.*;class PriorityTest extends JFrame&#123;    private Thread threadA;    private Thread threadB;    private Thread threadC;    private Thread threadD;    private JProgressBar bar1 &#x3D; new JProgressBar();    private JProgressBar bar2 &#x3D; new JProgressBar();    private JProgressBar bar3 &#x3D; new JProgressBar();    private JProgressBar bar4 &#x3D; new JProgressBar();    public PriorityTest()&#123;        super(&quot;线程优先级练习&quot;);        Container c &#x3D; getContentPane();        c.setLayout(new GridLayout(4, 1));        setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);        setSize(1000, 1000);        setLocationRelativeTo(null);        setVisible(true);        c.add(bar1);        c.add(bar2);        c.add(bar3);        c.add(bar4);        bar1.setStringPainted(true);        bar2.setStringPainted(true);        bar3.setStringPainted(true);        bar4.setStringPainted(true);        threadA &#x3D; new Thread(new MyThread(bar1));        threadB &#x3D; new Thread(new MyThread(bar2));        threadC &#x3D; new Thread(new MyThread(bar3));        threadD &#x3D; new Thread(new MyThread(bar4));        setPriority(&quot;threadA&quot;, 5, threadA);        setPriority(&quot;threadB&quot;, 5, threadB);        setPriority(&quot;threadC&quot;, 2, threadC);        setPriority(&quot;threadD&quot;, 1, threadD);    &#125;    public void setPriority(String ThreadName, int priority, Thread t)&#123;        t.setPriority(priority);        t.setName(ThreadName);        t.start();    &#125;    private final class MyThread implements Runnable&#123;&#x2F;&#x2F;实现Runnable中的run方法        private final JProgressBar bar;        private int count &#x3D; 0;        private MyThread(JProgressBar bar)&#123;            this.bar &#x3D; bar;        &#125;        public void run()&#123;            while (true)&#123;                bar.setValue(count+&#x3D;1);                try &#123;                    Thread.sleep(50);                &#125;catch (Exception e)&#123;                    System.out.println(&quot;当前线程可能被中断&quot;);                    e.printStackTrace();                &#125;                if (count &#x3D;&#x3D; 100)&#123;                    JOptionPane.showMessageDialog(null, &quot;线程已结束&quot;);                &#125;            &#125;        &#125;    &#125;&#125;public class Ex_05 &#123;    public static void main(String[] args) &#123;        PriorityTest test &#x3D; new PriorityTest();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>这四个设定的进度条虽然看上去是统一加载，但是还是有细微的差别</p><p>系统总是会处理前面两个，从而导致前两个进度条最先进行变化</p><br/><h4 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h4><br/><p>不同步的线程会产生很多问题，比如地铁的购票系统中，如果同时进行了线程的操作，就会对同一事物判断两次</p><p>购票系统，即使有0的判断，也可能出现负数的情况</p><p>情况不仅仅如此，由于不是同步的线程，整个程序的逻辑顺序可能会变得混乱，设置优先级无法弥补这种错误</p><br/><pre class="line-numbers language-java" data-language="java"><code class="language-java">class ThreadSafeTest implements Runnable&#123;    private int sum &#x3D; 10;    public void run()&#123;        while (true)&#123;            if (sum &gt;&#x3D; 0)&#123;                try &#123;                    Thread.sleep(100);                &#125;catch (Exception e)&#123;                    e.printStackTrace();                &#125;                System.out.println(&quot;tickets &quot; + sum--);            &#125;        &#125;    &#125;&#125;public class Ex_06 &#123;    public static void main(String[] args) &#123;        ThreadSafeTest t &#x3D; new ThreadSafeTest();        Thread t1 &#x3D; new Thread(t);        Thread t2 &#x3D; new Thread(t);        Thread t3 &#x3D; new Thread(t);        Thread t4 &#x3D; new Thread(t);        t1.start();&#x2F;&#x2F;分开启动不同的线程，可能会使输出结果出现无法预知的问题        t2.start();        t3.start();        t4.start();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>可以使用synchronized关键字进行共享线程的锁定</p><p>就好像，一个人去上厕所时把门关上了一样，这样其他人就没法进去了（书上的奇妙比喻</p><p>有两种方法进行这种操作</p><br/><pre class="line-numbers language-java" data-language="java"><code class="language-java">package Multiply;class ThreadSafeTest implements Runnable&#123;    private int sum &#x3D; 10;    public void run()&#123;        synchronized (&quot;&quot;)&#123;&#x2F;&#x2F;直接简单粗暴，在需要的代码块前加上synchronized            while (true)&#123;                if (sum &gt;&#x3D; 0)&#123;                    try &#123;                        Thread.sleep(100);                    &#125;catch (Exception e)&#123;                        e.printStackTrace();                    &#125;                    System.out.println(&quot;tickets &quot; + sum--);                &#125;            &#125;        &#125;    &#125;    &#x2F;&#x2F;    public synchronized void Do()&#123; 通过单独定义一个函数进行实现&#x2F;&#x2F;        if (sum &gt;&#x3D; 0)&#123;&#x2F;&#x2F;            try &#123;&#x2F;&#x2F;                Thread.sleep(100);&#x2F;&#x2F;            &#125;catch (Exception e)&#123;&#x2F;&#x2F;                e.printStackTrace();&#x2F;&#x2F;            &#125;&#x2F;&#x2F;            System.out.println(&quot;tickets &quot; + sum--);&#x2F;&#x2F;        &#125;&#x2F;&#x2F;    &#125;&#x2F;&#x2F;    public void run()&#123;&#x2F;&#x2F;        while (true)&#123;&#x2F;&#x2F;            Do();&#x2F;&#x2F;        &#125;&#x2F;&#x2F;    &#125;    &#125;public class Ex_06 &#123;    public static void main(String[] args) &#123;        ThreadSafeTest t &#x3D; new ThreadSafeTest();        Thread t1 &#x3D; new Thread(t);        Thread t2 &#x3D; new Thread(t);        Thread t3 &#x3D; new Thread(t);        Thread t4 &#x3D; new Thread(t);        t1.start();        t2.start();        t3.start();        t4.start();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><h3 id="网络通信"><a href="#网络通信" class="headerlink" title="网络通信"></a>网络通信</h3><br/><h4 id="通信基本了解"><a href="#通信基本了解" class="headerlink" title="通信基本了解"></a>通信基本了解</h4><br/><p>想要实现两台计算机的通信，则必须使用网络来进行连接</p><p>简单归纳一下，可以简述为<code>服务器&lt;=&gt;网络&lt;=&gt;客户机</code>，从数台甚至几千台计算机连接的局域网，再到现在的互联网</p><p>internet采用ip规则，使得不同的硬件组成电脑能够连接到互联网</p><p>现在普遍使用的32位二进制，4个字节（IPv4），未来可能会使用16字节表示IP地址（IPv6）</p><br/><h4 id="TCP-UDP协议"><a href="#TCP-UDP协议" class="headerlink" title="TCP/UDP协议"></a>TCP/UDP协议</h4><br/><p>TCP协议是一种以固结连线位基础的协议，他提供两台计算机间可靠的数据传送。特点是能够保证数据确实送达到另一端，数据的排列顺序和送出顺序和发出时一致，适用于对数据可靠性要求高的场合</p><p>HTTP、FTP和telnet都是需要可靠的通信渠道，如果URL读取的信息和发送的信息不一致，就会出现错误的HTML</p><p>UDP协议则是无连接通信协议，不保证数据传输的可靠传输，但是能向若干个目标发送数据，并且每个数据都是一个独立的包。类似于邮差将信送到不同人手中，这个时候送信的顺序就不可能和寄信顺序一致了</p><p>UDP适用于对可靠性要求不高，但对于传输速度和时效性要求非常高的网站，如网络聊天室，在线影片等等。如果使用TCP会使得在认证上，传输速度缓慢，存在额外耗费。使用UDP即使一部分数据包遗失（我们所称为的丢包现象），也不会危害整个通信</p><br/><h4 id="Socket-TCP-编程"><a href="#Socket-TCP-编程" class="headerlink" title="Socket(TCP) 编程"></a>Socket(TCP) 编程</h4><br/><p>套接字使用TCP提供了两台计算机之间的通信机制。 客户端程序创建一个套接字，并尝试连接服务器的套接字</p><p>当连接建立时，服务器会创建一个 Socket 对象。客户端和服务器现在可以通过对 Socket 对象的写入和读取来进行通信</p><p>java.net.Socket 类代表一个套接字，并且 java.net.ServerSocket 类为服务器程序提供了一种来监听客户端，并与他们建立连接的机制</p><p>java中定义了InetAddress类来获取对应的信息</p><table><thead><tr><th align="center">方法</th><th align="center">返回值</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">getByName(String host)</td><td align="center">InetAddress</td><td align="center">获取于Host相对应的InetAddress对象</td></tr><tr><td align="center">getHostAddress()</td><td align="center">String</td><td align="center">获取inetAddress对象所包含的IP地址</td></tr><tr><td align="center">getHostName()</td><td align="center">String</td><td align="center">获取此IP地址的主机名</td></tr><tr><td align="center">getLocalHost()</td><td align="center">InetAddress</td><td align="center">返回本地主机的InetAddress对象</td></tr></tbody></table><br/><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.net.InetAddress;public class Ex_01 &#123;    public static void main(String[] args) &#123;        try &#123;            InetAddress ip &#x3D; InetAddress.getLocalHost();            String LocalName &#x3D; ip.getHostName();            String LocalIP &#x3D; ip.getHostAddress();            System.out.println(&quot;本机名:&quot; + LocalName);            System.out.println(&quot;本机IP地址:&quot; + LocalIP);        &#125;catch (Exception e)&#123;            e.printStackTrace();        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>1.服务器实例化一个 ServerSocket 对象，表示通过服务器上的端口通信。</p><p>2.服务器调用 ServerSocket 类的 accept() 方法，该方法将一直等待，直到客户端连接到服务器上给定的端口</p><p>3.服务器正在等待时，一个客户端实例化一个 Socket 对象，指定服务器名称和端口号来请求连接</p><p>4.Socket 类的构造函数试图将客户端连接到指定的服务器和端口号。如果通信被建立，则在客户端创建一个 Socket 对象能够与服务器进行通信</p><p>5.在服务器端，accept() 方法返回服务器上一个新的 socket 引用，该 socket 连接到客户端的 socket</p><br/><h4 id="服务器端代码编写"><a href="#服务器端代码编写" class="headerlink" title="服务器端代码编写"></a>服务器端代码编写</h4><br/><table><thead><tr><th align="center">方法</th><th align="center">返回值</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">accept()</td><td align="center">Socket</td><td align="center">等待客户机的连接，若连接，则创建一个套接字</td></tr><tr><td align="center">isBound()</td><td align="center">boolean</td><td align="center">判断ServerSocket的绑定状态</td></tr><tr><td align="center">getInetAddress()</td><td align="center">InetAddress</td><td align="center">返回此服务器套接字的本地地址</td></tr><tr><td align="center">isClosed()</td><td align="center">boolean</td><td align="center">返回服务器套接字的关闭状态</td></tr><tr><td align="center">close()</td><td align="center">void</td><td align="center">关闭服务器套接字</td></tr><tr><td align="center">bind(SocketAddress endpoint)</td><td align="center">void</td><td align="center">将ServerSocket绑定到特定地址（IP地址和端口号）</td></tr><tr><td align="center">getInetAddress()</td><td align="center">int</td><td align="center">返回服务器套接字等待的端口号</td></tr></tbody></table><br/><p>首先，进行服务器（伪）的撰写，由于是由主机host决定的，所以在后续连接时取地址为127.0.0.1</p><p>之后设置服务器的端口，客户机连接时需要和其一致</p><p>通过BufferedReader读取相对应客户机中Writer写入的数据</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;import java.net.ServerSocket;import java.net.Socket;class MyTCP&#123;    private BufferedReader reader;    private ServerSocket server;&#x2F;&#x2F;服务器    private Socket socket;&#x2F;&#x2F;客户机    public void getServer()&#123;        try &#123;            server &#x3D; new ServerSocket(8998);            System.out.println(&quot;服务器套接字已经创建成功&quot;);            while (true)&#123;                System.out.println(&quot;等待客户机的连接&quot;);                socket &#x3D; server.accept();                reader &#x3D; new BufferedReader(new InputStreamReader(socket.getInputStream()));&#x2F;&#x2F;通过socket获得输入流信息                getClientMessage();            &#125;        &#125;catch (IOException e)&#123;            e.printStackTrace();        &#125;    &#125;    private void getClientMessage()&#123;        try &#123;            while (true)&#123;                System.out.println(&quot;客户机:&quot; + reader.readLine());&#x2F;&#x2F;获得客户信息            &#125;        &#125;catch (Exception e)&#123;            e.printStackTrace();        &#125;        try &#123;            if (reader !&#x3D; null)&#123;                reader.close();            &#125;            if (socket !&#x3D; null)&#123;                socket.close();            &#125;        &#125;catch (IOException e)&#123;&#x2F;&#x2F;可能会引发IOException中的错误            e.printStackTrace();        &#125;    &#125;&#125;public class Ex_02_Server &#123;    public static void main(String[] args) &#123;        MyTCP tcp &#x3D; new MyTCP();        tcp.getServer();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>下面填写客户机的代码</p><p>首先就是实例化socket跟服务器进行连接，规定IP和端口</p><p>利用PrintWriter类将数据写进getOutputStream()，输出流中</p><br/><pre class="line-numbers language-java" data-language="java"><code class="language-java">import javax.swing.*;import javax.swing.border.BevelBorder;import java.awt.*;import java.io.PrintWriter;import java.net.Socket;class MyClient extends JFrame&#123;    private PrintWriter writer;    private Socket socket;    private JTextArea ta &#x3D; new JTextArea();&#x2F;&#x2F;使用文本域作为整体过程的显示    private JTextField tf &#x3D; new JTextField();    public MyClient()&#123;        super(&quot;向服务器输入数据&quot;);        Container c &#x3D; getContentPane();        setVisible(true);        setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);        setSize(500, 500);        setLocationRelativeTo(null);        final JScrollPane scrollPane &#x3D; new JScrollPane();&#x2F;&#x2F;滚动界面        scrollPane.setBorder(new BevelBorder(BevelBorder.RAISED));        c.add(scrollPane, BorderLayout.CENTER);        scrollPane.setViewportView(ta);&#x2F;&#x2F;将关注点集中到文本域中        c.add(tf, &quot;South&quot;);&#x2F;&#x2F;可以直接使用字符串类型，代替BorderLayout.South        tf.addActionListener(e -&gt; &#123;            writer.println(tf.getText());            ta.append(tf.getText() + &quot;\n&quot;);            ta.setSelectionEnd(tf.getText().length());&#x2F;&#x2F;设置下一个点的具体位置            tf.setText(&quot;&quot;);        &#125;);    &#125;    public void connect()&#123;        ta.append(&quot;尝试连接\n&quot;);        try &#123;            socket &#x3D; new Socket(&quot;127.0.0.1&quot;, 8998);            writer &#x3D; new PrintWriter(socket.getOutputStream(), true);            ta.append(&quot;连接成功\n&quot;);        &#125;catch (Exception e)&#123;            e.printStackTrace();        &#125;    &#125;&#125;public class Ex_02_Client &#123;    public static void main(String[] args) &#123;        MyClient client &#x3D; new MyClient();        client.connect();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>随便写点</title>
      <link href="2021/06/30/%E9%9A%8F%E4%BE%BF%E5%86%99%E7%82%B9/"/>
      <url>2021/06/30/%E9%9A%8F%E4%BE%BF%E5%86%99%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<p>写了，但没完全写（</p>]]></content>
      
      
      <categories>
          
          <category> 人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 个人感悟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA 枚举&amp;泛型&amp;多线程</title>
      <link href="2021/06/17/JAVA-%E6%9E%9A%E4%B8%BE-%E6%B3%9B%E5%9E%8B-%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
      <url>2021/06/17/JAVA-%E6%9E%9A%E4%B8%BE-%E6%B3%9B%E5%9E%8B-%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><br/><p>枚举没有什么好说明的，基本和C差不多的东西，但是有部分类中定义的方法作为稍微的了解</p><table><thead><tr><th align="center">方法名称</th><th align="center">具体含义</th></tr></thead><tbody><tr><td align="center">values()</td><td align="center">该方法可以将枚举类型成员以数组的形式返回</td></tr><tr><td align="center">valueOf()</td><td align="center">该方法可以实现将普通字符串转换为枚举实例</td></tr><tr><td align="center">compareTo()</td><td align="center">该方法用于比较两个枚举对象在定义时的顺序</td></tr><tr><td align="center">ordinal()</td><td align="center">该方法用于得到枚举成员的位置索引</td></tr></tbody></table><p>Java中的枚举也可以添加构造方法，不过必须使用private修饰符</p><br/><pre class="line-numbers language-java" data-language="java"><code class="language-java">interface Constants&#123;    int Constants_A &#x3D; 1;    int Constants_B &#x3D; 12;&#125;&#x2F;&#x2F;把常数定义在接口中public class Ex_01 &#123;    enum Constants2&#123;Constants_A, Constants_B&#125;&#x2F;&#x2F;默认值为0    public static void DoIt1(int c)&#123;        switch (c)&#123;            case Constants.Constants_A:                System.out.println(&quot;Constants_A1&quot;);                break;            case Constants.Constants_B:                System.out.println(&quot;Constants_B1&quot;);                break;        &#125;    &#125;    public static void DoIt2(Constants2 c)&#123;        switch (c)&#123;            case Constants_A:                System.out.println(&quot;Constants_A2&quot;);                break;            case Constants_B:                System.out.println(&quot;Constants_B2&quot;);                break;        &#125;    &#125;    public static void main(String[] args) &#123;        Ex_01.DoIt1(Constants.Constants_A);        Ex_01.DoIt1(Constants.Constants_B);        Ex_01.DoIt2(Constants2.Constants_A);        Ex_01.DoIt2(Constants2.Constants_B);        System.out.println();                for (int i &#x3D; 0; i &lt; Constants2.values().length; i++)&#123;            System.out.println(&quot;枚举类型成员变量&quot; + Constants2.values()[i]);        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>使用枚举的优势主要有以下几点：</p><p>1.类型安全</p><p>2.紧凑有效的数据定义</p><p>3.可以和程序其他部分完美交互</p><p>4.运行效率高</p><br/><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><br/><h4 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h4><br/><p>具体使用的原理和好处可以参考Cprimer中对于泛型的讲解</p><p>（这里只是对一些基本的进行了解，如果未来想要从事相关方面的工作，建议还是要深究）</p><p>这里使用Object类型作为基本的向上转化类型</p><br/><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Ex_02 &#123;    private Object b;    public void setB(Object b) &#123;        this.b &#x3D; b;    &#125;    public Object getB() &#123;        return b;    &#125;&#125;class Main&#123;    public static void main(String[] args) &#123;        Ex_02 ex02 &#x3D; new Ex_02();        ex02.setB(Boolean.TRUE);&#x2F;&#x2F;相当于new Boolean(true)        System.out.println(ex02.getB());        ex02.setB(12.3f);&#x2F;&#x2F;相当于new float(12.3f)        Float f &#x3D; (Float) ex02.getB();        System.out.println(f);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>Java中的泛型主要跟类一起定义，使泛型变成一种类和对象的用法</p><p>（不需要像C++一样添加template这样的关键字提示）</p><br/><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Ex_03&lt;T&gt;&#123;    private T over;    public void setOver(T over) &#123;        this.over &#x3D; over;    &#125;    public T getOver() &#123;        return over;    &#125;&#125;class Main03&#123;    public static void main(String[] args) &#123;        Ex_03&lt;Boolean&gt; e1 &#x3D; new Ex_03&lt;Boolean&gt;();        Ex_03&lt;Float&gt; e2 &#x3D; new Ex_03&lt;Float&gt;();        e1.setOver(false);        e2.setOver(2.555f);        System.out.println(e1.getOver());        System.out.println(e2.getOver());    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>当然，在定义的时候可以加上两个不同的泛型，设置的变量也能是数组</p><p>在之前，我们也了解过集合类，这就是Java系统中定义好的泛型操作</p><table><thead><tr><th align="center">集合类</th><th align="center">泛型定义</th></tr></thead><tbody><tr><td align="center">ArrayList</td><td align="center">ArrayList<E></td></tr><tr><td align="center">HashMap</td><td align="center">HashMap&lt;K, V&gt;</td></tr><tr><td align="center">HashSet</td><td align="center">HashSet<E></td></tr><tr><td align="center">Vector</td><td align="center">Vector<E></td></tr></tbody></table><br/><h4 id="进阶用法"><a href="#进阶用法" class="headerlink" title="进阶用法"></a>进阶用法</h4><br/><p>可以在定义时，加上extends+接口名，对泛型继承的接口的进行限制</p><p>泛型的机制中，引入了类型通配符，要声明这样一个对象可以使用？通配符来表示，同时使用extends来加以限制</p><p>通过通配符可以表示位置的类型</p><br/><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.util.ArrayList;import java.util.LinkedList;import java.util.List;public class Ex_04&lt;T extends List&gt; &#123;    public static void main(String[] args) &#123;        Ex_04&lt;ArrayList&gt; l1 &#x3D; new Ex_04&lt;&gt;();        Ex_04&lt;LinkedList&gt; l2 &#x3D; new Ex_04&lt;&gt;();        Ex_04&lt;? extends List&gt; l3 &#x3D; null;        l3 &#x3D; new Ex_04&lt;ArrayList&gt;();        l3 &#x3D; new Ex_04&lt;LinkedList&gt;();    &#125;&#125;import java.util.ArrayList;import java.util.LinkedList;import java.util.List;public class Ex_05 &#123;    public static void main(String[] args) &#123;        List&lt;String&gt; l1 &#x3D; new ArrayList&lt;&gt;();        l1.add(&quot;cxy&quot;);        l1.add(&quot;ckt&quot;);        List&lt;?&gt; l2 &#x3D; l1;        List&lt;?&gt; l3 &#x3D; new LinkedList&lt;Integer&gt;();        System.out.println(l2.get(0));&#x2F;&#x2F;获取l2中的第一个值    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>1.泛型的类型参数只能是类类型，不能是简单类型，如A<int>就是错误的</p><p>2.泛型的类型个数可以是多个</p><p>3.可以使用extends关键字限制泛型的类型</p><p>4.可以使用通配符限制泛型的类型</p><br/><h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><br/><p>所谓线程，就相当于我们做一件事情，我们可以很多事情一起做（比如刷b站和复习（x），这就是多线程</p><p>不是所有的程序都支持多线程的，有些需要一个任务执行完之后再执行下一个任务，Java正是提供了这种并发机制</p><p>实现线程有着两种方式，一个是Thread、一个是Runnable</p><br/><h4 id="Thread类"><a href="#Thread类" class="headerlink" title="Thread类"></a>Thread类</h4><br/><p>通过将类继承Thread，并且实现Thread类中的run方法，就可以定义一个基本的线程类</p><p>在主函数中可以调用start()方法触发Thread类</p><br/><pre class="line-numbers language-java" data-language="java"><code class="language-java">package Multiply;class ThreadTest extends Thread&#123;    private int count &#x3D; 10;    @Override    public void run() &#123;        while(true)&#123;            System.out.print(count + &quot; &quot;);            if (--count &#x3D;&#x3D; 0)&#123;                return;            &#125;        &#125;    &#125;&#125;public class Ex_01 &#123;    public static void main(String[] args) &#123;        ThreadTest test &#x3D; new ThreadTest();        test.start();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>在主方法调用start之前Thread只是一个实例，并不是一个线程</p><p>通常的run方法使用的是一个无限循环，使得线程可以一直进行下去</p><br/><h4 id="Runnable接口"><a href="#Runnable接口" class="headerlink" title="Runnable接口"></a>Runnable接口</h4><br/><p>如果想要使用非Thread类来实现线程，可以使用该接口</p><p>调用接口之后就能构建Thread对象，有两个构造方法</p><blockquote><p>public Thread(Runnable target)</p><p>public Thread(Runnable target, String name)</p></blockquote><p>1.建立Runnable对象</p><p>2.使用参数为Runnable对象的构造方法创建Thread实例</p><p>3.调用start方法启动线程</p><br/><p>接下来是一部分小知识环节（x</p><p>public void setOpaque(boolean isOpaque)</p><p>如果为 true，则该组件绘制其边界内的所有像素。否则该组件可能不绘制部分或所有像素，从而允许其底层像素透视出来</p><p>对于 JComponent 而言，此属性的默认值是 false。但是对于大多数标准的 JComponent 子类（如 JButton 和 JTree），此属性的默认值与外观有关</p><br/><pre class="line-numbers language-java" data-language="java"><code class="language-java">package Multiply;import javax.swing.*;import java.awt.*;class SwingThread extends JFrame&#123;    private static Thread t;    private String[] name &#x3D; &#123;&quot;cxy&quot;, &quot;ckt&quot;, &quot;cyx&quot;, &quot;cmk&quot;&#125;;    private int count &#x3D; 0;        public SwingThread()&#123;        t &#x3D; new Thread(new Runnable() &#123;            @Override            public void run() &#123;              while(true)&#123;                  setTitle(name[count]);                  count++;                  if(count &#x3D;&#x3D; name.length)&#123;                      count &#x3D; 0;                  &#125;                  try &#123;                      Thread.sleep(1000);&#x2F;&#x2F;使程序休眠一秒（1000毫秒），需要使用try&#x2F;catch环绕                  &#125;catch (Exception e)&#123;                      e.printStackTrace();                  &#125;              &#125;            &#125;        &#125;);        t.start();        Container c &#x3D; getContentPane();        setSize(300, 300);        setLocationRelativeTo(null);        setLayout(null);        setVisible(true);        setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);    &#125;&#125;public class Ex_02&#123;    public static void main(String[] args) &#123;        SwingThread test &#x3D; new SwingThread();    &#125;&#125;&#x2F;&#x2F;Runnable的实现也可以使用lambda函数&#x2F;&#x2F;t &#x3D; new Thread(() -&gt; &#123;&#x2F;&#x2F;        while(true)&#123;&#x2F;&#x2F;            setTitle(name[count]);&#x2F;&#x2F;            count++;&#x2F;&#x2F;            if(count &#x3D;&#x3D; name.length)&#123;&#x2F;&#x2F;                count &#x3D; 0;&#x2F;&#x2F;            &#125;&#x2F;&#x2F;            try &#123;&#x2F;&#x2F;                Thread.sleep(1000);&#x2F;&#x2F;            &#125;catch (Exception e)&#123;&#x2F;&#x2F;                e.printStackTrace();&#x2F;&#x2F;            &#125;&#x2F;&#x2F;        &#125;&#x2F;&#x2F;&#125;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p><img src="https://www.runoob.com/wp-content/uploads/2014/01/java-thread.jpg" alt="img"></p><br/><p>当然，可以使用sleep休眠，wait使程序等待</p><p>notify或者notifyAll让程序从等待过程回到准备运行阶段</p><br/><h3 id="GUI-rand-线程"><a href="#GUI-rand-线程" class="headerlink" title="GUI+rand+线程"></a>GUI+rand+线程</h3><br/><p>上面的例子已经用线程演示了一个基本的GUI中的线程操作</p><p>其中使用到了sleep方法，来使得程序休眠，但是可能会触发InterruptedException异常，所以需要try/catch语句环绕</p><br/><pre class="line-numbers language-java" data-language="java"><code class="language-java">package Multiply;import javax.swing.*;import java.awt.*;import java.util.Random;class Gui extends JFrame&#123;    private Thread t;    private static Color[] color &#x3D; &#123;Color.BLACK, Color.BLUE, Color.CYAN,    Color.GREEN, Color.ORANGE, Color.YELLOW, Color.RED, Color.PINK, Color.LIGHT_GRAY&#125;;    private static final Random rand &#x3D; new Random();    private static Color getC()&#123;        return color[rand.nextInt(color.length)];&#x2F;&#x2F;在这个长度内随机整数    &#125;    public Gui()&#123;        t &#x3D; new Thread(new Runnable() &#123;            int x &#x3D; 30;            int y &#x3D; 50;            @Override            public void run() &#123;                while (true)&#123;                    try &#123;                        Thread.sleep(50);                    &#125;catch (Exception e)&#123;                        e.printStackTrace();                    &#125;                    Graphics graphics &#x3D; getGraphics();&#x2F;&#x2F;获取组件绘图上下对象                    graphics.setColor(getC());                    graphics.drawLine(x, y, 200, y++);&#x2F;&#x2F;绘制直线并向下递减坐标                    if (y &gt;&#x3D; 200)&#123;                        y &#x3D; 50;                    &#125;                &#125;            &#125;        &#125;);        t.start();        setSize(300, 300);        setLocationRelativeTo(null);        setVisible(true);        setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);    &#125;&#125;public class Ex_03  &#123;    public static void main(String[] args) &#123;        Gui gui &#x3D; new Gui();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>Graphics 类相当于一个画布，每个 Swing 组件都通过 Graphics 对象来绘制显示</p><p>绘图的原点位于组件的左上角</p><p>暂时先简单地介绍一下直线基本画法，其他图形基本差不多</p><br/><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcwMjE4MTczNzAxNTgw?x-oss-process=image/format,png" alt="Graphics坐标"></p><br/><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 创建 Graphics 的副本Graphics create()&#x2F;&#x2F; 回收 Graphicsvoid dispose()&#x2F;&#x2F; 设置画笔颜色void setColor(Color c)&#x2F;&#x2F; 擦除某一区域（擦除后显示背景色）void clearRect(int x, int y, int width, int height)&#x2F;&#x2F; 绘制一条线段（如果两点为同一点，则绘制点）void drawLine(int x1, int y1, int x2, int y2)&#x2F;&#x2F; 根据给定的多个点坐标绘制折线void drawPolyline(int xPoints[], int yPoints[], int nPoints)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA 反射 p2</title>
      <link href="2021/06/15/JAVA-%E5%8F%8D%E5%B0%84-p2/"/>
      <url>2021/06/15/JAVA-%E5%8F%8D%E5%B0%84-p2/</url>
      
        <content type="html"><![CDATA[<h3 id="深挖Field"><a href="#深挖Field" class="headerlink" title="深挖Field"></a>深挖Field</h3><br/><h4 id="主要方法"><a href="#主要方法" class="headerlink" title="主要方法"></a>主要方法</h4><br/><p>当然，如果不需要进行比较高级的操作，可以直接使用类名来进行反射操作</p><p>不过对于一些调用属性的操作依然需要类的对象</p><p><a href="http://www.51gjie.com/java/792.html">getType()</a>： 获取属性声明时类型对象（返回class对象）</p><p><a href="http://www.51gjie.com/java/793.html">getGenericType() </a>： 返回属性声的Type类型</p><p>getName() ： 获取属性声明时名字</p><p>getAnnotations() ： 获得这个属性上所有的注释</p><p>getModifiers() ： 获取属性的修饰</p><p>isEnumConstant() ： 判断这个属性是否是枚举类</p><p>isSynthetic() ： 判断这个属性是否是 复合类</p><p><a href="http://www.51gjie.com/java/795.html">get(Object obj) </a>： 取得obj对象这个Field上的值</p><p><a href="http://www.51gjie.com/java/794.html">set(Object obj, Object value)</a> ： 向obj对象的这个Field设置新值value</p><p>可以通过以上方法来对其进行的属性进行调用，在之前的例子中就已经有所使用</p><p>这些属性可以让反射编程快速调用一个类的各种具体信息，在Method中，方法也具体同理</p><br/><h4 id="小知识"><a href="#小知识" class="headerlink" title="小知识"></a>小知识</h4><br/><p>AccessibleObject 类是 Field、Method 和 Constructor 对象的基类。它提供了将反射的对象标记为在使用时取消默认 Java 语言访问控制检查的能力。对于公共成员、默认（打包）访问成员、受保护成员和私有成员，在分别使用 Field、Method 或 Constructor 对象来设置或获得字段、调用方法，或者创建和初始化类的新实例的时候，会执行访问检查</p><p>这样就可以直接去访问私有成员了（x</p><br/><h4 id="set-amp-get"><a href="#set-amp-get" class="headerlink" title="set()&amp;get()"></a>set()&amp;get()</h4><br/><p>set(Object obj, Object value);</p><p>可以通过这种方法，快速修改所调用field里面变量的值</p><p>public Object get(Object obj);</p><p>通过这种方法获取field里的属性值</p><p>这就很像类中固有的两种方法了，熟能生巧便能掌握全部（x</p><br/><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.lang.reflect.Field;class Fish&#123;    private String name &#x3D; &quot;cxy&quot;;    private int age &#x3D; 5;&#125;public class Field_set_get &#123;    public static void main(String[] args) throws Exception&#123;        Fish fish &#x3D; new Fish();        Field field &#x3D; fish.getClass().getDeclaredField(&quot;name&quot;);        field.setAccessible(true);&#x2F;&#x2F;关闭Java访问规则，这样私有成员也能访问        System.out.println(field.get(fish));        field.set(fish, &quot;fwh&quot;);        System.out.println(field.get(fish));    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><h3 id="访问构造方法"><a href="#访问构造方法" class="headerlink" title="访问构造方法"></a>访问构造方法</h3><br/><blockquote><p>getConstructors() 获取类中的公共方法</p><p>getConstructor(Class[]  params) 获取类的特定构造方法,params参数指定构造方法的参数类型</p><p>getDeclaredConstructors() 获取类中所有的构造方法(public、protected、default、private)</p><p>getDeclaredConstructor(Class[] params) 获取类的特定构造方法,params参数指定构造方法的参数类型</p></blockquote><p>（1）得到这个类的所有构造方法：如得到上面示例中Person类的所有构造方法</p><p>Constructor[] cons = Class.forName(“cn.itheima.Person”).getConstructors();</p><p>（2）获取某一个构造方法：</p><p>Constructor con=Person.class.getConstructor(String.class,int.class);</p><p>写多了你就会发现反射的语法调用都是类似的几种方法</p><p>要么就是直接连续调用，要么就是使用数组的东西获得整体</p><br/><pre class="line-numbers language-java" data-language="java"><code class="language-java">package Reflect;import java.awt.*;import java.lang.reflect.Constructor;class Human&#123;    private String name;    private String sex;    private int age;    private double scores;    public Human(String name, String sex, int age, double scores)&#123;        this.name &#x3D; name;        this.sex &#x3D; sex;        this.age &#x3D; age;        this.scores &#x3D; scores;    &#125;    public Human()&#123;        this(&quot;&quot;, &quot;&quot;, 0, 0.0);    &#125;&#125;public class Class_Constructor &#123;    public static void main(String[] args) &#123;        try &#123;            Class c &#x3D; Class.forName(&quot;Reflect.Human&quot;);            Human co &#x3D; (Human) c.newInstance();            Constructor c1 &#x3D; co.getClass().getConstructor(null);            System.out.println(c1);            System.out.println();            c1 &#x3D; co.getClass().getConstructor(String.class, String.class, int.class, double.class);            System.out.println(c1);            System.out.println();            Constructor[] c2 &#x3D; co.getClass().getConstructors();            for (Constructor constructor : c2)&#123;                System.out.println(constructor);            &#125;        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><h3 id="Annotation"><a href="#Annotation" class="headerlink" title="Annotation"></a>Annotation</h3><br/><p>Annotation不影响程序的运行，但对编译器的警告工具会有一定作用（写在对应接口中）</p><p>定义的关键字为@interface，隐含了继承相关接口的意思</p><p><img src="https://www.runoob.com/wp-content/uploads/2019/08/28123151-d471f82eb2bc4812b46cc5ff3e9e6b82.jpg" alt="img"></p><br/><pre class="line-numbers language-java" data-language="java"><code class="language-java">public @interface OneMemberAnnotation&#123;        String value();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><br/><p>String：成员类型，可用的类型有String、Class、primitive、enumerated、annotation，以及所有类型的数组</p><p>value：成员名称，如果类中只包含一个成员，名称通常为value</p><p><img src="https://www.runoob.com/wp-content/uploads/2019/08/28123653-84d14b886429482bb601dc97155220fb.jpg" alt="img"></p><p>除此之外，还在ElementType中定义各种枚举常量进行注释（使用@target）</p><table><thead><tr><th align="center">枚举常量</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">ANNOTATION_TYPE</td><td align="center">表示用于Annotation类型</td></tr><tr><td align="center">TYPE</td><td align="center">表示用于类、接口和枚举，以及Annotation类型</td></tr><tr><td align="center">CONSTRUCTOR</td><td align="center">表示用于构造方法</td></tr><tr><td align="center">FIELD</td><td align="center">表示用于成员变量和枚举变量</td></tr><tr><td align="center">METHOD</td><td align="center">表示用于方法</td></tr><tr><td align="center">PARAMETER</td><td align="center">表示用于参数</td></tr><tr><td align="center">LOCAL_VARIABLE</td><td align="center">表示用于局部变量</td></tr><tr><td align="center">PACKAGE</td><td align="center">表示用于包</td></tr></tbody></table><p>也有RetentionPolicy类，表示Annotation的有效范围（使用@Retention）</p><table><thead><tr><th align="center">枚举常量</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">SOURCE</td><td align="center">表示不编译Annotation到类文件中，有效范围最小</td></tr><tr><td align="center">CLASS</td><td align="center">表示编译Annotation盗垒文件中，但是在运行时不加载Annotation到JVM中</td></tr><tr><td align="center">RUNTIME</td><td align="center">表示在运行时加载Annotation到JVM中，有效范围最大</td></tr></tbody></table><br/><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class EX_01 &#123;    @Ex_01_1(describe &#x3D; &quot;编号&quot;, type &#x3D; int.class)&#x2F;&#x2F;Java的Annotation提供了自定义注释的方法，可以对特定的代码块进行注释    private int id;    @Ex_01_1(describe &#x3D; &quot;姓名&quot;, type &#x3D; String.class)    private String name;    @Ex_01_2(&quot;初始化构造方法&quot;)    public EX_01(int id, String name)&#123;        this.id &#x3D; id;        this.name &#x3D; name;    &#125;    @Ex_01_2()&#x2F;&#x2F;调用注释中的默认值&quot;默认构造方法&quot;    public EX_01()&#123;        this(0, &quot;cxy&quot;);    &#125;    @Ex_01_1(describe &#x3D; &quot;获取姓名&quot;, type &#x3D; String.class)    public String getName() &#123;        return name;    &#125;    @Ex_01_1(describe &#x3D; &quot;设置姓名&quot;)&#x2F;&#x2F;默认参数值为void.class    public void setName(String name) &#123;        this.name &#x3D; name;    &#125;    @Ex_01_1(describe &#x3D; &quot;获取编号&quot;, type &#x3D; int.class)    public int getId() &#123;        return id;    &#125;    @Ex_01_1(describe &#x3D; &quot;设置编号&quot;)    public void setId(int id) &#123;        this.id &#x3D; id;    &#125;&#125;class Main&#123;    public static void main(String[] args) &#123;        EX_01 e &#x3D; new EX_01();        System.out.println(e.getId() + &quot; &quot; + e.getName());        e.setId(20032025);        e.setName(&quot;cmk&quot;);        System.out.println(e.getId() + &quot; &quot; + e.getName());    &#125;&#125;&#x2F;&#x2F;以下是两个接口的代码import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Target(&#123;ElementType.FIELD, ElementType.METHOD, ElementType.PARAMETER&#125;)@Retention(RetentionPolicy.RUNTIME)public @interface Ex_01_1 &#123;    String describe();&#x2F;&#x2F;定义一个没有默认值的String类型成员    Class type() default void.class;&#x2F;&#x2F;定义一个具有默认值的Class值成员&#125;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Target(ElementType.CONSTRUCTOR)@Retention(RetentionPolicy.RUNTIME)public @interface Ex_01_2 &#123;    String value() default &quot;默认构造方法&quot;;&#x2F;&#x2F;定义一个具有默认值的String型成员&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>当然，在这之上，你也可以获取Annotation中的信息</p><p>不过，这个东西实在太麻烦了，就不讲了</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++ IO文件操作&amp;c++11新规则</title>
      <link href="2021/06/06/c-IO%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C-c++11%E6%96%B0%E8%A7%84%E5%88%99/"/>
      <url>2021/06/06/c-IO%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C-c++11%E6%96%B0%E8%A7%84%E5%88%99/</url>
      
        <content type="html"><![CDATA[<h3 id="文件操作基本理解"><a href="#文件操作基本理解" class="headerlink" title="文件操作基本理解"></a>文件操作基本理解</h3><br/><p>文件操作包含在头文件<code>fstream</code>中，打开文件之后编译器是可以自动关闭的，也可以使用显式方法close()来关闭文件（推荐）</p><p>对于一般的文本读写，可以直接使用&gt;&gt;和&lt;&lt;，并且对于某些需要char *类型的函数，如果使用了string类型，可以使用c_str()来将其转化成c语言风格的字符串</p><p>（使用is_open()查看是否成功打开文件）</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;fstream&gt;#include &lt;cstdlib&gt;using namespace std;void CreateFile(string fileName);void ReadFile(string fileName);int main()&#123;    CreateFile(&quot;0x01.txt&quot;);    ReadFile(&quot;0x01.txt&quot;);    return 0;&#125;void CreateFile(string fileName)&#123;    ofstream fout(fileName.c_str());    string str;    if(!fout)&#123;        cout &lt;&lt; &quot;Open Error&quot; &lt;&lt; endl;        exit(1);    &#125;    cin &gt;&gt; str;    while(str !&#x3D; &quot;#&quot;)&#123;        fout &lt;&lt; str &lt;&lt; endl;        cin &gt;&gt; str;    &#125;    fout.close();&#125;void ReadFile(string fileName)&#123;    ifstream fin(fileName.c_str());    string str;    if(!fin)&#123;        cout &lt;&lt; &quot;Open Error&quot; &lt;&lt; endl;        exit(1);    &#125;        while(getline(fin, str, &#39;\n&#39;))&#123;        cout &lt;&lt; str &lt;&lt; endl;    &#125;    fin.close();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>当然你可以使用用一个对象进行多个文件打开的操作，不过要记得显式关闭并且清除流中的残余</p><p>（使用clear()&amp;close()）</p><br/><h3 id="命令行处理"><a href="#命令行处理" class="headerlink" title="命令行处理"></a>命令行处理</h3><br/><p>c++有在能在命令行环境中运行的程序能后访问命令行参数的机制（这个参数和Java有点像）</p><p>具体表现为<code>int main(int argc, char *argv[])</code>，前者表示命令行参数的个数，后者变量则为一个指针（储存这命令行变量）。argv[0]就表示第一个命令行参数</p><br/><h3 id="文件模式精确操作"><a href="#文件模式精确操作" class="headerlink" title="文件模式精确操作"></a>文件模式精确操作</h3><br/><table><thead><tr><th align="center">常量</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">ios_base::in</td><td align="center">打开文件，以便读取</td></tr><tr><td align="center">ios_base::out</td><td align="center">打开文件，以便写入</td></tr><tr><td align="center">ios_base::ate</td><td align="center">打开文件，并移到文件尾</td></tr><tr><td align="center">ios_base::app</td><td align="center">追加到文件尾（打开时不会重置文件内容）</td></tr><tr><td align="center">ios_base::trunc</td><td align="center">如果文件存在，则截短文件</td></tr><tr><td align="center">ios_base::binary</td><td align="center">二进制文件</td></tr></tbody></table><p>ios_base::app模式只允许将数据添加到文件尾</p><p>ios_base::ate模式将指针放到文件尾</p><br/><h3 id="二进制文件"><a href="#二进制文件" class="headerlink" title="二进制文件"></a>二进制文件</h3><br/><p>在C语言中就有接触过二进制文件，后缀尾dat</p><p>对于二进制文本的读写需要使用write()&amp;read()，第一个参数表示目标字符，第二个参数则是字符的大小</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;fstream&gt;#include &lt;cstdlib&gt;#include &lt;string&gt;using namespace std;class Student&#123;    private:        char number[20];        char name[20];        char sex[5];        int scores;    public:        Student(char *nu &#x3D; &quot;&quot;, char *na &#x3D; &quot;&quot;, char *se &#x3D; &quot;&quot;, int s &#x3D; 0);        friend ostream&amp; operator&lt;&lt;(ostream &amp;out, const Student &amp;s);&#125;;Student::Student(char *nu, char *na, char *se, int s)&#123;    strcpy_s(number, nu);    strcpy_s(name, na);    strcpy_s(sex, se);    scores &#x3D; s;&#125;ostream&amp; operator&lt;&lt;(ostream &amp;out, const Student &amp;s)&#123;    out &lt;&lt; s.number &lt;&lt; &quot; &quot; &lt;&lt; s.name &lt;&lt; &quot; &quot; &lt;&lt; s.sex &lt;&lt; &quot; &quot; &lt;&lt; s.scores &lt;&lt; endl;    return out;&#125;void CreateBiFile(string filename);void ReadBiFile(string filename);int main()&#123;    CreateBiFile(&quot;stu.dat&quot;);    ReadBiFile(&quot;stu.dat&quot;);    return 0;&#125;void CreateBiFile(string filename)&#123;    ofstream out(filename.c_str());    if(!out)&#123;        cerr &lt;&lt; &quot;File open error&quot; &lt;&lt; endl;        exit(1);    &#125;    Student stu[3] &#x3D; &#123;Student(&quot;B20032025&quot;, &quot;陈鑫扬&quot;, &quot;男&quot;, 99),    Student(&quot;B20032024&quot;, &quot;陈彦轩&quot;, &quot;男&quot;, 98),    Student(&quot;B20032023&quot;, &quot;陈科廷&quot;, &quot;男&quot;, 87)&#125;;    out.write((char *)stu, sizeof(Student) * 3);    out.close();&#125;void ReadBiFile(string filename)&#123;    Student stu[5];int i &#x3D; 0;    ifstream in(filename.c_str());    if(!in)&#123;        cerr &lt;&lt; &quot;File open error&quot; &lt;&lt; endl;        exit(1);    &#125;    while(!in.eof())&#123;        in.read((char *)&amp;stu[i++], sizeof(Student));    &#125;    for(i &#x3D; 0; i &lt; 3; i++)&#123;        cout &lt;&lt; stu[i];    &#125;    in.close();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>C++也有将指针进行位移的函数，seekg将输入指针移动到指定位置，seekp将输出指针移动到指定位置</p><p>包含两个参数，第一个是位移量，第二个是相对位置</p><p>相对位置包含三个，ios_base::beg（开始位置）；ios_base::cur（当前位置）；ios_base::end（末尾）</p><br/><h3 id="C-11新定义"><a href="#C-11新定义" class="headerlink" title="C++11新定义"></a>C++11新定义</h3><br/><h4 id="新类型"><a href="#新类型" class="headerlink" title="新类型"></a>新类型</h4><br/><p>c++11新增了类型long long&amp;unsigned long long</p><p>char16_t&amp;char32_t，以支持16位和32位的字符表示</p><p>c++11新增了右值(rvalue)的引用，使用&amp;&amp;表示，右值引用可关联到右值（可以出现在赋值的右边），但不能取地址</p><p>原本的左值(value)可以出现在赋值语句的左边，但是const修饰符出现之后就不行了，但是地址仍然可以使用</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">const int b &#x3D; 101;&#x2F;&#x2F;这样b就不能成为可使用的左值了，但是&amp;b仍然可用const int &amp;rb &#x3D; b;int x &#x3D; 10;int y &#x3D; 33;int &amp;&amp;r1 &#x3D; x + y;&#x2F;&#x2F;这样我们规定的右值引用就可以放在赋值符左边<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><h4 id="统一的初始化"><a href="#统一的初始化" class="headerlink" title="统一的初始化"></a>统一的初始化</h4><br/><p>c++11扩大了大括号的使用范围，可以添加等号（=），也可以不添加</p><p>虽然不能随便的类型转化，但是只要对应类型存在对应的值，就可以进行转化</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int x &#x3D; &#123;23&#125;;double y&#123;2.5&#125;;short sqrt&#123;4.2, 5.6&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><br/><p>在能够使用大括号初始化后，就可以进行传入模板的操作了</p><p>c++中提供了initializer_list模板，可将其用作构造函数的参数，包含在头文件<code>initializer_list</code></p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;initializer_list&gt;using namespace std;double sum(initializer_list&lt;double&gt; li);int main()&#123;    cout &lt;&lt; sum(&#123;1.5, 23.7&#125;) &lt;&lt; endl;        return 0;&#125;double sum(initializer_list&lt;double&gt; li)&#123;    double total &#x3D; 0;    for(auto i &#x3D; li.begin(); i &lt; li.end(); i++)&#123;&#x2F;&#x2F;initializer_list&lt;double&gt; li::iterator i        total +&#x3D; *i;    &#125;    return total;&#125;&#x2F;&#x2F;多多使用auto自动声明<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>可以使用decltype强制让一个变量成为某种类型</p><p><code>decltype(x * n) p</code>此时p就为x * n的类型，这可以在定义模板时起到作用（因为模板类只有到最后才知道类型）</p><p>此外，c++11还新增了一种返回值后置的写法。这种写法将返回的类型在后面指定，这样就可以使用decltype指定类型</p><p><code>auto sum(int x, double y)-&gt;double</code></p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template&lt;typename T, typename U&gt;auto eff(T t, U u)-&gt;decltype(T * U)&#123;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><br/><h4 id="重命名"><a href="#重命名" class="headerlink" title="重命名"></a>重命名</h4><br/><p>对于一些冗长的标识符，可以使用重命名的方式。以前提供的是typedef，c++11现提供了using=</p><p>这对于模板的具体化可以进行重命名，typedef则不行（使用新规则的可读性更强了）</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;&#x2F;&#x2F; typedef vector&lt;string&gt;::iterator itType;using itType &#x3D; vector&lt;string&gt;::iterator;int main()&#123;    vector&lt;string&gt;v&#123;&quot;cxy&quot;, &quot;cyx&quot;, &quot;ckt&quot;, &quot;cmk&quot;&#125;;    for(itType i &#x3D; v.begin(); i &lt; v.end(); i++)&#123;        cout &lt;&lt; *i &lt;&lt; &quot; &quot;;    &#125;    cout &lt;&lt; endl;    return 0;&#125;template&lt;typename T&gt;using arr12 &#x3D; array&lt;T, 12&gt;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><h4 id="小细节优化"><a href="#小细节优化" class="headerlink" title="小细节优化"></a>小细节优化</h4><br/><p>在枚举方法中，原本的枚举的变量是不能重名的。c++11新增可以使用struct或者class，这种枚举的使用很类似类和对象的不同方法的调用</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">enum class new1 &#123;q, w, e, r&#125;;enum struct new2 &#123;q, w, e, r&#125;;&#x2F;&#x2F;在具体区分时，可以使用new1::q<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><br/><p>原本为了避免使用模板时多个&gt;导致编译混淆，需要使用空格来区分，现在不需要了</p><p><code>vector&lt;list&lt;int&gt; &gt; v1; vector&lt;list&lt;int&gt;&gt; v1;</code></p><p>初次之外，如果基类定义了多个重载的构造函数fin，在派生的定义中就可以使用<code>using c1::fin;</code>来时派生类访问所有的基类构造函数</p><br/><h4 id="Lambda函数"><a href="#Lambda函数" class="headerlink" title="Lambda函数"></a>Lambda函数</h4><br/><p>lambda的作用就是让程序员能使用一个匿名的函数（使用[]代替函数名），这在大篇幅代码的文件中比较实用</p><p>这里使用模板来举例，generate()接受一个区间（由前两个区间决定），最后一个参数是不接受任何参数的函数对象</p><p>使用cout_if()则是可以计算区间内有多少元素符合规定的要求</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;cstdlib&gt;#include &lt;ctime&gt;#include &lt;algorithm&gt;using namespace std;int main()&#123;    vector&lt;int&gt; v(5);    srand((unsigned int)(time(NULL)));    generate(v.begin(), v.end(), rand);    for_each(v.begin(), v.end(), [](int x)&#123;cout &lt;&lt; x &lt;&lt; &quot; &quot;;&#125;);&#x2F;&#x2F;输出模板中的值    cout &lt;&lt; endl;    cout &lt;&lt; count_if(v.begin(), v.end(), [](int x)&#123;return x % 3 &#x3D;&#x3D; 0;&#125;) &lt;&lt; endl;&#x2F;&#x2F;判断模板中有多少值可以被3整除    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>但是这种新型的语法反而使可读性变差了，但是实际上，有些时候并非如此</p><p>如果一个文件中的代码量很多，对应表达式函数的代码往往是很难找到的，而且lambda也可以采用以下方式应用于多个要求使用同一个函数的代码参数</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">auto mod3 &#x3D; [](int x)&#123;return x % 3 &#x3D;&#x3D; 0;&#125;int count1 &#x3D; count_if(v1.begin(), v1.end(), mod3);int count2 &#x3D; count_if(v2.begin(), v2.end(), mod3);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++ 输入</title>
      <link href="2021/05/22/c-%E8%BE%93%E5%85%A5/"/>
      <url>2021/05/22/c-%E8%BE%93%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<h3 id="c-对-gt-gt-运算符的重载"><a href="#c-对-gt-gt-运算符的重载" class="headerlink" title="c++对&gt;&gt;运算符的重载"></a>c++对&gt;&gt;运算符的重载</h3><br/><p>cin也可以像cout一样格式化输入格式，比如<code>cin &gt;&gt; hex</code>，将会把输入的12（0x12）理解成十进制的18或者十六进制的12</p><p>同时也可以直接使用cin来输入string或者是char *等类型，输入时编译器会自动在末尾处添加\0（空字符）（表示字符串）</p><p>在检查cin输入是否合理时，它会从非空白字符开始，一直到不同类型的第一个字符结束</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;using namespace std;int main()&#123;    int count &#x3D; 0;    int num;    while(cin &gt;&gt; num)&#123;        count++;        cout &lt;&lt; count &lt;&lt; &quot; : &quot; &lt;&lt; num &lt;&lt; endl;    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>c++中通过一些成员表示流的状态，一般为1（设置）、0（清除）</p><table><thead><tr><th align="center">成员</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">eofbit</td><td align="center">如果到达文件尾，则设置为1</td></tr><tr><td align="center">badbit</td><td align="center">如果流被破坏，则设置为1（比如：文件读取错误）</td></tr><tr><td align="center">failbit</td><td align="center">如果输入操作未能读取预期的字符或输出操作没有写入预期的字符，则设置为1</td></tr><tr><td align="center">eof()</td><td align="center">如果eofbit设置，则返回true</td></tr><tr><td align="center">bad()</td><td align="center">如果badbit设置，则返回true</td></tr><tr><td align="center">fail()</td><td align="center">如果badbit或failbit被设置，则返回true</td></tr><tr><td align="center">exceptions()</td><td align="center">返回一个位掩码，指出哪些标记导致异常被引发</td></tr><tr><td align="center">setstate()</td><td align="center">设置输入流中的错误</td></tr><tr><td align="center">clear()</td><td align="center">将流状态设置为s：s的默认值为0(goodbit)</td></tr></tbody></table><br/><p>clear()&amp;setstate()很相似，都可以重置状态，但是采取的方式不同</p><p>默认的clear()方法将三个为全部设置为0，但如果是clear(eofbit)，就是只将eofbit设置，其他被清除</p><p>setstate()方法之影响其参数中已设置的位，setstate(eofbit)，这个将设置eofbit（其他位不会受到影响）</p><p>exceptions()默认设置为goodbit（此时使用clear()&amp;setstate()修改位的状态不会出现问题，无法引发异常），如果将默认值修改为badbit，重载的函数就能控制这种行为（引发ios_base::failure异常，该类包含在exception类中）</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;exception&gt;using namespace std;int main()&#123;    cin.exceptions(ios_base::failbit);    cout &lt;&lt; &quot;Enter a number:&quot; &lt;&lt; endl;    int sum &#x3D; 0;    int input;    try&#123;        while(cin &gt;&gt; input)&#123;            sum +&#x3D; input;        &#125;    &#125;catch(ios_base::failure &amp;ibf)&#123;        cout &lt;&lt; ibf.what() &lt;&lt; endl;        cout &lt;&lt; &quot;Error&quot; &lt;&lt; endl;    &#125;    cout &lt;&lt; &quot;Last value &#x3D; &quot; &lt;&lt; input &lt;&lt; endl;    cout &lt;&lt; &quot;sum &#x3D; &quot; &lt;&lt; sum &lt;&lt; endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>如果在流意外错误结束的时候继续选择输入，将会失败（对后面的输入和输出关闭，直到流被清除）</p><p>可以使用两种方法，一个为isspace()函数，不断读取字符直到空白为止；另一种方法是使用get()，直接丢弃行中的剩余部分（）（如果想重读取数据，一般使用后者方法）</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">cin.clear();while(!isspace(cin.get()))&#123;&#x2F;&#x2F;依然会读取已存在    continue;&#125;cin &gt;&gt; input;cout &lt;&lt; &quot;new value &#x3D; &quot; &lt;&lt; input &lt;&lt; endl;cin.clear();while(cin.get() !&#x3D; &#39;\n&#39;)&#123;    continue;&#125;cin &gt;&gt; input;cout &lt;&lt; &quot;new value &#x3D; &quot; &lt;&lt; input &lt;&lt; endl;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><h3 id="单字符输入"><a href="#单字符输入" class="headerlink" title="单字符输入"></a>单字符输入</h3><br/><p>在使用cin的输入方式中，如果想要输入空格，那便是比较尴尬的一件事情</p><p>因为space和’\n’都是编译器判断是否输入下个字符的依据，那么此时就应该使用get来避免错误</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;using namespace std;int main()&#123;    int count;    char ch;    cin.get(ch);    while(ch !&#x3D; &#39;\n&#39;)&#123;&#x2F;&#x2F;但是不能使用cin &gt;&gt; ch进行判断        cout &lt;&lt; ch;        count++;        cin.get(ch);        &#125;    cout &lt;&lt; endl &lt;&lt; count &lt;&lt; endl;        return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>单字符输入函数的cin.get(ch)和ch = cin.get()的特征是不一样的</p><p>因为cin.get()的返回值是int（或者更大储存范围的整形），但是并不是类对象。<code>cin.get().get() &gt;&gt; c3;</code>这种语句是违法的</p><table><thead><tr><th align="center">特征</th><th align="center">cin.get(ch)</th><th align="center">ch = cin.get()</th></tr></thead><tbody><tr><td align="center">传输输入字符的方法</td><td align="center">赋给参数ch</td><td align="center">将函数返回值赋给ch</td></tr><tr><td align="center">字符输入时函数的返回值</td><td align="center">指向istream对象的引用</td><td align="center">字符编码（int值）</td></tr><tr><td align="center">达到文件尾时函数的返回值</td><td align="center">转换为false</td><td align="center">EOF</td></tr></tbody></table><br/><h3 id="字符串输入"><a href="#字符串输入" class="headerlink" title="字符串输入"></a>字符串输入</h3><br/><p>在字符串中，我们一般使用getline()、get()、ignore()进行输入</p><p>对于前两种方法，都有两个重载，一种是两个参数，另一种是三个参数</p><p>第一个参数表示输入字符串的储存位置，第二个参数表示输入字符的数量（需要比实际输入量多一，用来储存’\0’），第三个被称作为分界符的字符（读取到特定字符时就判定尾停止输入字符）。在两个参数的函数中，默认换行符为分界符</p><p>（get和getline的区别在于，后者会舍弃分界符，而前者不会）</p><p>ignore()通常用来舍弃输入流中的字符，通过<code>ignore(255, &#39;\n&#39;)</code>就能舍弃一整行的255个字符</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;using namespace std;const int Limit &#x3D; 25;int main()&#123;    char input[Limit];    cin.getline(input, Limit, &#39;#&#39;);    cout &lt;&lt; input &lt;&lt; endl;    char ch;    cin.get(ch);&#x2F;&#x2F;读取输入流中剩下的字符    cout &lt;&lt; ch &lt;&lt; endl;&#x2F;&#x2F;输出将会为#之后的一个字符    cin.ignore(Limit, &#39;\n&#39;);&#x2F;&#x2F;清除流中剩余的字符    cin.get(input, Limit, &#39;#&#39;);    cout &lt;&lt; input &lt;&lt; endl;    cin.get(ch);    cout &lt;&lt; ch &lt;&lt; endl;&#x2F;&#x2F;这里将会输出#（get会保留分界字符）    cin.ignore(Limit, &#39;\n&#39;);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><h3 id="意外字符输入"><a href="#意外字符输入" class="headerlink" title="意外字符输入"></a>意外字符输入</h3><br/><p>对于意外输入的字符，一般都是通过setstate设置failbit来引发错误</p><p>但是有些时候这种方法并不能使用，一是输入方法一开始就在文件尾，另一种就是输入了空行（’\0’）</p><p>解决办法也比较简单，使用<code>while(cin.getline(temp, 80) &amp;&amp; temp[0] != &#39;\0&#39;)</code>判断即可</p><p>（在getline(temp, 30)中，如果字符输入数为29并且最后一个字符为换行符，则编译器会自动删除；如果不是就会设置failbait，超出设定的字符长度）</p><br/><h3 id="istream中的其他方法"><a href="#istream中的其他方法" class="headerlink" title="istream中的其他方法"></a>istream中的其他方法</h3><br/><p>peek()字符返回输入中的下一个字符，可以在向数组中输入字符时防止流中有残余</p><p>gcount()方法返回最后一个非格式化抽取方法抽取的字符数（作用于使用get()、getline()、ignore()、read()读取的字符）</p><p>（如果是&gt;&gt;向数组中输入，则使用strlen的效率更高）</p><p>putback()函数将将一个字符插入到输入字符串中，被插入的字符将是下一条输入语句读取的第一个字符</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;using namespace std;int main()&#123;    char ch;    while(cin.peek() !&#x3D; &#39;#&#39;)&#123;        cin.get(ch);        cout &lt;&lt; ch;    &#125;    if(!cin.eof())&#123;        cin.get(ch);        cout &lt;&lt; endl &lt;&lt; ch &lt;&lt; &quot;next character&quot; &lt;&lt; endl;&#x2F;&#x2F;输出#     &#125;else&#123;        cout &lt;&lt; &quot;last line&quot; &lt;&lt; endl;    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++ 输出</title>
      <link href="2021/05/20/c-%E8%BE%93%E5%87%BA/"/>
      <url>2021/05/20/c-%E8%BE%93%E5%87%BA/</url>
      
        <content type="html"><![CDATA[<h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><br/><p>你们可能并不知道c++输如输入数据的原理。在输入过程中，c++程序只是检查字节流，而并不检查字节的来源（可能来自于硬盘、键盘或者其他外设）。在处理输出方式时将独立于其去向，分为将流和输入去向的程序关联起来&amp;将流与文件连接起来</p><p>通常使用缓冲区来提高输入输出的效率。从磁盘文件中读取字符需要大量的硬件活动，因此大量重复这个过程将会非常浪费时间。缓冲方法就是先将信息存储在缓冲区中，然后每次从缓冲区读取一个字节，这比直接从磁盘中读取要快很多</p><blockquote><p>streambuf：为缓冲区提供了内存，提供了用于缓冲区的各种方法</p><p>ios_base：表示流的一般特征，如是否可读取、是二进制流还是文本流 </p><p>ios：基于ios_base类，包含一个指向streambuf的指针成员</p></blockquote><br/><h3 id="使用cout进行输出"><a href="#使用cout进行输出" class="headerlink" title="使用cout进行输出"></a>使用cout进行输出</h3><br/><p>可以通过输入重定向（&lt;）和输出重定向（&gt;），大多数的输入输出都连接着屏幕和键盘</p><p>cout代表的是标准输出是程序的输出的常用通道，标准错误流（由cerr&amp;clog代表），用于输出错误信息</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;cstdlib&gt;using namespace std;int main()&#123;    int success;    if(cin &gt;&gt; success)&#123;&#x2F;&#x2F;这里否定的条件是程序异常终止导致值没有正常输入        cout &lt;&lt; &quot;nice&quot; &lt;&lt; endl;    &#125;else&#123;        cerr &lt;&lt; &quot;error&quot; &lt;&lt; endl;        exit(EXIT_FAILURE);    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p><code>&lt;&lt;</code>也被重载，可以拼接使用（这个比较常用）</p><p>除此之外还提供了put()&amp;write()方法，前者用于输出字符，后者用于输出字符串</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;using namespace std;int main()&#123;    cout.put(&#39;A&#39;);    cout &lt;&lt; endl;    cout.put(65).put(65.3);&#x2F;&#x2F;通过.来连接输出    &#x2F;&#x2F;上面三个输出的结果是一样的，put会将数值当成asc码（double类型会直接类型转换）    cout &lt;&lt; endl &lt;&lt; &#39;A&#39; &lt;&lt; endl;    &#x2F;&#x2F;在一些较老版本的c++中（c++2.0之前），会用int类型表示字符，这里结果就会是67（所以需要使用put）    &#x2F;&#x2F;但是现在都是直接用char类型来解释，两种方法都可以    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>个人感觉write方法使用的时候更像是for的范围循环，因为可以输出字符串中单个字符或者固定长度的字符</p><p>（要求必须是char类型的数组（指针），string无法通过转换从而使用）</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;int main()&#123;    const char *str1 &#x3D; &quot;cxy,nice&quot;;    long val &#x3D; 987654321;    int i;    for(i &#x3D; 1; i &lt;&#x3D; strlen(str1); i++)&#123;        cout.write(str1, i) &lt;&lt; endl;&#x2F;&#x2F;一个表示需要的数组，一个表示输出的长度    &#125;    cout.write((char *) &amp;val, sizeof(val)) &lt;&lt; endl;&#x2F;&#x2F;该输出结果是一个乱码    &#x2F;&#x2F;将数值强制转换为char *，此时当作传输内存中存储的位表示    &#x2F;&#x2F;上述的long的四个字节将作为ASCII码独立输出，最后的结果是4个字符的组合，可能是乱码    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>c++输出可以使用flush来刷新缓存区，如果没有这个操作，程序在输入的时候将会先等待数值输入完毕，而不会输出其他提示信息</p><p>这个本身也是个函数，可以使用<code>flush(cout)</code>，当然c++重载了函数，使得使用更加方便</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;using namespace std;int main()&#123;    cout &lt;&lt; &quot;looking for love&quot; &lt;&lt; flush;    cout &lt;&lt; &quot;Waiting...&quot; &lt;&lt; endl;&#x2F;&#x2F;endl和flush都是刷新缓存区，endl在刷新之后还会添加一个换行符flush(cout);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><h3 id="cout的精确设置"><a href="#cout的精确设置" class="headerlink" title="cout的精确设置"></a>cout的精确设置</h3><br/><p>1.和c++也提供了更改输出格式的方法，使用dec、hex、oct更改进制（十进制、十六进制、八进制）</p><p>2.由于cout代替printf，所以c++使用width方法代替原c语言中的，这个方法可以设定字段宽度（注意：这个方法是一次性的，只能设定一个cout语句，结束之后恢复默认值）</p><p>3.在设置宽度之后，自然就会存在空余空间，c++默认使用space来填充</p><p>当然可以使用fill方法来使用字符来设置填充字符</p><p>4.需要控制浮点数显示位数的时候，就需要使用precision方法了（这个精度是包括前面的数的，0不算位（这个在c语言中有较大的篇幅提及））（c++的默认精度为6但是不会显示末尾的0）。跟width不同的是，这个东西是一直持续的，并不会默认恢复</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;using namespace std;int main()&#123;    int num &#x3D; 251;        hex(cout);&#x2F;&#x2F;也可以使用cout &lt;&lt; hex;    cout &lt;&lt; num &lt;&lt; endl;    oct(cout);    cout &lt;&lt; num &lt;&lt; endl;    dec(cout);    cout &lt;&lt; num &lt;&lt; endl;        cout.fill(&#39;-&#39;);    cout &lt;&lt; &quot;num&quot;;    cout.width(5);     cout &lt;&lt; num &lt;&lt; endl;&#x2F;&#x2F;只对单个插入符内部有效，如果是拼接的只会作用于第一部分    double x &#x3D; 0.1;    cout.precision(1);    cout &lt;&lt; x &lt;&lt; endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><h3 id="setf的各种使用"><a href="#setf的各种使用" class="headerlink" title="setf的各种使用"></a>setf的各种使用</h3><br/><p>通常使用setf进行格式化输出，c语言中并没有这种规范化的定义（c++引入类的定义）</p><p>先介绍setf第一个版本，只是用一个参数</p><table><thead><tr><th align="center">常量</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">ios_base::boolalpha</td><td align="center">输入和输出bool值，可以为true&amp;false</td></tr><tr><td align="center">ios_base::showbase</td><td align="center">对于输出，使用c++基数前缀（0，0x）</td></tr><tr><td align="center">ios_base::showpoint</td><td align="center">输出末尾的小数点</td></tr><tr><td align="center">ios_base::upercase</td><td align="center">对于16进制的输出，使用大写字母，E表示法</td></tr><tr><td align="center">ios_base::showpos</td><td align="center">在正数前面加上+（只对十进制有效）</td></tr></tbody></table><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;using namespace std;int main()&#123;    double x &#x3D; 25.1;    cout.setf(ios_base::showpoint);    cout &lt;&lt; x &lt;&lt; endl;&#x2F;&#x2F;补充剩下的0        int temperature &#x3D; 29;    cout.setf(ios_base::showpos);    cout.setf(ios_base::uppercase);    cout.setf(ios_base::showbase);    cout &lt;&lt; temperature &lt;&lt; endl;    cout &lt;&lt; hex &lt;&lt; temperature &lt;&lt; endl;&#x2F;&#x2F;不会自动添加+号    cout &lt;&lt; dec &lt;&lt; true &lt;&lt; endl;&#x2F;&#x2F;默认true输出值为1    cout.setf(ios_base::boolalpha);    cout &lt;&lt; true &lt;&lt; endl;&#x2F;&#x2F;此时可以直接正常输出true    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>另一个版本的setf的使用在类和对象中有介绍过，使用两个参数</p><p>可以对cout进行更加精确的格式化控制</p><br/><p>第二个参数                    第一个参数                    含义<br>ios_base::basefield    ios_base::dec                使用10进制<br>                                 ios_base::oct                使用8进制<br>                                  ios_base::hex                使用16进制<br>ios_base::floatfield    ios_base::fixed                使用定点计数法(即一般计数法)<br>                                  ios_base::scientific        使用科学计数法<br>ios_base::adjustfield    ios_base::left                左对齐<br>                                    ios_base::right                右对齐<br>                                    ios_base::internal        符合或前缀左对齐，值右对齐<br><br/></p><p>虽然看起来比较麻烦，但是只要记住基本的归类，加上vscode的代码提示，还是很方便的就能写出来</p><p>调用的setf方法可以通过unsetf方法消除，如果将设置的setf位设置位1，unsetf位就是恢复为0</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">cout.setf(ios_base::showpoint);cout.unsetf(ios_base::showpoint);cout.setf(ios_base::boolalpha);cout.unsetf(ios_base::boolalpha);cout.setf(0, ios_base::floatfield);&#x2F;&#x2F;因为floatfield时是没有专门的显示标记的，所以可以直接使用0作为默认<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>当然使用setf方法并不是最好的格式化方式，c++提供了多个控制符，可以代替使用setf方法</p><p>这样之后可以直接使用简短的控制符，代替长串的setf代码</p><table><thead><tr><th align="center">控制符</th><th align="center">调用</th></tr></thead><tbody><tr><td align="center">boolalpha</td><td align="center">setf(ios_base::boolalpha)</td></tr><tr><td align="center">noboolalpha</td><td align="center">unsetf(ios_base::noboolalpha)</td></tr><tr><td align="center">showbase</td><td align="center">setf(ios_base::showbase)</td></tr><tr><td align="center">noshowbase</td><td align="center">unsetf(ios_base::showbase)</td></tr><tr><td align="center">showpos</td><td align="center">setf(ios_base::showpos)</td></tr><tr><td align="center">noshowpos</td><td align="center">unsetf(ios_base::showpos)</td></tr><tr><td align="center">uppercase</td><td align="center">setf(ios_base::uppercase)</td></tr><tr><td align="center">nouppercase</td><td align="center">unsetf(ios_base::uppercase)</td></tr><tr><td align="center">internal</td><td align="center">setf(ios_base::internal, ios_base::adjustfield)</td></tr><tr><td align="center">left</td><td align="center">setf(ios_base::left, ios_base::adjustfield)</td></tr><tr><td align="center">right</td><td align="center">setf(ios_base::right, ios_base::adjustfield)</td></tr><tr><td align="center">dec</td><td align="center">setf(ios_base::dec, ios_base::basefield)</td></tr><tr><td align="center">hex</td><td align="center">setf(ios_base::hex, ios_base::basefield)</td></tr><tr><td align="center">oct</td><td align="center">setf(ios_base::oct, ios_base::basefield)</td></tr><tr><td align="center">fixed</td><td align="center">setf(ios_base::fixed, ios_base::floatfield)</td></tr><tr><td align="center">scientific</td><td align="center">setf(ios_base::scientific, ios_base::floatfield)</td></tr></tbody></table><br/><p>在头文件<code>iomanip</code>中，定义了一些其他的控制符，可以更加精确控制输出</p><p>常用的就是为setprecision()、setfill()、setw()分别对应设置精度，填充字符，宽度（只不过是控制符，可以直接在插入运算符中使用）</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;iomanip&gt;#include &lt;cmath&gt;using namespace std;int main()&#123;    &#x2F;&#x2F;如果要使用iostream中的表达式，应为cout.width(6),这样写太繁琐    cout &lt;&lt; setw(6) &lt;&lt; &quot;N&quot; &lt;&lt; setw(16) &lt;&lt; &quot;square result&quot; &lt;&lt; endl;    cout &lt;&lt; fixed;&#x2F;&#x2F;使用一般计数法,在不使用一般计数法时，precision表示总位数；设置之后表示小数精度    for(int n &#x3D; 10; n &lt;&#x3D; 100; n +&#x3D; 10)&#123;        cout &lt;&lt; setw(6) &lt;&lt; setfill(&#39;~&#39;) &lt;&lt; n &lt;&lt; setw(16) &lt;&lt; setfill(&#39; &#39;)&lt;&lt; setprecision(4) &lt;&lt; sqrt(double(n)) &lt;&lt; endl;    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++ 函数对象&amp;算法&amp;标准库 p3</title>
      <link href="2021/05/15/c-%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1-%E7%AE%97%E6%B3%95-%E6%A0%87%E5%87%86%E5%BA%93-p3/"/>
      <url>2021/05/15/c-%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1-%E7%AE%97%E6%B3%95-%E6%A0%87%E5%87%86%E5%BA%93-p3/</url>
      
        <content type="html"><![CDATA[<h3 id="预定义函数符"><a href="#预定义函数符" class="headerlink" title="预定义函数符"></a>预定义函数符</h3><br/><p> transform()：</p><p>重载一：四个参数，前两个为指定容器区间的迭代器，第三个参数表示复制对象的容器，最后一个为函数符，被应用于各个元素</p><p>重载二：五个参数，在中间添加了第三个参数，表示第二个区间的起始位置</p><p>这两者也很好区分，关键在于最后的函数符是否需要两个元素</p><p>当然你也可以像for_each那样，自己定义一个函数，但是这样往往很麻烦。于是c++就将每一个运算符都规定了特定的函数符</p><br/><table><thead><tr><th align="center">运算符</th><th align="center">相应的函数符</th></tr></thead><tbody><tr><td align="center">+</td><td align="center">plus</td></tr><tr><td align="center">-（减号）</td><td align="center">minus</td></tr><tr><td align="center">*</td><td align="center">multiplies</td></tr><tr><td align="center">/</td><td align="center">divides</td></tr><tr><td align="center">%</td><td align="center">modulus</td></tr><tr><td align="center">-（负数符号）</td><td align="center">negate</td></tr><tr><td align="center">==</td><td align="center">equal_to</td></tr><tr><td align="center">!=</td><td align="center">not_equal_to</td></tr><tr><td align="center">&gt;</td><td align="center">greater</td></tr><tr><td align="center">&lt;</td><td align="center">less</td></tr><tr><td align="center">&gt;=</td><td align="center">greater_equal</td></tr><tr><td align="center">&lt;=</td><td align="center">less_equal</td></tr><tr><td align="center">&amp;&amp;</td><td align="center">logical_and</td></tr><tr><td align="center">||</td><td align="center">logical_or</td></tr><tr><td align="center">!</td><td align="center">logical_not</td></tr></tbody></table><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;iterator&gt;#include &lt;cmath&gt;using namespace std;const int N &#x3D; 5;double Sqrt(double x);int main()&#123;    double arr[N] &#x3D; &#123;36, 39, 42, 45, 48&#125;;    double array[N] &#x3D; &#123;30, 85, 62, 75, 92&#125;;    vector&lt;double&gt; v1(arr, arr + N);    vector&lt;double&gt; v2(array, array + N);    ostream_iterator&lt;double, char&gt; out(cout, &quot; &quot;);    transform(v1.begin(), v1.end(), out, Sqrt);&#x2F;&#x2F;如果将out改为v.begin()，将会覆盖原来的容器    cout &lt;&lt; endl;    transform(v1.begin(), v1.end(), v2.begin(), out, plus&lt;double&gt;());&#x2F;&#x2F;省去了定义相加函数的过程    cout &lt;&lt; endl;    transform(v1.begin(), v1.end(), v2.begin(), out, multiplies&lt;double&gt;());&#x2F;&#x2F;()已经被重载过了    cout &lt;&lt; endl;    transform(v1.begin(), v1.end(), v2.begin(), out, divides&lt;double&gt;());    cout &lt;&lt; endl;    return 0;&#125;double Sqrt(double x)&#123;    return sqrt(x);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><br/><p>1.replace() :</p><p>用新的值来替换和给定值相匹配的元素.它的前两个参数是被处理序列的正向迭代器，第 3 个参数是被替换的值，第 4 个参数是新的值</p><p>2.replace_if() ：</p><p>会将使谓词返回 true 的元素替换为新的值。它的第 3 个参数是一个谓词，第 4 个参数是新的值</p><p>3.replace_copy() ：</p><p>和 replace() 做的事是一样的，但它的结果会被保存到另一个序列中，而不会改变原始序列</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;const int N &#x3D; 5;void show(int x);int main()&#123;    int a[N] &#x3D; &#123;45, 78, 10, 5, 2&#125;;    string b &#x3D; &quot;I will kill you all!&quot;;    vector&lt;int&gt; v(a, a + N);    for_each(v.begin(), v.end(), show);    cout &lt;&lt; endl;    sort(v.begin(), v.end());    for_each(v.begin(), v.end(), show);    cout &lt;&lt; endl;    replace(v.begin(), v.end(), 5, 111);    for_each(v.begin(), v.end(), show);    cout &lt;&lt; endl;    replace_if(b.begin(), b.end(), [](char ch)&#123;return isspace(ch);&#125;, &#39;.&#39;);    &#x2F;&#x2F;isspace()判断该字符是否为空格    &#x2F;&#x2F;通过[]()&#123;&#125;的形式定义一个无名函数    cout &lt;&lt; b &lt;&lt; endl;    return 0;&#125;void show(int x)&#123;    cout &lt;&lt; x &lt;&lt; &#39;\t&#39;;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><h3 id="STL-amp-string"><a href="#STL-amp-string" class="headerlink" title="STL&amp;string"></a>STL&amp;string</h3><br/><p>string虽然并不是STL的组成部分，在上述例子中可知，它可以使用部分STL中的迭代器</p><p>next_permutation()：将区间内容转换为下一种排列方式，如果已经处于最后一种排序方式，则返回false</p><p>（唯一的自动排序算法）</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;int main()&#123;    string letters;    cout &lt;&lt; &quot;Enter a letter(quit to quit): &quot;;    while(cin &gt;&gt; letters &amp;&amp; letters !&#x3D; &quot;quit&quot;)&#123;        sort(letters.begin(), letters.end());        cout &lt;&lt; letters &lt;&lt; &quot; &quot;;        while(next_permutation(letters.begin(), letters.end()))&#123;            cout &lt;&lt; letters &lt;&lt; &quot; &quot;;        &#125;        cout &lt;&lt; endl;        cout &lt;&lt; &quot;Enter the next letter(quit to quit): &quot;;    &#125;    cout &lt;&lt; &quot;Done&quot; &lt;&lt; endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>在list中存在一个move()函数，但是这并不是成员，所以不能调整链表的长度</p><p>它将没被删除的元素放在链表的开始位置，并返回一个指向新的超尾值的迭代器，这样就可以用该迭代器修改容器的长度（可以用erase()删除一个区间）</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;list&gt;#include &lt;algorithm&gt;using namespace std;void Show(int);const int LIM &#x3D; 10;int main()&#123;    int ar[LIM] &#x3D; &#123;4, 5, 4, 2, 2, 3, 4, 8, 1, 4&#125;;    list&lt;int&gt; la(ar, ar + LIM);    list&lt;int&gt; lb(la);    cout &lt;&lt; &quot;Original list contents:&quot; &lt;&lt; endl;    for_each(la.begin(), la.end(), Show);    cout &lt;&lt; endl;    la.remove(4);&#x2F;&#x2F;此时值为4的元素已经全部删除    cout &lt;&lt; &quot;After using the remove() method:\n&quot;;    cout &lt;&lt; &quot;la: &quot;;    for_each(la.begin(), la.end(), Show);    cout &lt;&lt; endl;    list&lt;int&gt;::iterator last &#x3D; remove(lb.begin(), lb.end(), 4);&#x2F;&#x2F;返回一个超尾的迭代器    cout &lt;&lt; &quot;lb: &quot;;    for_each(lb.begin(), lb.end(), Show);&#x2F;&#x2F;从返回的值中可以看出，前面为正常的删除的结果，后面保持不变    cout &lt;&lt; endl;    lb.erase(last, lb.end());&#x2F;&#x2F;删除超出的部分    cout &lt;&lt; &quot;lb: &quot;;    for_each(lb.begin(), lb.end(), Show);    cout &lt;&lt; endl;    return 0;&#125;void Show(int v)&#123;    cout &lt;&lt; v &lt;&lt; &#39; &#39;;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>如果需要对vector的字符串类型进行排序，首先使用的就是sort()&amp;unique()，但是这种方法会覆盖原始的数据</p><p>我们可以使用set进行保存，这样可以规避这种问题（为了更加还原还是要使用对应的tolower来进行大小写转换）</p><p>当然因为tolower是char类型的，一些编译器规定要相同的类型，所以就需要再设定一个函数</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;set&gt;#include &lt;map&gt;#include &lt;iterator&gt;#include &lt;algorithm&gt;#include &lt;cctype&gt;using namespace std;char toLower(char ch)&#123; return tolower(ch);&#125;string &amp;ToLower(string &amp;st);void display(string &amp;s)&#123;cout &lt;&lt; s &lt;&lt; &quot; &quot;;&#125;int main()&#123;    vector&lt;string&gt; words;    string input;    cout &lt;&lt; &quot;Enter words(quit to quit): &quot; &lt;&lt; endl;    while(cin &gt;&gt; input &amp;&amp; input !&#x3D; &quot;quit&quot;)&#123;        words.push_back(input);    &#125;    cout &lt;&lt; &quot;your entered words : &quot; &lt;&lt; endl;    for_each(words.begin(), words.end(), display);    cout &lt;&lt; endl;    set&lt;string&gt; wordset;    transform(words.begin(), words.end(), insert_iterator&lt;set&lt;string&gt;&gt;(wordset, wordset.begin()), ToLower);    cout &lt;&lt; &quot;words in directionary: &quot; &lt;&lt; endl;    for_each(words.begin(), words.end(), display);    map&lt;string, int&gt; wordmap;    cout &lt;&lt; &quot;total words: &quot; &lt;&lt; endl;    for(auto it &#x3D; wordset.begin(); it !&#x3D; wordset.end(); it++)&#123;&#x2F;&#x2F;相当于set&lt;string&gt;::iterator it;        wordmap[*it] &#x3D; count(words.begin(), words.end(), *it);&#x2F;&#x2F;*it表示set中的值        cout &lt;&lt; *it &lt;&lt; &quot;: &quot; &lt;&lt; wordmap[*it] &lt;&lt; endl;    &#125;    return 0;&#125;string &amp;ToLower(string &amp;st)&#123;    transform(st.begin(), st.end(), st.begin(), toLower);    return st;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><h3 id="其他库"><a href="#其他库" class="headerlink" title="其他库"></a>其他库</h3><br/><h4 id="vector-amp-valarray-amp-array"><a href="#vector-amp-valarray-amp-array" class="headerlink" title="vector&amp;valarray&amp;array"></a>vector&amp;valarray&amp;array</h4><br/><p>valarray类模板是面向数值计算的，没有vector中的push_back&amp;insert()方法，但是给数学运算符提供了简单的接口</p><p>array表示长度固定的数组，也不支持上面两种方法，但是也提供像begin()的STL方法</p><p>对于需要使用数学运算符的场景，使用valarray就大大方便了（valarray还提供了sum()计算所有元素的和，size()返回元素数，max()返回最大元素值，min()返回最小的元素值）</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">vector&lt;double&gt; ved1(10), ved2(10), ved3(10);array&lt;double, 10&gt; vod1, vod2, vod3;valarray&lt;double&gt; vad1(10), vad2(10), vad3(10);transform(ved1.begin(), ved1.end(), ved2.begin(), ved3.begin(), plus&lt;double&gt;());&#x2F;&#x2F;一般vector使用的相加方法（array也可以）vad3 &#x3D; vad1 + vad2; &#x2F;&#x2F;valarray重载了+运算符，可以直接这么写transform(ved3.begin(), ved3.end(), ved3.begin(), bind1st(multiplies&lt;double&gt;(), 2.5)); vad3 &#x3D; 2.5 * vad3;vad3 *&#x3D; 2.5; &#x2F;&#x2F;甚至可以用这种形式的运算符transform(ved1.begin(), ved1.end(), ved3.begin(), log);vad3 &#x3D; log(vad1); &#x2F;&#x2F;对于数组的()也进行了重载vad3 &#x3D; vad1.apply(log);&#x2F;&#x2F;也可以使用apply方法，该方法也能用于非重载函数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>当然，除了基本的数学运算符计算，valarray还有很多特性</p><p>比如创建一个double类型的valarray对象number，<code>valarray&lt;bool&gt; vbool = number &gt; 9</code>（表示number中所有大于9的元素，返回true）</p><p>slice对象：三个参数，1.起始元素的索引，2.元素的个数，3.索引之间的跨度</p><p>假设varint是一个valarray<int>对象，<code>varlint[slice(1, 4, 3)] = 10</code>（第1、4、7、10元素被设置为10）</p><br/><h4 id="initializer-list-c-11"><a href="#initializer-list-c-11" class="headerlink" title="initializer_list(c++11)"></a>initializer_list(c++11)</h4><br/><p><code>initializer_list</code>包含在头文件initializer_list中</p><p>新增的STL构造函数（<code>vector&lt;double&gt; payment &#123;45.99, 55, 6.2, 7.6&#125;;</code>），此时的编译器会进行类型的自动转换</p><p>上述代码也和下面这个相同<code>vector&lt;int&gt; payment (&#123;45.99, 55, 6.2, 7.6&#125;);</code></p><p>但是如果是<code>vector&lt;double&gt; payment = &#123;45.99, 55, 6.2, 7.6&#125;;</code>则不能进行隐式转换（可以用类的构造函数举例）</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;initializer_list&gt;using namespace std;double sum(initializer_list&lt;double&gt; il);double average(const initializer_list&lt;double&gt; &amp;il);int main()&#123;    cout &lt;&lt; sum(&#123;2, 3, 4, 6&#125;) &lt;&lt; &quot; &quot; &lt;&lt; average(&#123;2, 3, 4, 6&#125;) &lt;&lt; endl;    initializer_list&lt;double&gt; ddl &#x3D; &#123;2.0, 4.5, 9.7&#125;;    cout &lt;&lt; sum(ddl) &lt;&lt; &quot; &quot; &lt;&lt; average(ddl) &lt;&lt; endl;    return 0;&#125;double sum(initializer_list&lt;double&gt; il)&#123;    double result &#x3D; 0;    initializer_list&lt;double&gt;::iterator p;&#x2F;&#x2F;c++98写法    for(p &#x3D; il.begin(); p !&#x3D; il.end(); p++)&#123;        result +&#x3D; *p;    &#125;    return result;&#125;double average(const initializer_list&lt;double&gt; &amp;il)&#123;     return sum(il) &#x2F; il.size();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++ 泛型编程&amp;函数对象 p2</title>
      <link href="2021/05/09/c-%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B-%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1-p2/"/>
      <url>2021/05/09/c-%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B-%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1-p2/</url>
      
        <content type="html"><![CDATA[<h3 id="迭代器优化"><a href="#迭代器优化" class="headerlink" title="迭代器优化"></a>迭代器优化</h3><br/><blockquote><p>rend：返回程序的第一个值（和begin一样的返回值），类型不同，属于reverse_iterator（begin属于iterator）</p><p>rebegin：返回程序的最后一个值，类型同上</p></blockquote><p>通过这两个迭代器加上输出迭代器，可以实现反向输出</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;iterator&gt;#include &lt;vector&gt;using namespace std;int main()&#123;    vector&lt;int&gt; v;    ostream_iterator&lt;int, char&gt; ov(cout, &quot; &quot;);    int num;    cin &gt;&gt; num;    while(num !&#x3D; -999)&#123;        v.push_back(num);        cin &gt;&gt; num;    &#125;    sort(v.begin(), v.end());    copy(v.begin(), v.end(), ov);    cout &lt;&lt; endl;    copy(v.rbegin(), v.rend(), ov);&#x2F;&#x2F;倒序输出，写法正常    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>在赋值进容器的时候，有时候会面临不知道所拷贝数据的长度或者单纯只是插入不覆盖原值的情况，这个时候就需要插入迭代器了 </p><p>同时，c++也提供了三种插入类型的迭代器，插入将添加新的元素，而不会覆盖已有的元素</p><blockquote><p>back_insert_iterator：将元素插入到容器的尾部</p><p>front_insert_iterator：将元素插入到容器的前端</p><p>insert_iterator：将元素插入构造函数参数的指定位置</p></blockquote><p>在这里存在隐藏的限制，back_insert_iterator只允许在尾部进行快速插入的容器（快速插入算法），vector满足这种要求</p><p>front_insert_iterator智能允许在起始位置做时间固定插入的容器，vector就不能满足这种要求了，但是queue可以</p><p>虽然insert_iterator不用局限这种限制，但是写法会稍微麻烦一些</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;iterator&gt;using namespace std;&#x2F;&#x2F;插入的时候会自动申请内存int main()&#123;   int s1[4] &#x3D; &#123;1, 2, 3, 4&#125;;   int s2[2] &#x3D; &#123;5, 6&#125;;   int s3[2] &#x3D; &#123;7, 8&#125;;   vector&lt;int&gt; v(4);   ostream_iterator&lt;int, char&gt; oit(cout, &quot; &quot;);   copy(s1, s1 + 4, &amp;v.front());   copy(v.begin(), v.end(), oit);   cout &lt;&lt; endl;   copy(s2, s2 + 2, back_insert_iterator&lt;vector&lt;int&gt;&gt;(v));&#x2F;&#x2F;可以直接使用的快速插入的容器-vector   &#x2F;&#x2F;insert_iterator&lt;vector&lt;int&gt;&gt;(v, v.end()) 也可以写成这样   copy(v.begin(), v.end(), oit);   cout &lt;&lt; endl;   copy(s3, s3 + 2, insert_iterator&lt;vector&lt;int&gt;&gt;(v, v.begin()));&#x2F;&#x2F;对v的特定位置进行插入   copy(v.begin(), v.end(), oit);   cout &lt;&lt; endl;   return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><br/><h4 id="容器概念"><a href="#容器概念" class="headerlink" title="容器概念"></a>容器概念</h4><br/><p>原本是有11个容器queue、vector、map等等，在c++11中，又添加了几个新的</p><blockquote><p>a.cbegin()：返回指向容器的第一个元素的const迭代器</p><p>a.cend()：返回超尾值const迭代器</p></blockquote><p>（稍微解释固定时间和线性时间：拿取箱子举例子</p><p>固定时间即执行的任务和目标的个数没有关系，无论是100个箱子或是1000个箱子，消耗的时间是一样的</p><p>如果消耗的时间和箱子的数目成正比，这种任务就是线性时间复杂度）</p><br/><h4 id="序列"><a href="#序列" class="headerlink" title="序列"></a>序列</h4><br/><p>dequeue、list、queue、priority_queue、stack、vector、forward_list（c++11新增的容器）</p><p>这七种STL都属于容器，队列能够允许你在队尾添加元素，在队首删除元素</p><p>（array也被归类到序列容器，但是它并不满足序列的所有需求）</p><blockquote><p>X a(n, t)：生命一个名为a的由n个t值组成的序列</p><p>a.insert(p, t)：将t插入到p的前面（注意是前面）</p><p>insert还有几个其他的重载insert(p, n, t)：插入n个t，insert(p, i,  j)：向p前面插入i到j区间中的值（一般是数组或者其他容器）</p><p>a.erase(p)：删除p位置的元素。其重载a.erase(p, q)：删除p到q区间的元素</p><p>a.clear()：删除全部元素，相当于a.erase(begin(), end())</p></blockquote><p>下面介绍不同序列的特点和用法</p><p>1.deque：表示双端队列，其实现类似于vector容器，支持随机访问</p><p>2.list：表示双向链表，除了第一个和最后一个元素意外，每个元素都与前后的元素相链接</p><p>这意味这，你可以双向遍历链表。list对任一位置的插入和删除都是固定时间，vector强调的是通过随机访问进行快速访问，list强调的是元素的快速插入和删除</p><p>和vector不同的是，list不支持数组表示法和随机访问。</p><blockquote><p>merge(list&lt;T, Alloc&gt; &amp;x)：将链表x和调用链表合并，合并前必须排序，合并完之后保存在调用链表里（合并之后，程序也会自动排序）</p><p>remove(const T &amp;val)：删除链表中所有的val实例</p><p>sort()：使用&lt;运算符进行正序排序</p><p>unique()：清除重复的元素</p><p>splice(iterator pos, lis&lt;T, Alloc A&gt; x)：将链表x的内容插入到pos前面，执行之后x将会清</p></blockquote><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;list&gt;#include &lt;vector&gt;#include &lt;iterator&gt;#include &lt;algorithm&gt;using namespace std;void print(int x)&#123;cout &lt;&lt; x &lt;&lt; &quot; &quot;;&#125;int main()&#123;    vector&lt;int&gt; v;    int a[3] &#x3D; &#123;35, 35, 6&#125;;    int num;    cin &gt;&gt; num;    while(num !&#x3D; -999)&#123;        v.push_back(num);        cin &gt;&gt; num;    &#125;    list&lt;int&gt; l1;    list&lt;int&gt; l2;    &#x2F;&#x2F;无法使用copy将值复制到list中    l1.insert(l1.end(), v.begin(), v.end());    l2.insert(l2.end(), a, a + 3);    l1.sort();    l2.sort();    for_each(l1.begin(), l1.end(), print);    cout &lt;&lt; endl;    for_each(l2.begin(), l2.end(), print);    cout &lt;&lt; endl;    l1.splice(l1.begin(), l2);    for_each(l1.begin(), l1.end(), print);    cout &lt;&lt; endl;    for_each(l2.begin(), l2.end(), print);&#x2F;&#x2F;此时的l2中为空    cout &lt;&lt; endl;    l1.merge(l2);    for_each(l1.begin(), l1.end(), print);    cout &lt;&lt; endl;    l1.unique();    for_each(l1.begin(), l1.end(), print);    cout &lt;&lt; endl;       return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>3.forward_list：c++11新增的容器，只需要正向迭代器，不需要双向迭代器</p><p>相比于list更加简单&amp;紧凑，但是对应的功能也就更少</p><p>4.queue：在头文件queue中，限制更多，不仅不允许随机访问队列元素，甚至不允许遍历队列</p><blockquote><p>empty() const：如果队列为空，则返回true</p><p>push(const T &amp;X)：在队尾插入x</p><p>pop()：删除队首元素</p></blockquote><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;queue&gt;using namespace std;int main()&#123;    queue&lt;int&gt; q;    int num;    cin &gt;&gt; num;    while(num !&#x3D; -999)&#123;        q.push(num);        cin &gt;&gt; num;    &#125;        while(!q.empty())&#123;        cout &lt;&lt; q.front() &lt;&lt; &quot; &quot;;        q.pop();    &#125;    cout &lt;&lt; endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>5.stack：和queue相似，添加了top()返回栈顶元素</p><br/><h4 id="关联容器"><a href="#关联容器" class="headerlink" title="关联容器"></a>关联容器</h4><br/><p>关联容器你可以理解为php中的键值对概念</p><p>最简单的就是set，键名和值的类型相同，每个键对应一个值（包含在set头文件中）</p><p>再往上进阶一点就是map，键名可以和值类型不同，不过每个键也是只能对应一个值（再来就是multimap，一个键可以对应多个值）（包含在map头文件中）</p><p>1.set：</p><p>set_union()：将两个set的并集传到另一个容器中</p><p>set_intersection()：查找两个set的交集</p><p>set_difference()：查找两个set的差</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;set&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;iterator&gt;using namespace std;const int N &#x3D; 6;int main()&#123;    string s1[N] &#x3D; &#123;&quot;cxy&quot;, &quot;about&quot;, &quot;lgbt&quot;, &quot;nice&quot;, &quot;kpl&quot;, &quot;no&quot;&#125;;    string s2[N] &#x3D; &#123;&quot;customer&quot;, &quot;lgbt&quot;, &quot;arrange&quot;, &quot;no&quot;, &quot;please&quot;, &quot;go&quot;&#125;;    set&lt;string&gt; A(s1, s1 + N);    set&lt;string&gt; B(s2, s2 + N);    vector&lt;string&gt; C;    ostream_iterator&lt;string, char&gt; oit(cout, &quot; &quot;);&#x2F;&#x2F;set的输出会自动排序    cout &lt;&lt; &quot;A: &quot;;    copy(A.begin(), A.end(), oit);    cout &lt;&lt; endl;    cout &lt;&lt; &quot;B: &quot;;    copy(B.begin(), B.end(), oit);    cout &lt;&lt; endl;    cout &lt;&lt; &quot;A and B: &quot;;    set_union(A.begin(), A.end(), B.begin(), B.end(), oit);    cout &lt;&lt; endl;    cout &lt;&lt; &quot;A in B: &quot;;    set_intersection(A.begin(), A.end(), B.begin(), B.end(), oit);    cout &lt;&lt; endl;    cout &lt;&lt; &quot;A not B: &quot;;    set_difference(A.begin(), A.end(), B.begin(), B.end(), oit);    cout &lt;&lt; endl;    cout &lt;&lt; &quot;C: &quot;;    set_union(A.begin(), A.end(), B.begin(), B.end(), insert_iterator&lt;vector&lt;string&gt;&gt;(C, C.begin()));    &#x2F;&#x2F;不能直接使用c.begin(),需要使用插入迭代器进行显示插入    copy(C.begin(), C.end(), oit);    cout &lt;&lt; endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>2.multimap：</p><p><code>multimap&lt;int, string&gt; does;</code>：键名为int类型，储存的值为string类型</p><p><code>pair&lt;class T, class U&gt; item(213, &quot;cxy&quot;);</code>：通过pair模板类储存这种键名</p><p>（在pair对象中，可以使用first和second分别访问键名和值）</p><blockquote><p>count(KeyType)：返回键名匹配的值的个数</p><p>equal_range()：返回键名相等的键值对（一般储存在pair中）</p></blockquote><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;iterator&gt;#include &lt;algorithm&gt;using namespace std;typedef int KeyType;typedef string DataType;typedef pair&lt;KeyType, DataType&gt; Pair;typedef multimap&lt;KeyType, DataType&gt; Map;int main()&#123;    Map codes;    codes.insert(Pair(73042, &quot;cxy&quot;));    codes.insert(Pair(73042, &quot;ckt&quot;));    codes.insert(Pair(73041, &quot;zpy&quot;));    codes.insert(Pair(73041, &quot;lxq&quot;));    cout &lt;&lt; &quot;number in 73042: &quot; &lt;&lt; codes.count(73042) &lt;&lt; endl;    cout &lt;&lt; &quot;number\tname\t&quot;&lt;&lt; endl;    Map::iterator it;    for(it &#x3D; codes.begin(); it !&#x3D; codes.end(); it++)&#123;        cout &lt;&lt; (*it).first &lt;&lt; &quot;\t&quot; &lt;&lt; (*it).second &lt;&lt; endl;&#x2F;&#x2F;迭代器是指针的形式，调用对象方法的时候需要取地址    &#125;    pair&lt;Map::iterator, Map::iterator&gt; range &#x3D; codes.equal_range(73041);    cout &lt;&lt; &quot;name in 73041: &quot; &lt;&lt; endl;    for(it &#x3D; range.first; it !&#x3D; range.second; it++)&#123;&#x2F;&#x2F;这里不定义map的迭代器，直接使用auto i也没有问题        cout &lt;&lt; (*it).second &lt;&lt; endl;    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><h3 id="函数对象引入"><a href="#函数对象引入" class="headerlink" title="函数对象引入"></a>函数对象引入</h3><br/><p>很多STL算法都是用函数对象——函数符（即在类中定义了operator()类）</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;using namespace std;class Linear&#123;    private:        double x;        double y;        public:        Linear(double x0 &#x3D; 1, double y0 &#x3D; 1):x(x0), y(y0)&#123;cout &lt;&lt; &quot;created&quot; &lt;&lt; endl;&#125;        ~Linear()&#123;cout &lt;&lt; &quot;closed&quot; &lt;&lt; endl;&#125;        double operator() (double x0)&#123;return x + y * x0;&#125;&#125;;int main()&#123;    Linear l1;    Linear l2(2.5, 10.0);    double x1 &#x3D; l1(12.5);    double x2 &#x3D; l2(0.4);    cout &lt;&lt; x1 &lt;&lt; endl    &lt;&lt; x2 &lt;&lt; endl;        return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>list模板中存在remove_if()成员，这个稍微举个例子就能明白了</p><p>简单来说，就是去除满足条件的元素</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">bool tooBig(int n)&#123; return n &gt; 100&#125;;list&lt;int&gt; scores;scores.remove_if(tooBig);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vscode个人使用经验&amp;习惯</title>
      <link href="2021/05/01/vscode%E4%B8%AA%E4%BA%BA%E4%BD%BF%E7%94%A8%E7%BB%8F%E9%AA%8C-%E4%B9%A0%E6%83%AF/"/>
      <url>2021/05/01/vscode%E4%B8%AA%E4%BA%BA%E4%BD%BF%E7%94%A8%E7%BB%8F%E9%AA%8C-%E4%B9%A0%E6%83%AF/</url>
      
        <content type="html"><![CDATA[<p>这篇博客主写我使用vscode中的一些经验，也是对这近一年来的编程环境进行总结</p><p>vscode，不同于vs，是一种集成式开发软件，特点是其包容性，可以通过安装插件来进行不同语言的扩展。于是我的前端和后端就采用了该编译器，c/c++也抛弃了Dev，Java因为idea简约的界面和丰富的提示信息，所以没有抛弃使用。当然，这种编译器的最大问题还是内存占用很大，并且由于是插件的问题，语言的更新速度并没有很及时。包括后端项目中使用的laravel框架，代码的提示信息依然只停留在laravel5的语法（目前laravel已经到版本已经到8，虽然用6的人依然很多，但是已经对5的语法进行了大幅度的删改）。</p><p>我对这个编译器，是又爱又恨。下面，就来细说那些好用的插件&amp;各种语言坏境的搭建</p><br/><h3 id="插件推荐"><a href="#插件推荐" class="headerlink" title="插件推荐"></a>插件推荐</h3><br/><p>1.中文插件</p><p>进入vscode，就算你是英文大咖，我也不觉得你会使用原装英文版本（除非你是想装逼或者训练自己的英文水平）</p><p>所以，直接下载<code>Chinese (Simplified) Language Pack for Visual Studio Code</code></p><p>2.code runner</p><p>支持几乎所有的语言编译运行，运行反应速度还算可以</p><p>在搭建c/c++或者python环境中使用更加顺滑一些</p><p>3.各种美化插件-背景图</p><p>这种还是有很多，诸如拼写检查，更多的括号颜色，代码提示等等，可以自己没事去插件商店看看（x</p><p>由于各种的语言的美化插件不同，所以这里就只列举对能对背景图进行设置的</p><p>原本vscode虽然有很多颜色主题，但是看多了之后就可能会觉得很单一，所以就有了可以让你写代码的时候看老婆的插件（bushi</p><p>当然更改背景图不一定需要使用插件，你可以直接在vscode的本体css页面中进行修改（x（这也是这种插件的原理）</p><p><code>Microsoft VS Code\resources\app\out\vs\workbench\workbench.desktop.main.css</code>，在这个文件中可以直接添加body的css参数，这样的缺点也很明显。每次更新之后，vscode都是重置css，所以需要不断重新写入。当然其他两种方法也会有这种问题，但是因为是一种相对独立的json格式，修改起来比直接看一大串的原本css要方便得多</p><p>接下来的两个插件就是旧王没落和新王的崛起了（bushi</p><p>(1)老牌background插件</p><p>说起这个插件，在你百度或者用搜索引擎输入怎么给vscode设定背景图时，99%会出现这个插件并且会给你贴出设定代码。这个插件怎么说呢，太麻烦了！你需要在插件的设定中写入css参数，这对不会前端的人或者是只学了皮毛的人是很痛苦的（亲身体会</p><p>这个插件不会覆盖vscode整体界面，只会在代码界面显图片，看着还是有点难受的。唯一的好处可能就是你能设置多开窗口时，能显示不同的图片（老婆）（x</p><p>(2)新王background-cover插件</p><p>这是一个国人制作的插件，最大好处就是有中文提示，而且相当于提供了一个可视化界面，极大方便了操作</p><p>在此之外，功能也是多种多样，具体看介绍文档就能知道了</p><br/><h3 id="语言环境"><a href="#语言环境" class="headerlink" title="语言环境"></a>语言环境</h3><br/><p>虽然这些在网上有保姆级的教程，但是我还是有必要说一下我个人的使用体验</p><p>因为不是每个人都习惯别人摸索出来的东西，也算是对我这一年使用各种编译器的一个归纳</p><br/><h4 id="c-c"><a href="#c-c" class="headerlink" title="c/c++"></a>c/c++</h4><br/><p>这个在校科协的视频中就有提及，可以参考这个<a href="https://www.bilibili.com/video/BV1Nz4y1f7Zc">链接</a></p><p>（如果你还不习惯使用c，那我个人建议从DEV开始，等到熟练之后再使用vscode）</p><p>在vscode需要安装gcc作为c的编译器，安装c compile run 可以为写的第一个c程序自动查找对应的编译器（code runner是不具备的，但是你可以查找编译器结束之后直接把c compile run给卸载掉（x）</p><p>再加上一些代码提示和美化功能，c++的一些复杂的编程过程也能稍微简约一点</p><br/><h4 id="前端插件"><a href="#前端插件" class="headerlink" title="前端插件"></a>前端插件</h4><br/><p>html&amp;css&amp;js稍微看一下也就配置成功了（如果有一个插件名称叫自动格式化，建议还是不要装，这个东西就是在你保存代码的时候自动帮你格式化代码。但是vscode大部分都是开启的自动的保存，手速慢的人非常容易被这个插件给影响，当然你也可以关闭自动保存来规避这个问题，但关键是保存是一个很容易被遗忘的过程，自动保存也会让整个软件的使用更加顺滑。再一点就是，这个自动格式化的很容易将代码变得十分零散，有些个人习惯也会被这个插件打乱）</p><p>加上一些标签自动补全&amp;预览颜色显示等等，前端的生产力在vscode上绝对是大大提升</p><br/><h4 id="php"><a href="#php" class="headerlink" title="php"></a>php</h4><br/><p>对于这个没有什么好多说的，只需要简单的安装一个php插件就可以了</p><p>这个东西重要的是对于phpstudy_pro的配置，vscode的基本插件基本都是能装就装（x</p><p>关于laravel，我某个懒鬼学长（x 这个说到，全装就完事了。不过我还是得说一句，现在我所学的laravel框架是ver8的，但是插件的版本还停留在ver6（可能是因为这个版本稳定并且用得人更多）。所以代码智能提示还是停留在6版本，当然授课具体使用的版本还得看下一届后端组的决定</p><p>（建议直接废除php改用Java，这样就能实现前后端分离了</p><br/><h4 id="python"><a href="#python" class="headerlink" title="python"></a>python</h4><br/><p>这个b站有很多视频都是传授的，就不细说了</p><p>至于为什么不用同一个公司的pycharm，本身这种集成式软件，对于内存要求就比较高。再加上python语言本身对内存消耗就比较大，导致使用pycharm的时候可能会非常慢。</p><p>为了生产力考虑，还是使用了vscode，这样的统一也很好</p>]]></content>
      
      
      <categories>
          
          <category> 编译器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c </tag>
            
            <tag> c++ </tag>
            
            <tag> python </tag>
            
            <tag> php </tag>
            
            <tag> html </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++ 标准模板库&amp;泛型编程 p1</title>
      <link href="2021/05/01/c-%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93-%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B-p1/"/>
      <url>2021/05/01/c-%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93-%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B-p1/</url>
      
        <content type="html"><![CDATA[<h3 id="STL-标准模板库"><a href="#STL-标准模板库" class="headerlink" title="STL(标准模板库)"></a>STL(标准模板库)</h3><br/><p>STL是一套功能强大的 C++ 模板类，提供了通用的模板类和函数，这些模板类和函数可以实现多种流行和常用的算法和数据结构，如向量、链表、队列、栈</p><p>基本分为三个部分容器、算法、迭代器</p><br/><h4 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h4><br/><p>容器是用来管理某一类对象的集合，C++ 提供了各种不同类型的容器，比如 deque、list、vector、map 等</p><p>在之前已经大概了解了vector的基本用法和原理，vector也可以用来进行动态内存分配</p><p>vector在前面说过，是自动使用new和delete（可以使用动态内存），如果忽略模板参数的值，会由自动使用分配器</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;const int N &#x3D; 10;int main()&#123;    vector&lt;int&gt; pdata(5);    vector&lt;int&gt; pd(N);&#x2F;&#x2F;支持动态内存分配    pdata[0] &#x3D; 1;&#x2F;&#x2F;类中的[]运算符是有重载过，可以使用该索引方法    cout &lt;&lt; pdata[0] &lt;&lt; endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><br/><p>迭代器用于遍历对象集合的元素。这些集合可能是容器，也可能是容器的子集。你可以把迭代器当作指针（在实际使用中的语法跟指针类似），一些特殊的方法对集合的进行判断</p><p>迭代器为不同容器类提供统一接口，方便程序的操作</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;int main()&#123;    vector&lt;int&gt; pd(5);    int i;    for (i &#x3D; 0; i &lt; 5; i ++)&#123;        pd.push_back(i);&#x2F;&#x2F;push_back( ) 成员函数在向量的末尾插入值，如果有必要会扩展向量的大小    &#125;        &#x2F;&#x2F;vector&lt;int&gt;::iterator idx &#x3D; pd.begin();    auto idx &#x3D; pd.begin();&#x2F;&#x2F;c++11 新增了自动类型推断，可以不用像上面一样    while (idx !&#x3D; pd.end())&#123;        cout &lt;&lt; *idx &lt;&lt; endl;        idx++;    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><h4 id="STL的其他操作"><a href="#STL的其他操作" class="headerlink" title="STL的其他操作"></a>STL的其他操作</h4><br/><p>在程序中我们一般要对多个数组进行操作，包括搜索、排序等等。STL正是简化了这种重复性高的工作，假设有8个容器，需要支持10种操作，一般需要定义80个成员函数。如果采用STL方法，只需要定义10个非成员函数来进行这种操作</p><p>STL中拥有各种简便的方法</p><blockquote><p>for_each：可以用这种代替反复枯燥的for循环</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;&#x2F;&#x2F;STL存在的头文件using namespace std;void print(const int &amp; x);int main()&#123;    int a[] &#x3D; &#123;1, 2, 3, 4, 5&#125;;    &#x2F;&#x2F;siezeof(a) &#x3D; N * sizeof(int) N为元素个数    vector&lt;int&gt; v(a, a + sizeof(a) &#x2F; sizeof(int));&#x2F;&#x2F;通过数组地址对vector进行初始化    &#x2F;&#x2F;vector&lt;int&gt; v(a, a + 5); 这样初始化也可以，前提是数组元素比较小且不变动    for_each(v.begin(), v.end(), print);&#x2F;&#x2F;开始，结束，使用的函数    &#x2F;&#x2F;可以跳过使用迭代器之后进行的一大堆for循环的编程    return 0;&#125;void print(const int &amp; x)&#123;    cout &lt;&lt; x &lt;&lt; endl;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>sort：之前就已经介绍过了，黄老板已经给我介绍的一句话排序</p><p>random_shuffle：将容器中的元素随机打乱，需要能过随机访问值的容器，vector就十分合适</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;void print(const int &amp; x);bool judge(const int &amp; x1, const int &amp; x2);int main()&#123;    int a[] &#x3D; &#123;1, 2, 3, 4, 5, 6&#125;;    vector&lt;int&gt; v(a, a + sizeof(a) &#x2F; sizeof(int));        random_shuffle(v.begin(), v.end());    for_each(v.begin(), v.end(), print);    cout &lt;&lt; endl;    sort(v.begin(), v.end(), judge);&#x2F;&#x2F;自定义判断标准    for_each(v.begin(), v.end(), print);    return 0;&#125;void print(const int &amp; x)&#123;    cout &lt;&lt; x &lt;&lt; endl;&#125;bool judge(const int &amp; x1, const int &amp; x2)&#123;    return x1 &gt; x2;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/></blockquote><h4 id="基于范围的for循环"><a href="#基于范围的for循环" class="headerlink" title="基于范围的for循环"></a>基于范围的for循环</h4><br/><p>c++11中新增的for循环（可以理解为Java中的foreach循环），为STL设计，将for_each进一步简化</p><p>在这个c++20即将推出之际，可以看到，各种语言也是在为了便利性不断地向前延申</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;void print(const int &amp; x);int main()&#123;    int a[] &#x3D; &#123;1, 2, 3, 4, 5, 6&#125;;    vector&lt;int&gt; v(a, a + sizeof(a) &#x2F; sizeof(int));    for(auto &amp; i : v)&#123;&#x2F;&#x2F;新增的auto判断可以省略判断类型的过程&quot;int i&quot;        print(i);    &#125;    return 0;&#125;void print(const int &amp; x)&#123;    cout &lt;&lt; x &lt;&lt; endl;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><h3 id="泛型编程介绍"><a href="#泛型编程介绍" class="headerlink" title="泛型编程介绍"></a>泛型编程介绍</h3><br/><p>在使用泛型编程之前，我们先回顾一下c链表的操作（基本的功能无非就是增删改查）</p><p>（也算是看看现在我能不能看懂链表（x）</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;using namespace std;struct Node&#123;    double item;    Node * p_next;&#125;;typedef struct Node Node;Node *create();Node *num_sort(Node * head);void destroy(Node * head);void print(Node *head);int main()&#123;    Node *head;    head &#x3D; create();    cout &lt;&lt; &quot;origin version&quot; &lt;&lt; endl;    print(head);    head &#x3D; num_sort(head);    cout &lt;&lt; &quot;sorted version&quot; &lt;&lt; endl;    print(head);    destroy(head);    return 0;&#125;Node *create()&#123;    Node *p, *head, *tail;    int num;    head &#x3D; NULL;    tail &#x3D; NULL;        cout &lt;&lt; &quot;enter a num (end with -999)&quot; &lt;&lt; endl;    cin &gt;&gt; num;    while(num !&#x3D; -999)&#123;        p &#x3D; new Node;        p-&gt;item &#x3D; num;        p-&gt;p_next &#x3D; NULL;        if(head &#x3D;&#x3D; NULL)&#123;            head &#x3D; p;        &#125;else&#123;            tail-&gt;p_next &#x3D; p;        &#125;        tail &#x3D; p;        cout &lt;&lt; &quot;enter a num (end with -999)&quot; &lt;&lt; endl;        cin &gt;&gt; num;    &#125;    return head;&#125;Node *num_sort(Node * head)&#123;    Node *p1, *p2, temp;    p1 &#x3D; head;    if(head &#x3D;&#x3D; NULL)&#123;        cout &lt;&lt; &quot;It&#39;s NULL&quot; &lt;&lt; endl;        return head;    &#125;else if(head-&gt;p_next &#x3D;&#x3D; NULL)&#123;        cout &lt;&lt; &quot;only one number, no need to sort&quot; &lt;&lt; endl;        return head;    &#125;    while(p1-&gt;p_next !&#x3D; NULL)&#123;        p2 &#x3D; p1-&gt;p_next;        while(p2 !&#x3D; NULL)&#123;            if(p1-&gt;item &gt; p2-&gt;item)&#123;                temp &#x3D; *p1;                *p1 &#x3D; *p2;                *p2 &#x3D; temp;                temp.p_next &#x3D; p1-&gt;p_next;                p1-&gt;p_next &#x3D; p2-&gt;p_next;                p2-&gt;p_next &#x3D; temp.p_next;            &#125;            p2 &#x3D; p2-&gt;p_next;        &#125;        p1 &#x3D; p1-&gt;p_next;    &#125;    return head;&#125;void print(Node *head)&#123;    Node *p;    p &#x3D; head;    if(head &#x3D;&#x3D; NULL)&#123;        cout &lt;&lt; &quot;nothing to print&quot; &lt;&lt; endl;    &#125;else&#123;        cout &lt;&lt; &quot;num is &quot; &lt;&lt; endl;        while(p !&#x3D; NULL)&#123;            cout &lt;&lt; p-&gt;item &lt;&lt; endl;            p &#x3D; p-&gt;p_next;        &#125;    &#125;&#125;void destroy(Node * head)&#123;    Node *p1, *p2;    p1 &#x3D; head;    while(p1 !&#x3D; NULL)&#123;        p2 &#x3D; p1;        p1 &#x3D; p1-&gt;p_next;        delete p2;    &#125;    cout &lt;&lt; &quot;release success&quot; &lt;&lt; endl;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>泛型编程旨在使用同一个find函数处理数组和链表问题，于是就产生了各种类型的迭代器</p><blockquote><p>输入迭代器：这种迭代器必须能够访问容器中的所有值（原理是根据++运算符来实现的）。并且，不能保证两次遍历容器时都是相同的顺序，也不能保证先前的值仍然可以被解除引用</p><p>（输入迭代器是单向迭代器，可以递增不能倒退）</p><p>输出迭代器：输出迭代器和输入迭代器类似，解除引用让程序能够修改容器值</p><p>正向迭代器：正向迭代器只使用++运算符，每次遍历数组时都是使用同一个顺序。递增之后，仍然可以对前面的迭代器解除引用，并可以得到相同的值</p><p>双向迭代器：显而易见，支持++运算符和–运算符</p><p>随机访问迭代器：有些算法要求能够直接跳到容器中的任何一个元素</p></blockquote> <br/><h3 id="迭代器实践"><a href="#迭代器实践" class="headerlink" title="迭代器实践"></a>迭代器实践</h3><br/><p>之前在例子中已经介绍过了begin()&amp;end()这两种迭代器，vector是动态内存，所以需要这些机制来扩充自己</p><blockquote><p>front()：返回当前vector容器中起始元素的引用</p><p>back()：返回当前vector容器中末尾元素的引用</p><p>copy(start, end, container.begin()): 把一个序列拷贝到一个容器中去</p></blockquote><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;const int SIZE &#x3D; 3;int main()&#123;    int a[SIZE] &#x3D; &#123;3, 4, 5&#125;;    int b[SIZE];    copy(a, a + SIZE, b);    &#x2F;&#x2F;可以看见，基于范围的for循环还是将值赋值给i    for(auto i : b)&#123;        cout &lt;&lt; i &lt;&lt; endl;&#x2F;&#x2F;不需要使用函数，直接通过这种方式也可以输出数组的值    &#125;    vector&lt;int&gt; temp(SIZE);    copy(a, a + SIZE, &amp;temp.front());&#x2F;&#x2F;要注意，front()的返回值是引用    for(auto i : temp)&#123;        cout &lt;&lt; i &lt;&lt; endl;    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><h4 id="输入迭代器"><a href="#输入迭代器" class="headerlink" title="输入迭代器"></a>输入迭代器</h4><br/><p>istream_iterator 定义在<code>&lt;iterator&gt;</code>头文件，并位于 std 命名空间中</p><p>创建输入流迭代器的方式有 3 种</p><blockquote><p>调用 istream_iterator 模板类的默认构造函数</p><p>创建一个可用来读取数据的输入流迭代器，<code>std::istream_iterator&lt;double&gt; iit(std::cin);</code></p><p>支持用已创建好的 istream_iterator 迭代器为新建 istream_iterator 迭代器初始化，<code>std::istream_iterator&lt;double&gt; iit2(iit1);</code></p></blockquote><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;iterator&gt;#include &lt;algorithm&gt;using namespace std;int main()&#123;    double v1, v2;    int i;    istream_iterator&lt;double&gt; eos;&#x2F;&#x2F;创建表示结束的输入迭代器    istream_iterator&lt;double&gt; lit(cin);&#x2F;&#x2F;创建一个可逐个读取输入流中数据的迭代器，同时这里会让用户输入数据    if(lit !&#x3D; eos)&#123;        v1 &#x3D; *lit;    &#125;    lit++;    if(lit !&#x3D; eos)&#123;        v2 &#x3D; *lit;    &#125;    cout &lt;&lt; &quot;value1&#x3D; &quot; &lt;&lt; v1 &lt;&lt; endl;    cout &lt;&lt; &quot;value2&#x3D; &quot; &lt;&lt; v2 &lt;&lt; endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>注意，只有读取到 EOF 流结束符时，程序中的 iit 才会和 eos 相等</p><p>在这个例子中，输入迭代器会自动根据要赋值的个数决定用户输入的次数</p><p>但我们大部分情况下会使用while循环进行赋值，这样就没办法通过自动判断的方法来中止了。Windows 平台上使用 Ctrl+Z 组合键输入 ^Z 表示 EOF 流结束符，此结束符需要单独输入，或者输入换行符之后再输入才有效</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;iterator&gt;#include &lt;algorithm&gt;using namespace std;int main()&#123;    vector&lt;double&gt; v;    int i;    istream_iterator&lt;double&gt; eos;    istream_iterator&lt;double&gt; lit(cin);        while(lit !&#x3D; eos)&#123;        v.push_back(*lit);        lit++;    &#125;&#x2F;&#x2F;停止输入需要手动输入^Z    for(auto j : v)&#123;        cout &lt;&lt; j &lt;&lt; &quot; &quot;;    &#125;        return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><h4 id="输出迭代器"><a href="#输出迭代器" class="headerlink" title="输出迭代器"></a>输出迭代器</h4><br/><p>ostream_iterator 模板类中也提供了 3 种创建 ostream_iterator 迭代器的方法</p><blockquote><p>通过调用该模板类的默认构造函数</p><p>在第一种方式的基础上，还可以为写入的元素之间指定一个分隔符，<code>std::ostream_iterator&lt;int&gt; out_it(std::cout，&quot;,&quot;);</code></p><p>在创建输出流迭代器时，可以用已有的同类型的迭代器，为其初始化，<code>std::ostream_iterator&lt;int&gt; out_it1(out_it);</code></p></blockquote><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;iterator&gt;#include &lt;algorithm&gt;#include &lt;string&gt;using namespace std;int main()&#123;    ostream_iterator&lt;string&gt; out(cout);    *out &#x3D; &quot;http:&#x2F;&#x2F;c.biancheng.net&#x2F;view&#x2F;7286.html&quot;;    cout &lt;&lt; endl;    ostream_iterator&lt;int&gt; out_iterator(cout, &quot;,&quot;);    *out_iterator &#x3D; 1;    *out_iterator &#x3D; 2;    *out_iterator &#x3D; 3;     &#x2F;&#x2F;轮流输入之后，输出迭代器会自动将指针递增    return 0;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>和输入迭代器一样，在一般情况下，我们是不会这么简单地直接赋值地，大部分情况都需要使用第三者</p><p>由于不能通过参数，所以就需要借用copy()</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;iterator&gt;#include &lt;vector&gt;using namespace std;int main()&#123;    vector&lt;int&gt; v;    ostream_iterator&lt;int&gt; ov(cout, &quot; &quot;);    &#x2F;&#x2F;ostream_iterator&lt;int, char&gt; ov(cout, &quot; &quot;); 写成这种类型也可以    int num;    cin &gt;&gt; num;    while(num !&#x3D; -999)&#123;        v.push_back(num);        cin &gt;&gt; num;    &#125;    sort(v.begin(), v.end());    copy(v.begin(), v.end(), ov);    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++ string类&amp;智能指针模板类</title>
      <link href="2021/04/28/c-string%E7%B1%BB-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E6%A8%A1%E6%9D%BF%E7%B1%BB/"/>
      <url>2021/04/28/c-string%E7%B1%BB-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E6%A8%A1%E6%9D%BF%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h3 id="string类的基本使用"><a href="#string类的基本使用" class="headerlink" title="string类的基本使用"></a>string类的基本使用</h3><br/><h4 id="构造字符串"><a href="#构造字符串" class="headerlink" title="构造字符串"></a>构造字符串</h4><br/><p>c++规定了几个常规的string函数</p><blockquote><p>string(const char *) 将string对象初始化为s指向的NBTS</p><p>（NBT，正如其名，它是通过一个个<strong>标签</strong>来储存和读取数据的。一个标签由<strong>标签名称</strong>和<strong>数值</strong>两部分组成，两者用冒号<code>:</code>隔开。例如<code>foo:1</code>就是一个标签。个人感觉像是键值对）（初次了解NBT还是在我的世界机制介绍里（x）</p><p>string(size_type n, char e) 这个在前面介绍过，就是初始化一个规定长度的字符的string对象</p><p>string() 默认构造函数</p><p>string(const string &amp; str) 复制构造函数</p><p>string(const char * s, size_type n) 对象初始化为s指向的NBTS前n个字符</p><p>string(const string &amp; str, size_type pos = 0, size_type n = npos) string对象初始化为对象str中从pos开始到结尾的字符</p><p><code>string(initializer_list &lt;char&gt; li)</code> c++11 新增，将string对象初始化一个列表li中的字符</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">string one &#x3D; &#123;&#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br/></blockquote><p>在string对象中，重载了部分运算符，使得可以适用string对象的计算</p><p>就比如<code>+</code>可以用来拼接两个字符串，<code>[]</code>可以访问特定的位置的字符</p><br/><h4 id="字符串输入"><a href="#字符串输入" class="headerlink" title="字符串输入"></a>字符串输入</h4><br/><p>对于c++来说，也就两种输入方式</p><p><code>cin</code> &amp; <code>getline</code></p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;using namespace std;int main()&#123;    string a, b;    cin &gt;&gt; a;    getline(cin, s, &#39;:&#39;); &#x2F;&#x2F;设置输入方式、储存对象、结束字符    cout &lt;&lt; a &lt;&lt; b &lt;&lt; endl;    return 0;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>区别在于getline拥有可选参数，支持更加丰富的写法</p><p>由于设计重载问题，只能对字符数组（并非c++中的string类）进行输入</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main()&#123;    char a[10];    cin.getline(a, 10);    return 0;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>string版本中的getline()函数从输入中读取字符，并存储到string对象中</p><blockquote><p>到达文件尾，这个时候输入流的eofbit将被设置，方法fail() &amp; eof() 都将返回true</p><p>（fail()用来判断一个流是否“坏”掉了。如果failbit、badbit中任意一种或两种被设置，则fail()返回true，否则返回false。在打开了一个文件过后，通常使用fail()函数对其进行检测）</p><p>遇到分界字符（默认为”\n”），会将分界字符从输入流中删除，但不会储存</p><p>读取字符数超过最大允许值时，将设置输入流中的failbit，方法fail()将返回true</p></blockquote><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;fstream&gt;#include &lt;string&gt;#include &lt;cstdlib&gt;using namespace std;&#x2F;** * @brief 读取文件中的字符串，凭借回车分割 *  * @return int  *&#x2F;int main()&#123;    ifstream fin;    fin.open(&quot;input.txt&quot;);    if(fin.is_open() &#x3D;&#x3D; false)&#123;        cerr &lt;&lt; &quot;ERROR&quot; &lt;&lt; endl;        exit(EXIT_FAILURE);    &#125;    string items;    int count &#x3D; 0;    getline(fin, items, &#39;\n&#39;);    while(fin)&#123;        count++;        cout &lt;&lt; count &lt;&lt; &quot;: &quot; &lt;&lt; items &lt;&lt; endl;        getline(fin, items, &#39;\n&#39;);    &#125;    cout &lt;&lt; &quot;Done&quot; &lt;&lt; endl;    fin.close();    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre> <br/><h4 id="使用字符串"><a href="#使用字符串" class="headerlink" title="使用字符串"></a>使用字符串</h4><br/><p>在c++中，关于string类的运算符进行了重载，size()&amp;length()成员函数都返回字符串中的字符数</p><p>在机器排列序列中，一个对象位于另一个对象前面，则前者被视为小于后者。如果极其排列序列为ASCII码，则数字将小于大写字符，大写字符小于小写字符</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main()&#123;    string s1(&quot;cobra&quot;);    string s2(&quot;coral&quot;);    string s3(&quot;cob&quot;);    if(s1 &lt; s2)&#123;        cout &lt;&lt; &quot;nice&quot; &lt;&lt; endl;                if(s2.size() &lt; s3.size())&#123;&#x2F;&#x2F;两种if语句的判定机制是一样的            cout &lt;&lt; &quot;No&quot;;                    &#125;else if(s2.length() &lt; s1.length())&#123;            cout &lt;&lt; &quot;YES&quot;;        &#125;    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>string库中提供大量相关的方法</p><blockquote><p>rfind() 查找子字符串或者字符出现的位置，位置类似数组的表示方式</p><p>find_first_of() 在字符串中查找参数中任何一个字符首次出现的位置</p><p>find_last_of() 与上述类似，是找出字符最后出现的位置</p><p>find_first_not_of() 见名知意，找出第一个不存在指定字符的位置</p></blockquote><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main()&#123;    string str(&quot;cxyaperfectman&quot;);        int position &#x3D; str.rfind(&quot;per&quot;);    cout &lt;&lt; position &lt;&lt; endl;&#x2F;&#x2F;4    position &#x3D; str.find_first_of(&quot;e&quot;);    cout &lt;&lt; position &lt;&lt; endl;&#x2F;&#x2F;5    position &#x3D; str.find_last_of(&quot;e&quot;);    cout &lt;&lt; position &lt;&lt; endl;&#x2F;&#x2F;8    position &#x3D; str.find_first_not_of(&quot;cxy&quot;);    cout &lt;&lt; position &lt;&lt; endl;&#x2F;&#x2F;3        return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><h4 id="string其他的功能"><a href="#string其他的功能" class="headerlink" title="string其他的功能"></a>string其他的功能</h4><br/><p>在string中，如果用+向末尾添加一个字母，并不是简单的内存再分配，因为相邻的内存有可能被占用了</p><p>所以程序要做的，是重新分配一个内存，将原来的内容复制到新内存处，这种操作如果大量进行将会极大影响运行效率和速度</p><p>显然，程序考虑到了这一点，所以在分配内存时，往往会分配一个更大的内存。为了避免内存块不断请求分配内存，string提供了reserve()，规定申请内存的最小长度</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;int main()&#123;    string s;        cout &lt;&lt; s.capacity() &lt;&lt; endl;&#x2F;&#x2F;string方法，返回s实际占用内存大小    &#x2F;&#x2F;此时函数的结果为15    s.reserve(40);    cout &lt;&lt; s.capacity() &lt;&lt; endl;    &#x2F;&#x2F;此时函数的结果为40    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><h3 id="小知识补充"><a href="#小知识补充" class="headerlink" title="小知识补充"></a>小知识补充</h3><br/><p>cout：写到标准输出的ostream对象；</p><p>cerr：输出到标准错误的ostream对象，常用于程序错误信息；</p><p>clog：也是输出标准错误流</p><br/><p>cout经过缓冲后输出，默认情况下是显示器。这是一个被缓冲的输出，是标准输出，并且可以重新定向</p><p>cerr不经过缓冲而直接输出，一般用于迅速输出出错信息，是标准错误，默认情况下被关联到标准输出流，但它不被缓冲，也就说错误消息可以直接发送到显示器，而无需等到缓冲区或者新的换行符时，才被显示</p><br/><p>string中还存在一个静态成员—npos，它代表了string中能存储的最大字符串长度</p><p>在具体实践中，可以用他来表示没有查到字符或者字符串</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">cout &lt;&lt; string::npos &lt;&lt; endl;&#x2F;&#x2F;18446744073709551615<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><br/><h3 id="智能指针模板类"><a href="#智能指针模板类" class="headerlink" title="智能指针模板类"></a>智能指针模板类</h3><br/><p>如果在函数中使用动态内存分配，很有可能会导致忘记释放而产生的内存泄漏问题</p><p>所以，c++中提供了智能指针这个功能（auto_ptr、unique_ptr、shared_ptr），前者是c++98的产物，在c++11中被废除并由后两者替代</p><p>（在vscode的编译器中，前者会报版本不支持警告，但是仍然会正常运行）</p><p>这三个指针被包含在memory头文件中，使用智能指针模板之后，就不需要使用delete了</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;memory&gt;using namespace std;class Report&#123;    private:        string str;        public:        Report(const string &amp; s):str(s)&#123; cout &lt;&lt; &quot;Report created&quot; &lt;&lt; endl;&#125;        ~Report()&#123; cout &lt;&lt; &quot;Report deleted&quot; &lt;&lt; endl;&#125;        void show() const&#123; cout &lt;&lt; str &lt;&lt; endl;&#125;&#125;;int main()&#123;    shared_ptr&lt;Report&gt; sp(new Report(&quot;using shared_ptr&quot;));&#x2F;&#x2F;这里的sp是指针对象    sp-&gt;show();    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>在系统定义的模板中，所有的智能指针都有explict构造函数，所以不需要自动转换，不能用=来进行赋值</p><p>在模板中，还使用了throw，这样在部分代码出现错误时，编译器可以及时停止运行，并显示错误信息</p><br/><h3 id="对比不同的智能指针模板"><a href="#对比不同的智能指针模板" class="headerlink" title="对比不同的智能指针模板"></a>对比不同的智能指针模板</h3><br/><p>c++实质上定义了四种智能指针（cprimer不讨论weak_ptr）</p><p>auto_ptr被c++11废除的原因可以从下面的例子略知一二</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">auto_ptr&lt;string&gt; ps(new string(&quot;cxy yyds&quot;));auto_ptr&lt;string&gt; version;version &#x3D; ps;&#x2F;&#x2F;这种写法很明显是错误的，在类和对象中有过提及&#x2F;&#x2F;两个对象会指向同一个地址，这样在析构函数调用时，就会调用两次，这是会出问题的（所以在重载&#x3D;的时候，才要释放旧参的内存）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><br/><p>要想解决这个办法，一般由三种可选方案</p><blockquote><p>重载赋值运算符（创建复制构造函数），使它执行深复制。让两个指针指向不同的对象，其中一个是另一个的副本（<code>retrun *this;</code>）</p><p>建立所有权概念，对于特定的对象，只能有一个智能指针掌控，赋值操作会删去对象并转让操控权（这是用于auto_ptr&amp;unique_ptr的策略，只不过后者更为严格）</p><p>创建智能更高的指针，使用引用计数（类似于先前的StringBad的例子），创建赋值时+1，释放时-1，最后一个指针过期时，才使用delete释放内存。这是shared_ptr采用的策略</p></blockquote><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;memory&gt;using namespace std;int main()&#123;    shared_ptr&lt;string&gt; filename[5] &#x3D; &#123;        shared_ptr&lt;string&gt; (new string(&quot;cmk&quot;)),        shared_ptr&lt;string&gt; (new string(&quot;ckt&quot;)),        shared_ptr&lt;string&gt; (new string(&quot;cyx&quot;)),        shared_ptr&lt;string&gt; (new string(&quot;cxy&quot;)),        shared_ptr&lt;string&gt; (new string(&quot;fwh&quot;))       &#125;;    shared_ptr&lt;string&gt; sp(new string(&quot;just monika&quot;));    filename[3] &#x3D; sp;&#x2F;&#x2F;如果使用auto_ptr将会产生问题        for(int i &#x3D; 0; i &lt; 5; i++)&#123;        cout &lt;&lt; *filename[i] &lt;&lt; endl;    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>如果想给一个由函数创建的智能指针赋值，可以使用move()，能够将一个unique_ptr赋值给另一个</p><p>如果程序需要有多个指针对象，必须使用shared_ptr，如果不需要，就使用unique_ptr</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++ 异常进阶&amp;类型转换运算符</title>
      <link href="2021/04/28/c-%E5%BC%82%E5%B8%B8%E8%BF%9B%E9%98%B6-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
      <url>2021/04/28/c-%E5%BC%82%E5%B8%B8%E8%BF%9B%E9%98%B6-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</url>
      
        <content type="html"><![CDATA[<h3 id="stdexcept异常类"><a href="#stdexcept异常类" class="headerlink" title="stdexcept异常类"></a>stdexcept异常类</h3><br/><p> stdexcept定义了其他几个异常类，包括logic_error&amp;runtime_error类</p><p>这些类都是从公有的exception类中派生出来的</p><br/><h4 id="logic-error"><a href="#logic-error" class="headerlink" title="logic_error"></a>logic_error</h4><br/><p>见名知意，这个类描述逻辑错误</p><blockquote><p>domain_error domain表示定义域，如果函数输出了定义域之外的值，会执行该错误</p><p>invalid_error 指出函数传递了一个意料之外的值</p><p>length_error 没有足够的空间来执行所需的操作</p><p>out_of_bounds 用于索引错误</p></blockquote><br/><h4 id="runtime-error"><a href="#runtime-error" class="headerlink" title="runtime_error"></a>runtime_error</h4><br/><blockquote><p>range_error 输出的值域不满足规定的要求</p><p>overflow_error 计算的结果超越了某个类型规定的最大允许范围</p><p>underflow_error 表示下溢错误，用在浮点类型中。一般的浮点类型存在可以表示的最小非零值，如果比这个值还要小，称为下一错误</p></blockquote><br/><h4 id="捕捉一般步骤"><a href="#捕捉一般步骤" class="headerlink" title="捕捉一般步骤"></a>捕捉一般步骤</h4><br/><p>先单独捕获out_of_bounds异常，然后统一捕获其他logic_error系列异常</p><p>最后再捕获exception异常以及其他从exception派生出来的异常</p><p>注意：out_of_bounds在vscode中无法使用</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">try&#123;&#125;catch(logic_error &amp; e)&#123;&#125;catch(exception &amp; e)&#123;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><h3 id="bad-alloc异常-amp-new"><a href="#bad-alloc异常-amp-new" class="headerlink" title="bad_alloc异常&amp;new"></a>bad_alloc异常&amp;new</h3><br/><p>使用new导致的内存分配问题，可以使用bad_alloc异常</p><p>在之前的版本中，异常中，无法分配请求的内存量时，new会返回一个空指针</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;cstdlib&gt;&#x2F;&#x2F;exit所需要的头文件#include &lt;new&gt;#include &lt;exception&gt;using namespace std;struct Big&#123;    double stuff[20000];&#125;;typedef struct Big Big;int main()&#123;    Big * pb;    try&#123;        cout &lt;&lt; &quot;分配一个很大的空间&quot; &lt;&lt; endl;        pb &#x3D; new Big[10000000];        &#x2F;&#x2F;使用Big[10000]时，并不会报错        cout &lt;&lt; &quot;执行下一步&quot; &lt;&lt; endl;        &#125;catch(bad_alloc &amp; ba)&#123;        cout &lt;&lt; &quot;出现错误&quot; &lt;&lt; endl;        cout &lt;&lt; ba.what() &lt;&lt; endl;        exit(EXIT_FAILURE);    &#125;    cout &lt;&lt; &quot;创建成功&quot; &lt;&lt; endl;    pb[0].stuff[0] &#x3D; 4;    cout &lt;&lt; pb[0].stuff[0] &lt;&lt; endl;        delete [] pb;    return 0;&#125;&#x2F;&#x2F;会引起异常错误&#x2F;&#x2F;空指针的调用方法if(pb &#x3D;&#x3D; 0)&#123;        cout &lt;&lt; &quot;分配内存失败&quot; &lt;&lt; endl;    exit(EXIT_FAILURE);    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><h3 id="引发异常时的问题"><a href="#引发异常时的问题" class="headerlink" title="引发异常时的问题"></a>引发异常时的问题</h3><br/><p>如果没有捕获catch中匹配的异常，在默认情况下，会导致程序异常终止</p><p>但是异常没有捕获不会让程序立刻终止，相反，会先调用terminate()函数</p><p>可以调用set_terminate()函数，设定该函数输出的信息，如果调用了多个，系统将会采用最后一个</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;cstdlib&gt;#include &lt;exception&gt;using namespace std;void MyError();int main()&#123;    set_terminate(MyError);&#x2F;&#x2F;在程序的开始处设定该代码    return 0;&#125;void MyError()&#123;    cout &lt;&lt; &quot;终端使程序终止&quot; &lt;&lt; endl;    exit(5);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>对于一些函数，可能不知道可能捕获可能存在的异常，这个时候就可以使用动态异常规范</p><p><code>double Argh(double, double) noexcept;</code></p><p>没有预料的异常程序会调用unexcept()函数，同上述相比，set_unexcepted()受到的限制更加严格</p><p>unexcepted_handler函数可以：</p><p>1.调用terminate()(默认)&amp;abort()&amp;exit() 来终止程序</p><p>2.引发异常</p><p>3.如果新引发的异常和原来的匹配，就从原来那里正常处理，不然将使用该处理代替意外异常</p><p>4.如果没有匹配的异常，并且没有bad_exception类型，默认调用terminate()</p><p>5.如果没有匹配的异常，并且有规定的bad_exception，不匹配的异常将被其所取代</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;exception&gt;using namespace std;void MyUnexception();int main()&#123;    set_unexpected(MyUnexception);    return 0;&#125;void MyUnexception()&#123;    throw bad_exception();&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><h3 id="类型转换运算符"><a href="#类型转换运算符" class="headerlink" title="类型转换运算符"></a>类型转换运算符</h3><br/><p>在c语言的类型转换中，c++的创始人认为太过于随意，所以c++采用了更加严格的转换方式，添加了4个类型转换符</p><p>1.dynamic_cast </p><p>用来检查两者是否有继承关系。因此该运算符实际上只接受基于类对象的指针和引用的类转换</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class A&#123;    &#125;class B : public class A&#123;    &#125;A * p1;B * p2;p1 &#x3D; dynamic_cast &lt;A * &gt; p2;&#x2F;&#x2F;将派生类转化为基类的指针<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>2.const_cast</p><p>用于执行只有一种用途的转换，改变值为const或volatile，不允许其他类型的转换</p><p>语法结构和dynamic_cast一样</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class High&#123;&#125;High p;const High * p1 &#x3D; &amp;p;High * pb &#x3D; const &lt;High *&gt; (p1);&#x2F;&#x2F;删除const标签<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>由于编程时可能会无意间更改类型和常量特征</p><p>所以使用const_cast更加安全</p><p>3.static_cast</p><p>只有转换的类中可以被隐式转换，或者被转换的类型可以被隐式转为type_name类型</p><p>4.reinterpret_cast</p><p>这种转化可以简化一些厌烦的操作，比如在字节的不同类型的存储方面可以起到规范作用</p><p>但是并不能适用于所有类型</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++ 友元&amp;异常</title>
      <link href="2021/04/18/c-%E5%8F%8B%E5%85%83-%E5%BC%82%E5%B8%B8-%E5%85%B6%E4%BB%96/"/>
      <url>2021/04/18/c-%E5%8F%8B%E5%85%83-%E5%BC%82%E5%B8%B8-%E5%85%B6%E4%BB%96/</url>
      
        <content type="html"><![CDATA[<h3 id="友元进阶"><a href="#友元进阶" class="headerlink" title="友元进阶"></a>友元进阶</h3><br/><p>友元函数可以直接访问类的私有数据，在重载运算字符中起了巨大的作用</p><p>友元函数提供了在不同类成员函数之间、类的成员函数于普通函数之间进行数据共享的机制。尤其是在一个函数需要访问多个类的时候，友元函数十分好用</p><p>但是友元违背了oop的封装性机制，在安全性和效率两方面需要权衡</p><p>这也是c++的缺陷，它虽然打破了c的陈旧，成了oop的鼻祖，但是依然没法突破指针和友元的限制，所以就让Java脱颖而出。虽然现在c++还在不断更新和完善，但是相比Java还是缺点火候，有些公司甚至是不允许使用友元，很容易造成安全问题</p><br/><h4 id="友元类"><a href="#友元类" class="headerlink" title="友元类"></a>友元类</h4><br/><p>类友元即<code>friend class CLASSNAME</code>的定义方式，在定义友元的类中可以使用所在类的私有对象</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class A&#123;public:    friend class B;    &#125;class B&#123;        &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><h4 id="友元成员函数"><a href="#友元成员函数" class="headerlink" title="友元成员函数"></a>友元成员函数</h4><br/><p>当然，这也引出了一个新的问题</p><p>在定义友元的成员函数时，因为编译器默认是按照顺序编译，所以定义友元函数时，大概率会出现变量还未定义的问题</p><p>解决办法也很简单，在类的前面提前加上一个类的声明就好</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#ifndef GIRLBOY_H#define GIRLBOY_H#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class Boy;&#x2F;&#x2F;提前声明，让类初始化class Girl&#123;    private:        string name;        int age;        public:        friend Boy;        Girl() : name(&quot;NoName&quot;), age(0)&#123;&#125;        Girl(const string &amp; n, int a) : name(n), age(a)&#123;&#125;        ~Girl();        void VisitBoy(const Boy &amp; b);        void display() const;    &#125;;class Boy&#123;    private:        string name;        int age;        public:        friend Girl;        Boy() : name(&quot;NoName&quot;), age(0)&#123;&#125;        Boy(const string &amp; n, int a) : name(n), age(a)&#123;&#125;        ~Boy();        void VisitGirl(const Girl &amp; g);        void display() const;    &#125;;#endif<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &quot;GirlBoy.h&quot;Girl :: ~Girl()&#123;&#125;void Girl :: display() const&#123;    cout &lt;&lt; &quot;name: &quot; &lt;&lt; name    &lt;&lt; &quot; age: &quot; &lt;&lt; age &lt;&lt; endl;&#125;Boy :: ~Boy()&#123;&#125;void Boy :: display() const&#123;    cout &lt;&lt; &quot;name: &quot; &lt;&lt; name    &lt;&lt; &quot; age: &quot; &lt;&lt; age &lt;&lt; endl;    &#125;void Girl :: VisitBoy(const Boy &amp; b)&#123;    cout &lt;&lt; b.name &lt;&lt; &quot; &quot; &lt;&lt; b.age &lt;&lt; endl;&#125;void Boy :: VisitGirl(const Girl &amp; g)&#123;     cout &lt;&lt; g.name &lt;&lt; &quot; &quot; &lt;&lt; g.age &lt;&lt; endl;     &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>（友元类不需要向前声明，因为使用之后已经表明其是个友元类）</p><br/><h4 id="共同的友元"><a href="#共同的友元" class="headerlink" title="共同的友元"></a>共同的友元</h4><br/><p>上述的例子中，可以让两个类称为相互的友元，两者可以相互影响</p><p>或者两个类的方法需要同步，也可以使用友元类</p><br/><h3 id="嵌套类"><a href="#嵌套类" class="headerlink" title="嵌套类"></a>嵌套类</h3><br/><p>在c++中，将一个类的声明放在另一个类中，称之为类的嵌套类</p><p>c primer在这里举了一个类中套类套链表的例子，这里我就不细说了（绝对不是因为自己链表不懂）</p><br/><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><br/><p>可以使用abort()函数（这个我在考试平台的中间件写法中，也用到了这个，可以传递对应格式的json值）</p><p>位于cstdlib（cstdlib.h）的头文件中，典型实现是向标准错误发送消息，然后终止程序</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;cstdlib&gt;using namespace std;double hmean(double a, double b);int main()&#123;    double x, y, z;    while(cin &gt;&gt; x &gt;&gt; y)&#123;        z &#x3D; hmean(x, y);        cout &lt;&lt; z &lt;&lt; endl;        cout &lt;&lt; &quot;请输入下一个数字&quot; &lt;&lt; endl;        &#125;    return 0;&#125;double hmean(double a, double b)&#123;    if(a &#x3D;&#x3D; -b)&#123;        cout &lt;&lt; &quot;除数为0&quot; &lt;&lt; endl;        abort();    &#125;    return 2.0 * a * b &#x2F; (a + b);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>当然，因为这样会使程序终止，我们还有一个更灵活的办法，即将函数设定为布尔类型，通过返回值判断是否进行下一步操作</p><p>同时，我们大部分都是使用try catch捕获异常， throw抛出异常</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;使用布尔类型进行判断#include &lt;iostream&gt;using namespace std;bool hmean(double a, double b, double &amp; c);int main()&#123;    double x, y, z;    while(cin &gt;&gt; x &gt;&gt; y)&#123;        if(hmean(x, y, z))&#123;            cout &lt;&lt; z &lt;&lt; endl;        &#125;else&#123; &#125;                cout &lt;&lt; &quot;请输入下一个数字&quot; &lt;&lt; endl;        &#125;    return 0;&#125;bool hmean(double a, double b, double &amp; c)&#123;    if(a &#x3D;&#x3D; -b)&#123;        cout &lt;&lt; &quot;除数为0&quot; &lt;&lt; endl;        return false;    &#125;    c &#x3D; 2.0 * a * b &#x2F; (a + b);    return true;&#125;&#x2F;&#x2F;try-catch一条龙 throw抛出#include &lt;iostream&gt;using namespace std;double hmean(double a, double b);int main()&#123;    double x, y, z;    while(cin &gt;&gt; x &gt;&gt; y)&#123;        try&#123;            z &#x3D; hmean(x, y);        &#125;catch(const char * s)&#123;            cout &lt;&lt; s &lt;&lt; endl;&#x2F;&#x2F;调用throw中的提示信息            cout &lt;&lt; &quot;请输入一个正确的数字&quot; &lt;&lt; endl;            continue;        &#125;        cout &lt;&lt; z &lt;&lt; endl;        cout &lt;&lt; &quot;输入新的数字&quot; &lt;&lt; endl;    &#125;&#125;double hmean(double a, double b)&#123;    if(a &#x3D;&#x3D; -b)&#123;        throw &quot;除数不允许为零&quot;;    &#125;    return 2.0 * a * b &#x2F; (a + b);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>try-catch中，会先将throw后的字符串赋值给s</p><p>当程序出现异常时，throw将程序控制权返还给main</p><p>如果在程序出现问题，但是没有try-catch语句，默认会调用abort()函数 </p><p>在c++中，引入类和对象的概念，对象也可以用作异常类型</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;using namespace std;class bad_hmean&#123;    private:        double v1;        double v2;        public:        bad_hmean(double a &#x3D; 0, double b &#x3D; 0) : v1(a), v2(b)&#123;&#125;        void mesg()&#123;            cout &lt;&lt; &quot;a &#x3D; -b&quot; &lt;&lt; endl;        &#125;&#125;;class bad_gmean&#123;    private:        double v1;        double v2;        public:        bad_gmean(double a &#x3D; 0, double b &#x3D; 0) : v1(a), v2(b)&#123;&#125;        void mesg()&#123;            cout &lt;&lt; &quot;need &gt;&#x3D; 0&quot; &lt;&lt; endl;                    &#125;&#125;;#include &quot;0x03.h&quot;#include &lt;cmath&gt;double hmean(double a, double b);double gmean(double a, double b);int main()&#123;    double x, y, z1, z2;    while(cin &gt;&gt; x &gt;&gt; y)&#123;        try&#123;            z1 &#x3D; hmean(x, y);            cout &lt;&lt; z1 &lt;&lt; endl;            z2 &#x3D; gmean(x, y);            cout &lt;&lt; z2 &lt;&lt; endl;                    &#125;catch(bad_hmean &amp; bh)&#123;            bh.mesg();            continue;        &#125;catch(bad_gmean &amp; bg)&#123;            bg.mesg();            break;        &#125;    &#125;    return 0;&#125;double hmean(double a, double b)&#123;    if(a &#x3D;&#x3D; -b)&#123;        throw bad_hmean(a, b);    &#125;    return 2.0 * a * b &#x2F; (a + b);&#125;double gmean(double a, double b)&#123;    if(a &lt; 0 || b &lt; 0)&#123;        throw bad_gmean(a, b);    &#125;    return sqrt(a * b);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><h3 id="栈解退"><a href="#栈解退" class="headerlink" title="栈解退"></a>栈解退</h3><br/><p>如果try没有调用处理异常的函数，而是调用了对引发异常的函数进行调用的函数，程序将从引发异常的函数跳转到包含try块和处理程序的函数。这种特性被称为栈解退</p><p>如果该异常导致函数终止，栈解退会为对象调用析构函数，并且回退到之前捕获异常的位置</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &quot;0x03.h&quot;#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;cmath&gt;using namespace std;class demo&#123;    private:        string word;    public:        demo(const string &amp; str) : word(str)&#123; cout &lt;&lt; &quot;created &quot; &lt;&lt; word &lt;&lt; endl;&#125;          ~demo()&#123; cout &lt;&lt; &quot;deleted &quot; &lt;&lt; word &lt;&lt; endl;&#125;        void show()&#123; cout &lt;&lt; word &lt;&lt; &quot; exist&quot; &lt;&lt; endl;&#125;&#125;;double hmean(double a, double b);double gmean(double a, double b);double means(double a, double b);int main()&#123;    double x, y, z;    demo d1(&quot;found block in main()&quot;);&#x2F;&#x2F;在整个程序结束之后，这个对象的声明周期才会结束    while(cin &gt;&gt; x &gt;&gt; y)&#123;        try&#123;            z &#x3D; means(x, y);            cout &lt;&lt; z &lt;&lt; endl;        &#125;catch(bad_hmean &amp; bh)&#123;            bh.mesg();            continue;        &#125;catch(bad_gmean &amp; bg)&#123;            bg.mesg();            break;        &#125;    &#125;    return 0;&#125;double hmean(double a, double b)&#123;    if(a &#x3D;&#x3D; -b)&#123;        throw bad_hmean(a, b);    &#125;    return 2.0 * a * b &#x2F; (a + b);&#125;double gmean(double a, double b)&#123;    if(a &lt; 0 || b &lt; 0)&#123;        throw bad_gmean(a, b);    &#125;    return sqrt(a * b);&#125;double means(double a, double b)&#123;    double am, hm, gm;    demo d2(&quot;found in means()&quot;);    am &#x3D; (a + b) &#x2F; 2.0;    try&#123;        hm &#x3D; hmean(a, b);        gm &#x3D; gmean(a, b);    &#125;catch(bad_hmean &amp; bh)&#123;        bh.mesg();        cout &lt;&lt; &quot;caught in means()&quot; &lt;&lt; endl;        throw;&#x2F;&#x2F;再次抛出异常到mai1n函数中    &#125;    d2.show();    return (am + hm + gm) &#x2F; 3.0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>在使用try-catch时，使用catch时，是会创建一个副本的</p><p>但是里面又是使用了引用。引用本身的作用是防止生成副本来提高程序运行效率，这是否矛盾呢</p><p>其实，引用还有一个特性，就是可以和任何派生类匹配</p><p>所以，如果子类出现了问题，可以创建一个基类的引用，从而匹配派生类的对象</p><br/><h3 id="Exception类"><a href="#Exception类" class="headerlink" title="Exception类"></a>Exception类</h3><br/><p>c++提供exception类，可以将exception作为基类，需要的类作为派生类（可以参考Java的写法）</p><p>在该类中，提供了一个what()的虚拟成员函数，它返回一个字符串，可以在类中重新定义它</p><p>c++11提供了noexception，旨在表示这个函数不会引发异常（认为这种声明是有价值的）</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;exception&gt;using namespace std;class bad_mean : public exception&#123;    public:        const char * what() &#123; return &quot;bad arguments to hmean&quot;;&#125;&#125;;try&#123;    &#125;catch(exception &amp; e)&#123;        cout &lt;&lt; e.what() &lt;&lt; endl;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA 反射 p1</title>
      <link href="2021/04/17/JAVA-%E5%8F%8D%E5%B0%84-p1/"/>
      <url>2021/04/17/JAVA-%E5%8F%8D%E5%B0%84-p1/</url>
      
        <content type="html"><![CDATA[<h3 id="Class类-amp-Java反射"><a href="#Class类-amp-Java反射" class="headerlink" title="Class类&amp;Java反射"></a>Class类&amp;Java反射</h3><br/><p>众所周知，Java中的所有类都是继承了Object类的</p><p>这样，在类中就提供了一系列方法返回对应的反射的值</p><br/><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Class_Java &#123;    public static void main(String[] args) &#123;        Apple a1 &#x3D; new Apple();        a1.setPrice(5.6);        System.out.println(a1.getPrice());        System.out.println(a1.getClass());&#x2F;&#x2F;        try &#123;&#x2F;&#x2F;            Class cl1 &#x3D; Class.forName(&quot;java.lang.String&quot;);&#x2F;&#x2F;            System.out.println(cl1.getPackage() + &quot; &quot; + cl1.getClass());&#x2F;&#x2F;        &#125; catch (ClassNotFoundException e) &#123;&#x2F;&#x2F;            e.printStackTrace();&#x2F;&#x2F;        &#125;    &#125;&#125;class Apple&#123;    private double price;    public Apple()&#123;        this(0.0);    &#125;    public Apple(double p)&#123;        p &#x3D; price;    &#125;    public void setPrice(double price) &#123;        this.price &#x3D; price;    &#125;    public double getPrice() &#123;        return price;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>上述是一个比较典型的例子，调用<code>getName()</code>返回String对象</p><p>还有<code>getSuperclass() 获得该类继承的类</code>  <code>getInterfaces() 活得该类实现的所有接口</code></p><br/><h3 id="Class-forName-返回类"><a href="#Class-forName-返回类" class="headerlink" title="Class.forName() 返回类"></a>Class.forName() 返回类</h3><br/><p>forName(String className)，要求JVM查找并加载指定的类，作用是执行该类的静态代码段，加载了类以后还需要进行类初始化操作之后才能正常使用此类，类初始化操作就是执行一遍类的静态语句，包括静态变量的声明还有静态代码块</p><p>可以用这个暂时的类进行一些反射的操作，并且在使用这种操作时一定需要try/catch的环绕。使用<code>ClassNotFoundException</code>报错类型，可以判断是否存在指定的类</p><br/><p>1.初始化initialize=true</p><p>2.总是使用当前类装载器(也就是装载执行forName()请求的类的类装载器)</p><p>3.总是初始化这个被装载的类(当然也包括：装载、连接、初始化</p><br/><p>forName(String className, boolean initialize, ClassLoader loader)</p><br/><p>1.loader指定装载参数类所用的类装载器，如果null则用bootstrp装载器。</p><p>2.initialize=true时，肯定连接，而且初始化了；</p><p>3.initializ=false时，绝对不会初始化，但是可能被连接了，但是这里有个例外，如果在调用这个forName()前，已经被初始化了，那么返回的类型也肯定是被初始化的(当然，这里也暗含着：被同一个loader所装载的，而且这个类被初始化了)</p><br/><h3 id="Class-isPrimitive-判断基本类型"><a href="#Class-isPrimitive-判断基本类型" class="headerlink" title="Class.isPrimitive() 判断基本类型"></a>Class.isPrimitive() 判断基本类型</h3><br/><p>Class.isPrimitive()判定指定的Class对象是否表示一个Java的基本类型（boolean、char、byte、short、int、long、float、double）（String不是基本类型哦）</p><p><code>public boolean isPrimitive()</code></p><br/><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class classForName &#123;    public static void main(String[] args) &#123;        String str &#x3D; &quot;abc&quot;;        Class cls1 &#x3D; str.getClass();        Class cls2 &#x3D; String.class;        Class cls3 &#x3D; null;&#x2F;&#x2F;必须要加上null        try &#123;            cls3 &#x3D; Class.forName(&quot;java.lang.String&quot;);        &#125; catch (ClassNotFoundException e) &#123;            &#x2F;&#x2F; TODO Auto-generated catch block            e.printStackTrace();        &#125;&#x2F;&#x2F;表示这两者是一样的        System.out.println(cls1&#x3D;&#x3D;cls2);        System.out.println(cls1&#x3D;&#x3D;cls3);        System.out.println(cls1.isPrimitive());&#x2F;&#x2F;False 类的不是基本类型        System.out.println(int.class.isPrimitive());&#x2F;&#x2F;True 判定指定的 Class 对象是否表示一个基本类型        System.out.println(int.class &#x3D;&#x3D; Integer.class);&#x2F;&#x2F;False        System.out.println(int.class &#x3D;&#x3D; Integer.TYPE);&#x2F;&#x2F;True        System.out.println(int[].class.isPrimitive());&#x2F;&#x2F;False 不是基本类型，是一个数组类型        System.out.println(int[].class.isArray());&#x2F;&#x2F;True    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><h3 id="访问成员变量"><a href="#访问成员变量" class="headerlink" title="访问成员变量"></a>访问成员变量</h3><br/><h4 id="区分new-amp-newnewInstance"><a href="#区分new-amp-newnewInstance" class="headerlink" title="区分new&amp;newnewInstance"></a>区分new&amp;newnewInstance</h4><br/><p>从jvm的角度看，我们使用new的时候，这个要new的类可以没有加载   </p><p>但是使用newInstance时候，就必须保证：1.这个类已经加载；2.这个类已经连接了</p><p>上面两个步骤的正是class的静态方法forName（）方法，这个静态方法调用了启动类加载器（该加载器用来加载Java API）</p><p>newInstance(): 弱类型。低效率。是<strong>实现IOC、反射、面对接口编程和依赖倒置等技术方法的必然选择</strong></p><p>new: 强类型。相对高效。能调用任何public构造。<strong>new只能实现具体类的实例化，不适合于接口编程</strong>    </p><br/><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.lang.reflect.Field;class Father&#123;    public String name &#x3D; &quot;父亲&quot;;    public String sex &#x3D; &quot;男&quot;;    public String getName() &#123;        return name;    &#125;    public String getSex() &#123;        return sex;    &#125;    public void setName(String name) &#123;        this.name &#x3D; name;    &#125;    public void setSex(String sex) &#123;        this.sex &#x3D; sex;    &#125;&#125;class Son extends Father&#123;    public int age &#x3D; 20;&#125;public class Class_ReflectField &#123;    public static void main(String[] args) &#123;        try &#123;            Class c &#x3D; Class.forName(&quot;Reflect.Son&quot;);&#x2F;&#x2F;获取Son类            Son vo &#x3D; (Son) c.newInstance();&#x2F;&#x2F;对Son对象进行初始化            Field field &#x3D; c.getField(&quot;name&quot;);&#x2F;&#x2F;获取Father类中的name成员变量            System.out.println(field.get(vo));        &#125;catch (Exception e)&#123;            e.printStackTrace();        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><h4 id="获取Field对象"><a href="#获取Field对象" class="headerlink" title="获取Field对象"></a>获取Field对象</h4><br/><p>Field主要获取类中的各种成员变量，可以跟method类比</p><p>Class.getDeclaredField(String name);</p><p>返回一个 Field 对象，该对象反映此 Class 对象所表示的类或接口的指定已声明字段（包括私有成员）</p><p>Class.getDeclaredFields();</p><p>返回 Field 对象的一个<strong>数组</strong>，该数组包含此 Class 对象所表示的类或接口所声明的所有字段（包括私有成员）</p><p>Class.getField(String name);</p><p>返回一个 Field 对象，它反映此 Class 对象所表示的类或接口的指定公共成员字段</p><p>Class.getFields();</p><p>返回一个包含某些 Field 对象的<strong>数组</strong>，该数组包含此 Class 对象所表示的类或接口的所有可访问公共字段</p><br/><pre class="line-numbers language-java" data-language="java"><code class="language-java">package Reflect;import java.lang.reflect.Field;public class Dog &#123;    private String name;    protected String sex;    public int age;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name &#x3D; name;    &#125;    public String getSex() &#123;        return sex;    &#125;    public void setSex(String sex) &#123;        this.sex &#x3D; sex;    &#125;    public int getAge() &#123;        return age;    &#125;    public void setAge(int age) &#123;        this.age &#x3D; age;    &#125;    public Dog(String name, String sex, int age)&#123;        this.name &#x3D; name;        this.sex &#x3D; sex;        this.age &#x3D; age;    &#125;    public void information()&#123;        System.out.println(name + &quot; &quot; + sex + &quot; &quot; + age);    &#125;    public void bark()&#123;        System.out.println(&quot;汪汪汪&quot;);    &#125;    public void bite()&#123;        System.out.println(&quot;PrPr&quot;);    &#125;&#125;class Main&#123;    public static void main(String[] args) throws Exception&#123;        Dog dog &#x3D; new Dog(&quot;puppy&quot;, &quot;男&quot;, 18);        dog.bark();        dog.bite();        Class cls &#x3D; dog.getClass();        Field c1 &#x3D; cls.getDeclaredField(&quot;name&quot;);        Field c2 &#x3D; cls.getField(&quot;age&quot;);        System.out.println(c1);        System.out.println(c2);        Field[] fields1 &#x3D; dog.getClass().getFields();&#x2F;&#x2F;只获取public修饰的变量        Field[] fields2 &#x3D; dog.getClass().getDeclaredFields();&#x2F;&#x2F;获取程序中所有的成员变量        System.out.println(&quot;\n------------method.toString--------------&quot;);        for (Field field1 : fields1)&#123;            System.out.println(field1);        &#125;        System.out.println();        for (Field field2 : fields2)&#123;            System.out.println(field2);        &#125;        System.out.println(&quot;\n------------method.getName--------------&quot;);        for (Field field1 : fields1)&#123;            System.out.println(field1.getName());        &#125;        System.out.println();        for (Field field2 : fields2)&#123;            System.out.println(field2.getName());        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><h4 id="使用method获取类方法"><a href="#使用method获取类方法" class="headerlink" title="使用method获取类方法"></a>使用method获取类方法</h4><br/><p>Class.getMethod():获取当前类及所有继承的父类的public修饰的方法（仅包括public）</p><p>Class.getDeclaredMethod():获取当前类的所有方法，包括public/private/protected/default修饰的方法</p><p><code>Method getMethod(String name, Class&lt;?&gt;... parameterTypes) </code></p><p>该方法的第一个参数name是要获得方法的名字，第二个参数parameterTypes是按声明顺序标识该方法形参类型</p><p>返回一个 Method 对象，它反映此 Class 对象所表示的类或接口的指定公共成员方法。方法后面接收的就是Class类的对象，而如：String.class、int.class这些字节码才是Class类的对象</p><br/><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.lang.reflect.Method;class TestBase&#123;    public String str &#x3D; &quot;hello, China!&quot;;    protected String say()&#123;        return &quot;hello, cxy&quot;;    &#125;    protected void say(String str)&#123;        this.str &#x3D; str;    &#125;&#125;public class Class_MethodTest &#123;    public static void main(String[] args) &#123;        TestBase cls &#x3D; new TestBase();        Class c &#x3D; cls.getClass();        Class[] cArg &#x3D; new Class[1];        cArg[0] &#x3D; String.class;&#x2F;&#x2F;让CLass中的成为String.class                try &#123;            &#x2F;&#x2F;第二个参数表示获取方法中的参数，由于第一个重载没有参数，所以便调用该方法            Method m &#x3D; c.getDeclaredMethod(&quot;say&quot;, null);            System.out.println(&quot;method &#x3D; &quot; + m);            Method lMethod &#x3D; c.getDeclaredMethod(&quot;say&quot;, cArg);            System.out.println(&quot;method &#x3D; &quot; + lMethod);        &#125; catch(Exception e) &#123;            System.out.println(e);        &#125;    &#125;&#125;&#x2F;&#x2F;下面定义稍微复杂一些的版本import java.lang.reflect.Method;public class Person &#123;    private String name;    private int ID;    public String speed;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name &#x3D; name;    &#125;    public int getID() &#123;        return ID;    &#125;    public void setID(int ID) &#123;        this.ID &#x3D; ID;    &#125;    public Person(String name, int ID)&#123;        this.name &#x3D; name;        this.ID &#x3D; ID;    &#125;    public void Speak()&#123;        System.out.println(&quot;Hello! My name is &quot; + name);    &#125;    public void run(String speed)&#123;        System.out.println(&quot;I can run &quot; + speed + &quot; KM!!!&quot;);    &#125;&#125;class TestMain&#123;    public static void main(String[] args) throws Exception&#123;        Person person &#x3D; new Person(&quot;cxy&quot;, 25);        person.Speak();        person.run(&quot;10&quot;);        Method m1 &#x3D; person.getClass().getMethod(&quot;Speak&quot;, null);&#x2F;&#x2F;连续调用，就不需要使用Class来过渡了        Method m2 &#x3D; person.getClass().getMethod(&quot;run&quot;, String.class);        System.out.println(m1);        System.out.println(m2);    &#125;&#125;&#x2F;&#x2F;下面的代码具体表现了getMethods&amp;getDeclaredMethods的具体区别import java.lang.reflect.Method;public class Car &#123;    private void bell(String time)&#123;        System.out.println(&quot;didi---&quot; + time);    &#125;    public void run()&#123;        System.out.println(&quot;running&quot;);    &#125;&#125;class CarTest&#123;    public static void main(String[] args) &#123;        Class&lt;?&gt; car &#x3D; Car.class;&#x2F;&#x2F;使用泛型进行class的静态初始化        Method[] methods1 &#x3D; car.getMethods();        Method[] methods2 &#x3D; car.getDeclaredMethods();        System.out.println(&quot;\n------------method.toString--------------&quot;);        for (Method method1 : methods1)&#123;            System.out.println(method1);&#x2F;&#x2F;获取所有Car涉及的方法和接口        &#125;        System.out.println();        for (Method method2 : methods2)&#123;            System.out.println(method2);&#x2F;&#x2F;只获取类中定义的两个方法        &#125;        System.out.println(&quot;\n------------method.getName--------------&quot;);        for (Method method1 : methods1)&#123;            System.out.println(method1.getName());        &#125;        System.out.println();        for (Method method2 : methods2)&#123;            System.out.println(method2.getName());        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id=""><a href="#" class="headerlink" title=""></a></h4>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++ 类模板优化</title>
      <link href="2021/04/17/c-%E7%B1%BB%E6%A8%A1%E6%9D%BF%E4%BC%98%E5%8C%96/"/>
      <url>2021/04/17/c-%E7%B1%BB%E6%A8%A1%E6%9D%BF%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h3 id="指针栈"><a href="#指针栈" class="headerlink" title="指针栈"></a>指针栈</h3><br/><p>使用指针栈的方法之一是，让调用程序提供一个指针数组，每个指针指向不同的字符串</p><p>把指针放在栈中是有意义的，因为每个指针是指向不同字符串的。创建指针是调用程序的任务，不是栈的职责。栈的任务是管理指针，而不是创建指针</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#ifndef CLASSTYPE_H#define CLASSTYPE_H#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;template &lt;class Type&gt;class Stack&#123;    private:        enum &#123;SIZE &#x3D; 10&#125;;        int stacksize;        Type * items;        int top;    public:        explicit Stack(int s &#x3D; SIZE);&#x2F;&#x2F;取消隐式转化        Stack(const Stack &amp; st);        ~Stack()&#123;delete [] items;&#125;        bool isempty()&#123;return top &#x3D;&#x3D; 0;&#125;        bool isfull()&#123;return top &#x3D;&#x3D; stacksize;&#125;        bool push(const Type &amp; item);        bool pop(Type &amp; item);        Stack &amp; operator &#x3D;(const Stack &amp; st);&#x2F;&#x2F;之前已经说过了，返回的指针值&#125;;template &lt;class Type&gt;Stack&lt;Type&gt; :: Stack(int s) : stacksize(s), top(0)&#123;    items &#x3D; new Type[stacksize];&#x2F;&#x2F;分配新的内存&#125;template &lt;class Type&gt;Stack&lt;Type&gt; :: Stack(const Stack &amp; st)&#123;    stacksize &#x3D; st.stacksize;    top &#x3D; st.top;    items &#x3D; new Type[stacksize];        for(int i &#x3D; 0; i &lt; top; i ++)&#123;        items[i] &#x3D; st.items[i];    &#125;&#125;template &lt;class Type&gt;bool Stack&lt;Type&gt; :: push(const Type &amp; item)&#123;    if(top &lt; stacksize)&#123;        items[top] &#x3D; item;        top ++;        return true;    &#125;    return false;&#125;template &lt;class Type&gt;bool Stack&lt;Type&gt; :: pop(Type &amp; item)&#123;    if(top &gt; 0)&#123;        item &#x3D; items[--top];        return true;    &#125;    return false;&#125;template &lt;class Type&gt;Stack&lt;Type&gt; &amp; Stack&lt;Type&gt; :: operator &#x3D;(const Stack&lt;Type&gt; &amp; st)&#123;    if(this &#x3D;&#x3D; &amp;st)&#123;        return * this;    &#125;    delete [] items;    stacksize &#x3D; st.stacksize;    top &#x3D; st.top;    items &#x3D; new Type[stacksize];    for(int i &#x3D; 0; i &lt; stacksize; i ++)&#123;        items[i] &#x3D; st.items[i];    &#125;&#125;#endif<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><h3 id="数组模板和非类型参数"><a href="#数组模板和非类型参数" class="headerlink" title="数组模板和非类型参数"></a>数组模板和非类型参数</h3><br/><p>容器类提供可重用的代码，这也是引入模板的重要原因</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#ifndef ARRAYCLASS_H#define ARRAYCLASS_H#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;template&lt;class T, int n&gt;class ArrayTP&#123;    private:        T ar[n];        public:        ArrayTP();        &#125;;#endifArrayTP &lt;double, 12&gt; atp;&#x2F;&#x2F;在template定义两个参数，使用整性定义对应的栈大小<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>模板类也是支持递归的（套娃），其实本质上就类似一个二维数组</p><p><code>ArrayTP&lt;ArrayTp&lt;int, 5&gt;, 10&gt;</code></p><p>此时，就相当于你创建了一个5行10列的二维数组</p><p>同理，template除了设置整数之外，也可以写两个类</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#ifndef ARRAYCLASS_H#define ARRAYCLASS_H#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;template&lt;class T1, class T2&gt;class ArrayTP&#123;    private:        T1 a;        T2 b;    public:        ArrayTP(const T1 &amp; t1, const T2 &amp; t2) : a(t1), b(t2)&#123;&#125;        ArrayTP()&#123;&#125;        T1 first() const&#123;return a;&#125;&#x2F;&#x2F;返回第一个栈中的值        T2 second() const&#123;return b;&#125;&#x2F;&#x2F;返回第二个栈中的值&#125;;#endif<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>在主函数的调用中，可以通过如下方法对栈进行定义</p><p><code>ArrayTp&lt;stirng, int&gt; atp = &#123;&quot;cxy&quot;, 18&#125;;</code></p><p>两个class对应的是栈中采用的两中类型的储存方式，甚至可以让类型确定默认值<code>&lt;class T1, class T2 = int&gt;</code></p><br/><h3 id="模板的具体化"><a href="#模板的具体化" class="headerlink" title="模板的具体化"></a>模板的具体化</h3><br/><p>1.隐式实例化，上述所写的代码都是隐式实例化</p><p>编译器会根据模板定义来自行生成类的定义，值得一提的是，在真正需要对象之前，编译器是不会生成类的隐式实例化的</p><p>2.显式实例化，编译器使用类声明进行实例化</p><p><code>template class ArrayTp&lt;string, 100&gt;</code></p><p>和隐式实例化一样，根据通用模板进行实例化（虽然没有创建或者提及类对象）</p><p>3.显式具体化，有时候在为特定类型实例化时，对模板进行修改</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template &lt;&gt; class SortedArray&lt;const char *&gt;&#123;        ...        &#125;;SortedArray&lt;const char *&gt; dates;&#x2F;&#x2F;使用特定的类型模板<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>4.部分具体化，部分限制模板的通用性</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template &lt;class T1, class T2&gt;&#x2F;&#x2F;通常的模板class Pair&#123;        ...        &#125;template &lt;class T1&gt;&#x2F;&#x2F;这个里面设定的参数类型是不确定的class Pair&lt;T1, int&gt;&#123;&#x2F;&#x2F;定义给定了确定的int，这样在实例化的时候编译器就能识别并调用特定的模板类        ...        &#125;;template &lt;&gt; class Pair&lt;int, int&gt;&#123;&#x2F;&#x2F;再过分一点(x        ...        &#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><h3 id="成员模板-amp-参数模板"><a href="#成员模板-amp-参数模板" class="headerlink" title="成员模板&amp;参数模板"></a>成员模板&amp;参数模板</h3><br/><p>在一个类的私有成员中可以定义模板，在使用方法时可以使用对应成员模板</p><p>除此之外，还可以中间使用template，这样下面定义的方法的返回值只能是对应的类型了</p><p>参数模板就是直接把基本的类型换成模板而已，<code>template &lt;template&lt;typename T&gt; class typename V&gt;</code></p><br/><h3 id="友元-amp-模板类"><a href="#友元-amp-模板类" class="headerlink" title="友元&amp;模板类"></a>友元&amp;模板类</h3><br/><blockquote><p>非模板友元 即对一般的方法使用友元，不过参数需要提供模板</p><p>约束模板友元 </p><p>约束非模板友元</p></blockquote><br/><h3 id="模板别名"><a href="#模板别名" class="headerlink" title="模板别名"></a>模板别名</h3><br/><p>对于模板的写法一般都比较繁琐，所以可以使用typedef来进行重命名（这种写法在结构体比较常见）</p><p>在c++11中，新增using = 方法来对非模板进行重新命名</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">typedef const char * pc1;const pc2 &#x3D; const char *;&#x2F;&#x2F;新版的可读性更强，更便于理解<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++ 代码的重用</title>
      <link href="2021/04/08/c-%E4%BB%A3%E7%A0%81%E7%9A%84%E9%87%8D%E7%94%A8/"/>
      <url>2021/04/08/c-%E4%BB%A3%E7%A0%81%E7%9A%84%E9%87%8D%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="包含对象成员的类"><a href="#包含对象成员的类" class="headerlink" title="包含对象成员的类"></a>包含对象成员的类</h3><br/><p>valarray类是由头文件vallaray支持的，这个类用于处理数值，这个和vector类似，是模板类</p><p>但是vector和array提供的方法没有valarray提供得多</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;一般使用的c++ 98的定义如下valarry &lt;int&gt; v1;valarry &lt;int&gt; v2(8);&#x2F;&#x2F;定义8个整形元素valarry &lt;int&gt; v3(10, 8);&#x2F;&#x2F;定义8个整形元素，并将值设置为10&#x2F;&#x2F;当然，也可以设置数组，并初始化对应的位数valarray &lt;int&gt; a [5] &#x3D; &#123;1, 2, 3, 4, 5&#125;;&#x2F;&#x2F;c++ 11支持该命名方式<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><blockquote><p>operator<a href=""></a> 访问模板（类）中的元素</p><p>size() 返回包含的元素数</p><p>sum() 返回所有元素的总和</p><p>max() 返回最大的元素</p><p>min() 返回最小的元素</p></blockquote><br/><p>在c++中，有时会进行一些隐式的转换，这样的使用构造方法的时候就容易因为疏忽，导致使用了错误的方法</p><p>而编译器因为使用隐式转换，所以并不会报错，这个时候我们就需要使用explicit关键词</p><p>它可以关闭隐式转换，这样使得我们在不小心写错格式的时候，编译器会进行对应的报错</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#ifndef STRING_2#define STRING_2#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;valarray&gt;using namespace std;class Student&#123;    private:        string name;        valarray &lt;double&gt; scores;    public:        Student() : name(&quot;noob&quot;), scores()&#123;&#125;&#x2F;&#x2F;使用列表初始化时，还是需要用括号        explicit Student(const string &amp; a) : name(a), scores()&#123;&#125;        explicit Student(int n) : name(&quot;NULLY STUDENT&quot;), scores(n)&#123;&#125;        Student(const string &amp; s, int n) : name(s), scores(n)&#123;&#125;        ~ Student();        &#125;;#endif <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>c++也存在着限制结构的特性，比如使用const限制方法修改参数，使用explict防止单参构造函数的隐式转换</p><p>这种东西多多使用，对于编程的可读性和安全性都有较大提升</p><p>如果上述代码不使用初始化列表，c++将会使用成员对象所属类的默认构造函数,并且初始列表的顺序并非要求固定</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">Student(const string &amp; s, int n) :  scores(n), name(s)&#123;&#125;&#x2F;&#x2F;此时类会先初始化name，因为声明的参数它在前面<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><br/><h3 id="私有继承"><a href="#私有继承" class="headerlink" title="私有继承"></a>私有继承</h3><br/><p>使用私有继承，基类的公有成员和保护成员都将称为派生类的私有成员，基类的公有方法将成为派生类的私有方法</p><p>包含将对象作为一个命名的成员对象添加到类中，私有继承将对象作为一个未被命名的继承对象添加到类中</p><p>在进行了私有继承之后，初始化列表就不能使用变量名了（毕竟已经没有变量了），需要使用类名来执行该操作</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#ifndef STUDENT_H#define STUDENT_H#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;valarray&gt;using namespace std;class Student : private string, private valarray &lt;double&gt;&#123;    private:        typedef valarray &lt;double&gt; ArrayDb;&#x2F;&#x2F;重新命名valarry的名字        public:        Student() : string(&quot;noob&quot;), ArrayDb()&#123;&#125;&#x2F;&#x2F;直接使用私有继承的类名        explicit Student(const string &amp; s) : string(s), ArrayDb()&#123;&#125;        explicit Student(int n) : string(&quot;Nully&quot;), ArrayDb(n)&#123;&#125;        Student(const string &amp; a, int n) : string(a), ArrayDb(n)&#123;&#125;    Student(const string &amp; as, const ArrayDb &amp; ad)             : string(as), ArrayDb(ad)&#123;&#125;&#x2F;&#x2F;直接使用类模板，直接对整体进行定义        Student(const string &amp; str, const double * pd, int n)             : string(str), ArrayDb(pd, n)&#123;&#125;&#x2F;&#x2F;通过指针实现不同位置的初始化        ~Student();&#125;;#endif<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>在访问基类方法的方面，私有也有很大差异</p><p>以前在类声明中可以自由使用定义的方法，私有继承使得能够使用类名和作用域解析运算符来调用基类方法</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">double Student :: Average() const&#123;    if(ArrayDb :: size() &gt; 0)&#123;        return ArrayDb :: sum() &#x2F; ArrayDb :: size();&#x2F;&#x2F;通过类调用方法使用::    &#125;else&#123;        return 0;    &#125;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>那么这是你可能会有个疑问，私有继承只有类没有名称，怎么访问基类对象呢</p><p>这时，就需要使用强制转换</p><p>我们知道this指针用来指向基类中的对象，那么返回值中，就可以使用* this来进行操作</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">const string &amp; Student :: Name() const&#123;    return (const string &amp;)* this;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>对于基类的友元函数，也可以使用强制转换进行访问</p><p>毕竟类中使用的是多重继承，如果不进行强制转换编译器就不知道怎么使用 </p><p>在一般的编程中，往往需要选择使用包含还是使用私有继承</p><p>在包含中，一般不会出现私有继承中的复杂问题，而且可读性强不会很抽象，并且可以支持多个同类的子对象（私有继承还是通过类和类型转换来判断对应的继承）</p><p>但是私有继承也有更多的特性，在包含中，假设类包含保护成员。这样的成员在派生类中是可用的，在继承层次结构外是不可用的。后者不是派生类，而是位于继承层次结构之外，因此不能访问保护成员。但是通过继承得到的是派生类，可以访问保护成员</p><p>派生类可以重新定义虚函数，但是包含类不行。使用私有继承，重新定义的函数将只能在类中使用，而不是公有的</p><br/><h4 id="保护继承"><a href="#保护继承" class="headerlink" title="保护继承"></a>保护继承</h4><br/><p>在继承这一块，也分为公有、保护、私有继承这三类</p><p>在前两者中，你可以使用隐式向上转换（即不需要进行显示转换就能将基类指针或引用指向派生类）</p><br/><table><thead><tr><th align="center">公有继承</th><th align="center">保护继承</th><th align="center">私有继承</th></tr></thead><tbody><tr><td align="center">可以隐式向上转换</td><td align="center">可以隐式向上转换（仅限于派生类中）</td><td align="center">不能隐式向上转换</td></tr></tbody></table><br/><h4 id="使用using重新定义访问权限"><a href="#使用using重新定义访问权限" class="headerlink" title="使用using重新定义访问权限"></a>使用using重新定义访问权限</h4><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Student : private string, private valarray &lt;double&gt;&#123;    ...        public:    using valarray &lt;double&gt; :: max;    using valarray &lt;double&gt; :: min;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>这样，就可以使用相当于公有方法的max&amp;min</p><p>不过要注意，using声明只使用成员名-没有圆括号、函数特征&amp;返回类型</p><br/><h3 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h3><br/><p>c++不存在Java那样的接口，所以支持多重继承，再来就有上述的三种继承类型的描述（这称之为MI）</p><p>但是这样就会引发很多问题，就比如继承了不同类的同名方法。自然支持者和反对者还有谨慎使用者三者就诞生了（</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#ifndef JOBS_H#define JOBS_H#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;class Worker&#123;    private:        string name;        int id;        public:        Worker() : name(&quot;Noob&quot;), id(0)&#123;&#125;        Worker(const string &amp; n, int i) : name(n), id(i)&#123;&#125;        virtual ~Worker() &#x3D; 0;        virtual void Set();        virtual void Show() const;&#125;;class Waiter : public Worker&#123;    private:        int panache;        public:        Waiter() : Worker(), panache(0)&#123;&#125;        Waiter(const string &amp; s, int i, int p &#x3D; 0) : Worker(s, i), panache(p)&#123;&#125;        Waiter(const Worker &amp; w, int p &#x3D; 0) : Worker(w), panache(p)&#123;&#125;        void Set();        void Show();&#125;;class Singer : public Worker&#123;    private:        int voice;    public:        Singer() : Worker(), voice(0)&#123;&#125;        Singer(const string &amp; s, int i, int v) : Worker(s, i), voice(v)&#123;&#125;        Singer(const Worker &amp; w, int v) : Worker(w), voice(v)&#123;&#125;        void Set();        void Show();&#125;;#endif<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &quot;Jobs.h&quot;Worker :: ~Worker()&#123;&#125;void Worker :: Set()&#123;    cout &lt;&lt; &quot;enter name: &quot;;    getline(cin, name);&#x2F;&#x2F;getline（cin,str）读的时候会读入这个回车，并判断结束了    cout &lt;&lt; &quot;enter id: &quot;;    cin &gt;&gt; id;    while(cin.get() !&#x3D; &#39;\n&#39;)&#123;&#x2F;&#x2F;判断只有换行符才能继续执行下面的命令                continue;    &#125;&#125;void Worker :: Show() const&#123;    cout &lt;&lt; &quot;name: &quot; &lt;&lt; name &lt;&lt; endl;    cout &lt;&lt; &quot;id &quot; &lt;&lt; id &lt;&lt; endl;&#125;void Waiter :: Set()&#123;    Worker :: Set();    cout &lt;&lt; &quot;enter panache: &quot;;    cin &gt;&gt; panache;    while(cin.get() !&#x3D; &#39;\n&#39;)&#123;&#x2F;&#x2F;这个地方不能使用&quot;\n&quot;，因为这是字符串，不是基本类型，无法转换                continue;    &#125;&#125;...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><h3 id="虚基类"><a href="#虚基类" class="headerlink" title="虚基类"></a>虚基类</h3><br/><p>在多重继承中，如果继承的两个类都来自于同一个基类，那么就相当于继承了两个基类组件，这个时候就需要使用虚基类来使用MI</p><p>在继承是使用virtual关键字，就可以使用（virtual&amp;public的顺序没有影响）</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Singer : virtual public Worker&#123;&#125;class Waiter : public virtual Worker&#123;&#125;class SingingWaiter : public Singer, public Waiter&#123;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><br/><p>在这个时候，构造函数的规则会发生变化</p><p>例如你可以构造三个类，并通过递归（套娃）的方式将他们的构造函数依次初始化</p><p>但是如果你是使用的虚基类，信息的自动传递就起不了作用，禁止使用中间类进行传递</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">SingingWaiter(const Worker &amp; w, int p &#x3D; 0, int v &#x3D; Singer :: other)    : Worker(w), Waiter(w, p), Singer(w, v)&#123;&#125;&#x2F;&#x2F;在虚基类中，必须这样显式地调用构造函数，对于非虚基类，这是违法的<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><br/><p>当然，既然是多重继承，就一定会碰到调用相同方法的问题</p><p>我们可以直接在调用界面，使用 :: 来区分不同的方法，但更推荐的方法是重新定义方法</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">SingingWaiter sw(&quot;cxy&quot;, 2005, 6, piano);sw.Waiter :: show();&#x2F;&#x2F;直接通过类来区分void SingingWaiter :: Show()&#123;        Waiter :: Show();    &#x2F;&#x2F;这时候可以适当调整原来代码，使得两个类中的方法可以同时调用并且不会重复    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>如果继承中之继承了一个虚基类，必须满足以下条件：</p><blockquote><p>有间接虚基类的派生类包括直接调用间接基类构造函数的构造函数，对于间接非虚类是非法的</p><p>通过优先顺序解决二义性问题（即包含相同的方法名）</p></blockquote><br/><h3 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h3><br/><p>在之前的模板中，有接触了解过Stack&amp;Queue类</p><p>类模板为生成通用的类声明提供了一种更好的方法，之后将会用类模板代替原有的模板</p><p>模板类开头时一般都要写上 <code>template &lt;class Type&gt;</code>，这里的Type只表明一个通用的类型说明符</p><p>（调用的时候，Type一般会用具体的类型来替换，就比如使用<code>Stack &lt;int&gt;</code>）</p><p>要注意一点的是，模板不是函数，所以不能够单独编译（虽然c++提供了export可以将模板成员单独放在文件中编译，但是不是所有编译器都支持这种用法。在c++11中，甚至将export的用法转换到了别的方面）。最简单的解决办法还是将两者放在同一个文件中</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#ifndef CLASSTYPE_H#define CLASSTYPE_H#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;template &lt;class Type&gt;class Stack&#123;    private:        enum &#123;MAX &#x3D; 10&#125;;        Type items[MAX];        int top;    public:        Stack();        bool isempty();        bool isfull();        bool push(const Type &amp; item);        bool pop(Type &amp; item);&#125;;template &lt;class Type&gt;Stack&lt;Type&gt; :: Stack()&#123;    top &#x3D; 0;&#125;template &lt;class Type&gt;bool Stack&lt;Type&gt; :: isempty()&#123;    return top &#x3D;&#x3D; 0;&#125;template &lt;class Type&gt;bool Stack&lt;Type&gt; :: isfull()&#123;     return top &#x3D;&#x3D; MAX;    &#125;template &lt;class Type&gt;bool Stack&lt;Type&gt; :: push(const Type &amp; item)&#123;    if(top &lt; MAX)&#123;        items[top] &#x3D; item;        top ++;        return true;    &#125;    return false;&#125;template &lt;class Type&gt;bool Stack&lt;Type&gt; :: pop(Type &amp; item)&#123;    if(top &gt; 0)&#123;        item &#x3D; items[--top];        return true;    &#125;    return false;&#125;#endif<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>下面列举三种不正确的Type使用方式</p><blockquote><p>1.char * 这个用指针代替了字符串形式，但是不可行，因为没有创建用于保存字符串的空间</p><p>2.char [40] 这个虽然有创建空间，但是和pop中的定义相违背（在进行赋值时，必须要是可以被引用的左值，而不是数组（数组相当于一个常量指针））</p><p>3.char * = new char[40] 在压入操作时，总是会读取同一个地址（即字符串末）因此也是没有用的</p></blockquote><br/><h3 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h3><br/><p>举例代码使用了枚举说明常量</p><p>在之前，我们就已经比较过define和const的优劣，使用enum有以下好处</p><p>1.使程序更容易维护，因为枚举常量是由编译程序自动生成的，而标识符常量必须由程序员手工赋值</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++"> enum Error_Code&#123;&#x2F;&#x2F;可以定义一组枚举常量，作为程序中可能发生的错误的错误号        OUT_OF_MEMORY，          INSUFFICIENT_DISK_SPACE，         LOGIC_ERROR，       FILE_NOT_FOUND       &#125;;  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre> <br/><p>2.使程序更易读，这样别人修改你的程序时就比较方便</p><p>3.使程序调试起来更方便，因为某些标识符调试程序能打印枚举常量的值</p><p>如果你的程序在使用枚举常量的一行语句中停住了，你就能马上检查出这个常量的值；反之，绝大多数调试程序无法打印标识符常量的值，因此你不得不在头文件中手工检查该常量的值</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA I/O（输入输出）</title>
      <link href="2021/04/04/JAVA-I-O%EF%BC%88%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%EF%BC%89/"/>
      <url>2021/04/04/JAVA-I-O%EF%BC%88%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>这个东西和c++差不多，通过流进行输入和输出，所以概念就不再过多描述</p><br/><h3 id="输入-输出流"><a href="#输入-输出流" class="headerlink" title="输入/输出流"></a>输入/输出流</h3><br/><h4 id="InputStream"><a href="#InputStream" class="headerlink" title="InputStream"></a>InputStream</h4><br/><p>输入流中，使用inputStream类，是所有字节输入流的父类</p><blockquote><p>read() 从输入流中读取数据的下一个字节，也可以读入一定长度的字节并已整数的形式返回</p><p>mark() 在输入流的当前位置放置一个标记，参数表示次输入流在标记位置失效前允许读取的字节数</p><p>reset() 将输入指针返回到当前所做的标记处</p><p>skip() 跳过输入流上的n个字节并返回实际跳过的字节数</p><p>close() 关闭次输入流并释放与该流关联的所有系统资源</p></blockquote><p>并不是所有inputStream类的子类都支持父类中的所有方法</p><br/><h4 id="Reader"><a href="#Reader" class="headerlink" title="Reader"></a>Reader</h4><br/><p>父类是对字节处理的，对于字符串的处理并不是很方便</p><p>所以在Java在处理字符串的时候，提供了一个单独的类Reader，是字符输入流的抽象类</p><br/><h4 id="OutputStream"><a href="#OutputStream" class="headerlink" title="OutputStream"></a>OutputStream</h4><br/><p>OutputStream类是字节输出类的抽象类，类中所有的方法都是void</p><blockquote><p>write() 将指定的字节写入此输出流</p><p>flush() 彻底完成输出并清空缓存区</p><p>close() 关闭输出流</p></blockquote><br/><h3 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h3><br/><p>可以使用File类创建一个文件对象，进行文件路径指定</p><br/><pre class="line-numbers language-java" data-language="java"><code class="language-java">new File(String pathname);new File(String parent, String child);new File(File f, String child);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><br/><blockquote><p>parent 父路径字符串，例如D:/</p><p>child 子路径字符串，例如cxy.docx</p></blockquote><br/><p>File类提供了很多方法以获取文件本身信息</p><br/><table><thead><tr><th align="center">方法</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">getName()</td><td align="center">获取文件的名称</td></tr><tr><td align="center">canRead()</td><td align="center">判断文件是否为可读的</td></tr><tr><td align="center">canWrite()</td><td align="center">判断文件是否可被写入</td></tr><tr><td align="center">exits()</td><td align="center">判断文件是否存在</td></tr><tr><td align="center">length()</td><td align="center">获取文件的长度</td></tr><tr><td align="center">getAbsolutePath()</td><td align="center">获取文件的绝对路径</td></tr><tr><td align="center">isFile()</td><td align="center">判断文件是否存在</td></tr><tr><td align="center">isDirectory()</td><td align="center">判断文件是否一个目录</td></tr><tr><td align="center">isHidden()</td><td align="center">判断文件是否为隐藏文件</td></tr><tr><td align="center">lastModified()</td><td align="center">获取文件最后的修改时间</td></tr></tbody></table><br/><h3 id="文件输出输入流"><a href="#文件输出输入流" class="headerlink" title="文件输出输入流"></a>文件输出输入流</h3><br/><p>FileInputStream&amp;FileOutputStream类，可以实现对文件内容进行操作</p><p>该类继承了InputStream&amp;OutputStream的方法</p><br/><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.io.File;import java.io.FileInputStream;import java.io.FileOutputStream;public class IO_Practice &#123;    public static void main(String[] args) &#123;        File f &#x3D; new File(&quot;D:&#x2F;Test&quot;, &quot;abc.txt&quot;);        try &#123;&#x2F;&#x2F;在Java中，为了安全性的考虑，使用该类一定要使用异常捕获            FileOutputStream out &#x3D; new FileOutputStream(f);            byte [] bytes &#x3D; &quot;我是傻逼&quot;.getBytes();&#x2F;&#x2F;创建byte型数组            out.write(bytes);            out.close();        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;        try &#123;            FileInputStream in &#x3D; new FileInputStream(f);            byte [] buy &#x3D; new byte[2048];            int length &#x3D; in.read(buy);            System.out.println(&quot;文件中的信息：&quot; + new String(buy, 0, length));            in.close();        &#125;catch (Exception e)&#123;            e.printStackTrace();        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>虽然Java在程序结束时自动关闭所有打开的流，但是使用完流后，手动显示关闭仍然是一个好习惯</p><p>一个被打开的流有可能会用尽系统资源，这取决平台和系统（</p><br/><h3 id="浅谈上述代码使用到的知识"><a href="#浅谈上述代码使用到的知识" class="headerlink" title="浅谈上述代码使用到的知识"></a>浅谈上述代码使用到的知识</h3><br/><h4 id="String-amp-new-String"><a href="#String-amp-new-String" class="headerlink" title="String&amp;new String"></a>String&amp;new String</h4><br/><p>在研究String直接赋值与new String的区别之前我们需要先了解java中的字符串常量池的概念</p><p>String类是我们平常项目中使用频率非常高的一种对象类型，Java为了提升性能和减少内存开销，避免字符的重复创建，其维护了一块特殊的内存空间，即字符串池</p><p>当需要使用字符串时，先去字符串池中查看该字符串是否已经存在，如果存在，则可以直接使用，如果不存在，初始化并将该字符串放入字符创常量池中</p><br/><h5 id="String直接赋值"><a href="#String直接赋值" class="headerlink" title="String直接赋值"></a>String直接赋值</h5><br/><p>String str = “abc”;可能创建一个或者不创建对象，如果”abc”在字符串池中不存在，会在java字符串池中创建一个String对象（”abc”），然后str指向这个内存地址，无论以后用这种方式创建多少个值为”abc”的字符串对象，始终只有一个内存地址被分配</p><p>==判断的是对象的内存地址，而equals判断的是对象内容</p><br/><pre class="line-numbers language-java" data-language="java"><code class="language-java">String str &#x3D; &quot;abc&quot;;String str1 &#x3D; &quot;abc&quot;;String str2 &#x3D; &quot;abc&quot;;System.out.println(str&#x3D;&#x3D;str1);&#x2F;&#x2F;trueSystem.out.println(str&#x3D;&#x3D;str2);&#x2F;&#x2F;true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><h5 id="new-String-创建字符串"><a href="#new-String-创建字符串" class="headerlink" title="new String 创建字符串"></a>new String 创建字符串</h5><br/><p>String str = new String(“abc”);至少会创建一个对象，也有可能创建两个。因为用到new关键字，肯定会在堆中创建一个String对象</p><p>如果字符池中已经存在”abc”,则不会在字符串池中创建一个String对象，如果不存在，则会在字符串常量池中也创建一个对象</p><br/><pre class="line-numbers language-java" data-language="java"><code class="language-java">String str &#x3D; new String(&quot;abc&quot;);String str1 &#x3D; new String(&quot;abc&quot;);String str2 &#x3D; new String(&quot;abc&quot;);System.out.println(str&#x3D;&#x3D;str1);&#x2F;&#x2F;falseSystem.out.println(str&#x3D;&#x3D;str2);&#x2F;&#x2F;false<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><h5 id="String拼接字符串"><a href="#String拼接字符串" class="headerlink" title="String拼接字符串"></a>String拼接字符串</h5><br/><p>项目中除了直接使用=赋值，也会用到字符串拼接，字符串拼接又分为变量拼接和已知字符串拼接</p><p>所以在项目中还是不要使用new String去创建字符串，最好使用String直接赋值</p><br/><pre class="line-numbers language-java" data-language="java"><code class="language-java">String str &#x3D; &quot;abc&quot;;&#x2F;&#x2F;在常量池中创建abcString str1 &#x3D; &quot;abcd&quot;;&#x2F;&#x2F;在常量池中创建abcdString str2 &#x3D; str+&quot;d&quot;;&#x2F;&#x2F;拼接字符串，此时会在堆中新建一个abcd的对象，因为str2编译之前是未知的String str3 &#x3D; &quot;abc&quot;+&quot;d&quot;;&#x2F;&#x2F;拼接之后str3还是abcd，所以还是会指向字符串常量池的内存地址System.out.println(str1&#x3D;&#x3D;str2);&#x2F;&#x2F;falseSystem.out.println(str1&#x3D;&#x3D;str3);&#x2F;&#x2F;true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><h4 id="getBytes"><a href="#getBytes" class="headerlink" title="getBytes()"></a>getBytes()</h4><br/><p>返回一个字节数组，上述代码使用了一个偷懒的写法</p><p>byte [] bytes = “我是傻逼”.getBytes(); 这个用了一个比较偷懒的写法</p><br/><pre class="line-numbers language-java" data-language="java"><code class="language-java">String a &#x3D; &quot;我是傻逼&quot;;byte [] bytes &#x3D; a.getBytes();&#x2F;&#x2F;上述代码也可以这么写<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><br/><h3 id="带缓存的输入输出"><a href="#带缓存的输入输出" class="headerlink" title="带缓存的输入输出"></a>带缓存的输入输出</h3><br/><p>在输入输出使用缓存时，可以加快文件的写入读取速度，从而达到性能的优化</p><p>使用BufferedInputStream&amp;BufferedOutputStream</p><br/><p>BufferedReader</p><blockquote><p>read() 读取单个字符</p><p>readLine() 读取一个文本行</p></blockquote><p>BufferedWriter</p><blockquote><p>write() 写入字符串的某一部分</p><p>flush() 刷新该流的缓存</p><p>newLine() 写入一个行分隔符</p></blockquote><br/><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.io.*;public class IO_Practice_Plus &#123;    public static void main(String[] args) &#123;        String [] content &#x3D; &#123;&quot;好久不见&quot;, &quot;最近好吗&quot;, &quot;常联系&quot;&#125;;        File file &#x3D; new File(&quot;D:&#x2F;Test&quot;, &quot;a.txt&quot;);        try &#123;            FileWriter fileWriter &#x3D; new FileWriter(file);            BufferedWriter writer &#x3D; new BufferedWriter(fileWriter);&#x2F;&#x2F;缓存写入本身是文件写入的一种            int k;            for (k &#x3D; 0; k &lt; content.length; k ++)&#123;                writer.write(content[k]);                writer.newLine();            &#125;            writer.close();            fileWriter.close();        &#125;catch (Exception e)&#123;            e.printStackTrace();        &#125;        try &#123;            FileReader fileReader &#x3D; new FileReader(file);            BufferedReader reader &#x3D; new BufferedReader(fileReader);            int i &#x3D; 0;            String s;            while ((s &#x3D; reader.readLine()) !&#x3D; null)&#123;                i ++;                System.out.println(&quot;第&quot; + i + &quot;行 &quot; + s);            &#125;            reader.close();&#x2F;&#x2F;先从最里层的套娃开始关闭            fileReader.close();        &#125;catch (Exception e)&#123;            e.printStackTrace();        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><h3 id="数据的输入输出"><a href="#数据的输入输出" class="headerlink" title="数据的输入输出"></a>数据的输入输出</h3><br/><p>在FileInputStream&amp;FileOutputStream的基础上，进一步完善，使得数据的输入输出更加方便</p><p>使用DataInputStream&amp;DataOutputStream</p><blockquote><p>writeBytes()</p><p>writeChars()</p><p>writeUTF()</p></blockquote><p>通过三种方法，可以实现写入不同编码格式的数据</p><p>在读取的时候，类中只提供了readUTF()返回字符串，如果用其他的编码方式编写了代码，想要读取就没那么方便了</p><br/><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.io.*;import java.util.Scanner;public class Example_0x01 &#123;    public static void main(String[] args) &#123;        File file &#x3D; new File(&quot;D:&#x2F;Test&quot;, &quot;Example_0x01.txt&quot;);        Scanner in &#x3D; new Scanner(System.in);        String string;        int count &#x3D; 0, i;        try &#123;            FileOutputStream fileOutputStream &#x3D; new FileOutputStream(file);            DataOutputStream dataOutputStream &#x3D; new DataOutputStream(fileOutputStream);            while (!(string &#x3D; in.nextLine()).equals(&quot;***&quot;))&#123;                count ++;                dataOutputStream.writeUTF(string);            &#125;            dataOutputStream.close();            fileOutputStream.close();        &#125;catch (Exception e)&#123;            e.printStackTrace();        &#125;        try &#123;            FileInputStream fileInputStream &#x3D; new FileInputStream(file);            DataInputStream dataInputStream &#x3D; new DataInputStream(fileInputStream);            for (i &#x3D; 0; i &lt; count; i ++)&#123;                System.out.println(dataInputStream.readUTF());            &#125;            dataInputStream.close();            fileInputStream.close();        &#125;catch (Exception e)&#123;            e.printStackTrace();        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><h3 id="ZIP压缩输入输出"><a href="#ZIP压缩输入输出" class="headerlink" title="ZIP压缩输入输出"></a>ZIP压缩输入输出</h3><br/><p>理所当然使用ZipOutputStream类对象，继承自OutputStream</p><br/><table><thead><tr><th align="center">方法</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">putNextEntry()</td><td align="center">开始写一个新的ZipEntry，并将流内的位置移至此entry所指的数据开头</td></tr><tr><td align="center">wirte()</td><td align="center">将字节数组写入当前ZIP条目数据</td></tr><tr><td align="center">finish()</td><td align="center">完成写入ZIP输出流的内容（注意，这个无需关闭对应的OutputStream）</td></tr><tr><td align="center">setComment</td><td align="center">设置此ZIP文件中的注释文字</td></tr></tbody></table><br/><p>当然，解压也是必不可少的工作，这个时候使用ZipInputStream(InputStream in)</p><br/><table><thead><tr><th align="center">方法</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">read()</td><td align="center">读取目标b数组内的内容，需要偏移量和字节长度</td></tr><tr><td align="center">available()</td><td align="center">判断是否已读完目前entry所指定的数据</td></tr><tr><td align="center">closeEntry()</td><td align="center">关闭当前ZIP条目并定位流以读取下一个条目</td></tr><tr><td align="center">skip()</td><td align="center">跳过当前ZIP条目中指定的字节数</td></tr><tr><td align="center">getNextEntry()</td><td align="center">读取下一个ZipEntry，并将流内的位置移至数据开头</td></tr><tr><td align="center">createZipEntry()</td><td align="center">以指定名字新建ZipEntrt对象</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA 集合类</title>
      <link href="2021/04/01/JAVA-%E9%9B%86%E5%90%88%E7%B1%BB/"/>
      <url>2021/04/01/JAVA-%E9%9B%86%E5%90%88%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<p>在这里的集合，你可以看作c++中的栈</p><p>不过拜Java的接口所赐，集合写起来会更加的自然且方便，不需要再像c++那样了</p><br/><h3 id="collection接口"><a href="#collection接口" class="headerlink" title="collection接口"></a>collection接口</h3><br/><p>List集合和Set集合都继承了collection接口，所以可以使用对应的方法</p><p>在这里也是先简单了解一下集合类的使用</p><br/><table><thead><tr><th align="center">方法</th><th align="center">功能描述</th></tr></thead><tbody><tr><td align="center">add()</td><td align="center">将一个对象添加到集合中</td></tr><tr><td align="center">remove</td><td align="center">将对应的对象从集合中移除</td></tr><tr><td align="center">isEmpty()</td><td align="center">判断当前集合是否为空</td></tr><tr><td align="center">iterator()</td><td align="center">返回collection的元素上进行的迭代器，用于遍历集合中的对象</td></tr><tr><td align="center">size()</td><td align="center">获取集合中元素的个数</td></tr></tbody></table><br/><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.util.ArrayList;import java.util.Collection;import java.util.Iterator;public class List_Practice &#123;    public static void main(String[] args) &#123;        Collection &lt;String&gt; list &#x3D; new ArrayList&lt;&gt;();&#x2F;&#x2F;实例化集合类对象        list.add(&quot;陈鑫扬哥哥好帅&quot;);        list.add(&quot;常陆茉子，我永远的老婆&quot;);        list.add(&quot;回复术士这玩意竟然能播出来？&quot;);        Iterator &lt;String&gt; iterator &#x3D; list.iterator();&#x2F;&#x2F;创建迭代器，返回值是一个对象                while (iterator.hasNext())&#123;&#x2F;&#x2F;判断是否有下一个元素            String str &#x3D; iterator.next();&#x2F;&#x2F;获取集合中的元素            System.out.println(str);        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><h3 id="List集合"><a href="#List集合" class="headerlink" title="List集合"></a>List集合</h3><br/><p>list继承collection接口，因此可以使用该接口的所有方法，初次之外还有两个常用的方法</p><blockquote><p>get(int index) 获得指定索引位置的元素（与数组相同，集合的索引也是从0开始）</p><p>set(int index, Object obj) 将集合中指定索引位置的对象修改为指定的对象</p></blockquote><p>list的接口常用实现类也有两种</p><blockquote><p>ArrayList类 实现了可变的数组，允许保存所有元素包括null，可以根据索引位置进行快速随机访问</p><p>LinkedList类 采用链表结构保存对象，这种结构的优点是便于向集合中插入和删除对象，这个时候的效率很高</p></blockquote><p>此时我们可以知道，两个类互为优缺点</p><br/><h3 id="Set集合"><a href="#Set集合" class="headerlink" title="Set集合"></a>Set集合</h3><br/><p>Set集合中的对象不按特定的方式排序，只是简单的把对象放到集合中，所以这个类中不能有重复的对象</p><p>同时，这个Set集合也继承了Collection接口</p><p>Set接口常用的实现类有HashSet类与TreeSet类</p><blockquote><p>HashSet 由哈希表支持，不保证Set的迭代顺序，特别是不保证该顺序保持不变。此类允许使用null元素</p><p>TreeSet 不仅实现了Set接口，还实现了java.util.SortedSet接口，因此实现在遍历集合时按照自然顺序递增排序</p></blockquote><br/><table><thead><tr><th align="center">方法</th><th align="center">功能描述</th></tr></thead><tbody><tr><td align="center">first()</td><td align="center">返回集合中的第一个元素</td></tr><tr><td align="center">last()</td><td align="center">返回集合中的最后一个元素</td></tr><tr><td align="center">comparator()</td><td align="center">返回对此Set中的元素进行排序的比较器，如果使用自然排序，则返回null</td></tr><tr><td align="center">headSet()</td><td align="center">返回一个新的Set集合，新集合是括号中对象之前的所有对象（不包括本身）</td></tr><tr><td align="center">subSet()</td><td align="center">返回在两个对象之间的所有对象（不包括本身）</td></tr><tr><td align="center">tailSet()</td><td align="center">返回之后的对象（包括本身）</td></tr></tbody></table><br/><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.util.Iterator;import java.util.TreeSet;public class Set_Practice&#123;    public static void main(String[] args) &#123;        StudentMessage message1 &#x3D; new StudentMessage(&quot;陈鑫扬&quot;, 1);        StudentMessage message2 &#x3D; new StudentMessage(&quot;范文豪&quot;, 2);        StudentMessage message3 &#x3D; new StudentMessage(&quot;陆晓琦&quot;, 3);        StudentMessage message4 &#x3D; new StudentMessage(&quot;张运培&quot;, 4);        TreeSet &lt;StudentMessage&gt; set &#x3D; new TreeSet&lt;&gt;();        set.add(message1);        set.add(message2);        set.add(message3);        set.add(message4);        Iterator iterator &#x3D; set.iterator();&#x2F;&#x2F;Set集合中所有元素的迭代器        System.out.println(&quot;输出集合中的所有元素&quot;);        while (iterator.hasNext())&#123;            StudentMessage stu &#x3D; (StudentMessage) iterator.next();            System.out.println(&quot;姓名：&quot; + stu.getName() + &quot;  id：&quot; + stu.getId());        &#125;        iterator &#x3D; set.headSet(message2).iterator();&#x2F;&#x2F;截取前面的对象        System.out.println(&quot;输出集合前面的所有元素&quot;);        while (iterator.hasNext())&#123;            StudentMessage stu &#x3D; (StudentMessage) iterator.next();            System.out.println(&quot;姓名：&quot; + stu.getName() + &quot;  id：&quot; + stu.getId());        &#125;        iterator &#x3D; set.subSet(message2, message3).iterator();        System.out.println(&quot;输出集合中间的所有元素&quot;);        while (iterator.hasNext())&#123;            StudentMessage stu &#x3D; (StudentMessage) iterator.next();            System.out.println(&quot;姓名：&quot; + stu.getName() + &quot;  id：&quot; + stu.getId());        &#125;    &#125;&#125;class StudentMessage implements Comparable&lt;Object&gt;&#123;    private String name;    private int id;    public StudentMessage(String name, int id)&#123;        this.name &#x3D; name;        this.id &#x3D; id;    &#125;    @Override    public int compareTo(Object o) &#123;&#x2F;&#x2F;规定比较的方式        StudentMessage message &#x3D; (StudentMessage) o;        return Integer.compare(id, message.id);        &#x2F;&#x2F;Integer类中的一个方法，比较前后两个整形书的大小，大于返回1，等于返回0，小于返回-1    &#125;    public void setName(String name) &#123;        this.name &#x3D; name;    &#125;    public String getName() &#123;        return name;    &#125;    public void setId(int id) &#123;        this.id &#x3D; id;    &#125;    public int getId() &#123;        return id;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><h3 id="Map集合"><a href="#Map集合" class="headerlink" title="Map集合"></a>Map集合</h3><br/><p>Map集合比较特殊，其没有继承Collection接口，使用的是键值对（这个在我php中讲过）</p><br/><table><thead><tr><th align="center">方法</th><th align="center">功能描述</th></tr></thead><tbody><tr><td align="center">put()</td><td align="center">向集合中添加对应的键值对</td></tr><tr><td align="center">containsKey()</td><td align="center">判断存在对应的键名</td></tr><tr><td align="center">containsValue()</td><td align="center">判断存在对应的值</td></tr><tr><td align="center">get()</td><td align="center">如果存在对应的key，就返回对象的值</td></tr><tr><td align="center">keySet()</td><td align="center">返回所有key对象形成的Set集合</td></tr><tr><td align="center">values()</td><td align="center">返回该集合中所有值对象形成的Collection集合</td></tr></tbody></table><br/><pre class="line-numbers language-java" data-language="java"><code class="language-java">package Collection_Practice;import java.util.*;public class Map_Practice &#123;    public static void main(String[] args) &#123;        Map&lt;String, String&gt; map &#x3D; new HashMap&lt;&gt;();        map.put(&quot;01&quot;, &quot;cxy&quot;);        map.put(&quot;02&quot;, &quot;fwh&quot;);        Set &lt;String&gt; set &#x3D; map.keySet();        Collection &lt;String&gt; collection &#x3D; map.values();        Iterator &lt;String&gt; iterator &#x3D; set.iterator();&#x2F;&#x2F;加入&lt;String&gt;可以规定迭代器的范围        System.out.println(&quot;Map中的键名&quot;);        while (iterator.hasNext())&#123;            System.out.println(iterator.next());        &#125;        iterator &#x3D; collection.iterator();        System.out.println(&quot;Map中的键值&quot;);        while (iterator.hasNext())&#123;            System.out.println(iterator.next());        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>同样的Map类中也拥有Set的两种类，结构相似这里不再赘述</p><p>HashMap、TreeMap</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++ 类继承</title>
      <link href="2021/03/28/c-%E7%B1%BB%E7%BB%A7%E6%89%BF/"/>
      <url>2021/03/28/c-%E7%B1%BB%E7%BB%A7%E6%89%BF/</url>
      
        <content type="html"><![CDATA[<h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><br/><p>List是连续的容器，而vector是非连续的容器，即list将元素存储在连续的存储器中，而vector存储在不连续的存储器中</p><p>正是因为vector不是连续的。所以它在插入和删除时，需要大量时间移动元素</p><p>List支持双向，并为插入和删除操作提供了一种有效的方法。在列表中遍历速度很慢，因为列表元素是按顺序访问的，而vector支持随机访问</p><br/><h3 id="基类"><a href="#基类" class="headerlink" title="基类"></a>基类</h3><br/><p>从一个类派生出另一个类时，原始类称为基类，继承类称为派生类</p><p>在初始化构造函数时，除了一般的赋值方法，还可以直接采用基本的列表赋值</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;class TableTennis&#123;    private:        string firstname;        string lastname;        bool hastable;        public:        TableTennis(const string &amp; fn &#x3D; &quot;none&quot;, const string &amp; ln &#x3D; &quot;none&quot;, bool ht &#x3D; false);&#125;;TableTennis :: TableTennis(const string &amp; fn, const string &amp; ln, bool ht) : firstname(fn), lastname(ln), hastable(ht)&#123;&#125;&#x2F;&#x2F;这两种写法一样&#x2F;&#x2F; TableTennis :: TableTennis(const string &amp; fn, const string &amp; ln, bool ht)&#123;&#x2F;&#x2F;     firstname &#x3D; fn;&#x2F;&#x2F;     lastname &#x3D; ln;&#x2F;&#x2F;     hastable &#x3D; ht;&#x2F;&#x2F; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>在c++中，派生（继承）一个类使用<code>：</code>其余和Java大差不差</p><p>有关派生类构造函数的要点如下</p><blockquote><p>创建基类对象</p><p><strong>派生类构造函数应通过成员初始化列表将基类信息传递给基类构造函数</strong></p><p>派生类构造函数应初始化派生类新增的数据成员</p></blockquote><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;iostream&gt;#include&lt;string&gt;#include &quot;TableTennis.h&quot;using namespace std;class TableTennisVip : TableTennis&#123;    private:        int rate;    public:        TableTennisVip(const string &amp; fn &#x3D; &quot;none&quot;, const string &amp; ln &#x3D; &quot;none&quot;, bool ht &#x3D; false, int r &#x3D;0);        int Rating() const;&#125;;TableTennisVip :: TableTennisVip(const string &amp; fn, const string &amp; ln, bool ht, int r) : TableTennis(fn, ln, ht)&#123;&#x2F;&#x2F;通过使用列表，来将值传入到基类中    rate &#x3D; r;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>如果不使用列表操作，就会默认为基类的默认值值</p><p>和直接使用TableTennis()是一样的</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">TableTennisVip :: TableTennisVip(const string &amp; fn, const string &amp; ln, bool ht, int r) : TableTennis()TableTennisVip :: TableTennisVip(const string &amp; fn, const string &amp; ln, bool ht, int r)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><br/><p>创建派生类的对象，程序首先会调用基类构造函数，然后再调用派生类构造函数</p><p>派生类过期时，程序会先调用派生类的析构函数，然后再使用基类的</p><p>基类的指针和引用可以不用显式转化的直接指向派生类的对象或者引用派生类的对象（不可以将基类对象和地址赋值给派生类）</p><br/><h3 id="题外话-格式化输出"><a href="#题外话-格式化输出" class="headerlink" title="题外话-格式化输出"></a>题外话-格式化输出</h3><br/><p>在之后的内容中会有详细的描述格式化输出问题，南邮的acm题目中也有对应的东西</p><p>c++ 使用 <code>cout.setf(ios_base::fixed, ios_base::floatfield)</code> 进行格式化输出</p><p><code>ios_base::fixed</code>表示：用正常的记数方法显示浮点数(与科学计数法相对应)；<code>ios_base::floatfield</code>表示小数点后保留6位小数</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">fmtflags setf(fmtflage) &#x2F;&#x2F;第一原型fmtflags setf(fmtflags, fmtflags)  &#x2F;&#x2F;第二原型&#x2F;&#x2F;fmtflags 是 bitmask 类型(一种用来存储各个位值的类型)的 typedef 名<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><br/><table><thead><tr><th align="center">标志</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">boolalpha</td><td align="center">可以使用单词”true”和”false”进行输入/输出的布尔值</td></tr><tr><td align="center">oct</td><td align="center">用八进制格式显示数值</td></tr><tr><td align="center">dec</td><td align="center">用十进制格式显示数值</td></tr><tr><td align="center">hex</td><td align="center">用十六进制格式显示数值</td></tr><tr><td align="center">left</td><td align="center">输出调整为左对齐</td></tr><tr><td align="center">right</td><td align="center">输出调整为右对齐</td></tr><tr><td align="center">scientific</td><td align="center">用科学记数法显示浮点数</td></tr><tr><td align="center">fixed</td><td align="center">用正常的记数方法显示浮点数(与科学计数法相对应)</td></tr><tr><td align="center">showbase</td><td align="center">输出时显示所有数值的基数</td></tr><tr><td align="center">showpoint</td><td align="center">显示小数点和额外的零，即使不需要</td></tr><tr><td align="center">showpos</td><td align="center">在非负数值前面显示”＋（正号）”</td></tr><tr><td align="center">skipws</td><td align="center">当从一个流进行读取时，跳过空白字符(spaces, tabs, newlines)</td></tr><tr><td align="center">unitbuf</td><td align="center">在每次插入以后，清空缓冲区</td></tr><tr><td align="center">internal</td><td align="center">将填充字符回到符号和数值之间</td></tr><tr><td align="center">uppercase</td><td align="center">以大写的形式显示科学记数法中的”e”和十六进制格式的”x”</td></tr></tbody></table><br/><p>除此之外，你还可以进行指示符的关闭和开启操作</p><br/><table><thead><tr><th align="center"><strong>操作符</strong></th><th align="center"><strong>描述</strong></th></tr></thead><tbody><tr><td align="center">resetiosflags(long f)</td><td align="center">关闭被指定为f的标志</td></tr><tr><td align="center">setiosflags(long f)</td><td align="center">启用指定为f的标志</td></tr></tbody></table><br/><p>第一原型比较简单且容易理解，可以直接设置cout的输出方式</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F; 形式一：&#x2F;&#x2F; cout &lt;&lt; showpos &lt;&lt; 255 &lt;&lt; endl;&#x2F;&#x2F; 形式二：&#x2F;&#x2F; showpos(cout);&#x2F;&#x2F; cout &lt;&lt; 255 &lt;&lt; endl;&#x2F;&#x2F; 形式三：cout.setf(ios_base::showpos);cout &lt;&lt; 255 &lt;&lt; endl;&#x2F;&#x2F;输出: +255<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">cout &lt;&lt; setiosflags(ios_base::scientific) &lt;&lt; 255.255 &lt;&lt; endl;&#x2F;&#x2F;输出： 2.55255e+02cout &lt;&lt; setiosflags(ios_base::scientific); &#x2F;&#x2F;启用scientific标志cout &lt;&lt; resetiosflags(ios_base::scientific); &#x2F;&#x2F;关闭scientific标志cout &lt;&lt; setprecision(4) &lt;&lt; 255.255 &lt;&lt; endl; &#x2F;&#x2F;设置输出数值的精度为4位&#x2F;&#x2F;输出： 255.3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>第二原型看似很麻烦，但是只需要记住模板就好，调试时，也会更加方便</p><br/><table><thead><tr><th align="center"><strong>第二个参数</strong></th><th align="center"><strong>第一个参数</strong></th><th align="center"><strong>含义</strong></th></tr></thead><tbody><tr><td align="center">ios_base::basefield</td><td align="center">ios_base::dec</td><td align="center">使用10进制</td></tr><tr><td align="center"></td><td align="center">ios_base::oct</td><td align="center">使用8进制</td></tr><tr><td align="center"></td><td align="center">ios_base::hex</td><td align="center">使用16进制</td></tr><tr><td align="center">ios_base::floatfield</td><td align="center">ios_base::fixed</td><td align="center">使用定点计数法(即一般计数法)</td></tr><tr><td align="center"></td><td align="center">ios_base::scientific</td><td align="center">使用科学计数法</td></tr><tr><td align="center">ios_base::adjustfield</td><td align="center">ios_base::left</td><td align="center">左对齐</td></tr><tr><td align="center"></td><td align="center">ios_base::right</td><td align="center">右对齐</td></tr><tr><td align="center"></td><td align="center">ios_base::internal</td><td align="center">符合或前缀左对齐，值右对齐</td></tr></tbody></table><br/><p>可以使用这种标识符进行定点输出，比如输出小数并且默认位数为小数点后两位</p><br/><h3 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h3><br/><p>虚函数很像Java中的抽象类的概念，在c++中，为基类创建一个虚析构函数是一种惯例</p><p>在类的继承中，原则之一（其实在其他程序里也是一样的），就是不要使用多余的程序，如果是在派生类中重新定义的方法，需要使用虚方法，否则就不需要使用</p><blockquote><p>在基类方法的声明中使用virtual可以这个方法在基类和派生类中都是虚方法</p><p>如果使用指向对象的指针或引用来调用虚方法，程序将使用为对象类型定义的方法，称为动态联编，这样基类指针或引用可以指向派生类对象</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int x &#x3D; 2.5;double * a &#x3D; &amp;x;&#x2F;&#x2F;这是不允许的，c++中不允许将不同类型的数值赋给另一个类型的指针long b &#x3D; &amp;x;&#x2F;&#x2F;同理，引用也不可以&#x2F;&#x2F;在类的继承中，派生类的引用和指针就可以直接被基类赋值Father x(&quot;cxy&quot;, 18);Son * a &#x3D; &amp;x;Son b &#x3D; &amp;x;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>在定义基类中，那些要被派生类使用的方法要使用虚方法</p></blockquote><br/><h3 id="使用虚函数的场景"><a href="#使用虚函数的场景" class="headerlink" title="使用虚函数的场景"></a>使用虚函数的场景</h3><br/><blockquote><p>构造函数：构造函数不能是虚函数，派生类的构造函数将使用基类的一个构造函数，这种顺序不同于继承机制，所以派生类不继承基类的构造函数</p><p>析构函数：析构函数一定要使用虚函数，在派生类过期时，一定要调用本类的析构函数</p><p>友元：友元不能是虚函数，友元不是类成员，只有成员才能使虚函数</p></blockquote><br/><h3 id="访问控制-protected"><a href="#访问控制-protected" class="headerlink" title="访问控制-protected"></a>访问控制-protected</h3><br/><p>private和protected的区别就在于基类的派生类，派生类的成员是可以直接访问基类保护成员的，但是不能访问私有成员</p><p>对于内部来说，保护类似于公有；对于外部来说，保护类似私有</p><p>不过，在一般情况下，我们都是采用私有访问，同时通过基类方法更改基类数据</p><br/><h3 id="抽象基类"><a href="#抽象基类" class="headerlink" title="抽象基类"></a>抽象基类</h3><br/><p>在使用基类和派生类的时候，很多时候会存在细节上的不同，比如基类的方法或者数据派生类用不到</p><p>这个时候单独创建一个类又十分麻烦，在这种情况下我们使用纯虚函数</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">virtual double Area() const &#x3D; 0;&#x2F;&#x2F;这就是一个纯虚函数void Move(int nx, int ny) &#x3D; 0;&#x2F;&#x2F;使用&#x3D;0来创建纯虚函数void BaseEllipse(int nx,int ny)&#123;&#x2F;&#x2F;仍然可以对其进行定义        x &#x3D; nx;    y &#x3D; ny;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker学习</title>
      <link href="2021/03/28/Docker%E5%AD%A6%E4%B9%A0/"/>
      <url>2021/03/28/Docker%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>有人说，docker的出现就像集装箱一样，所谓的穿着马甲的“标准化”</p><p>想要搞懂docker，需要明白它的两句口号</p><p>1.<strong>Build, Ship and Run</strong>，搭建、发送、运行三板斧</p><p>2.<strong>Build once，Run anywhere</strong>，只要搭建一次，什么情况下都能够使用</p><p>docker技术的核心概念分别是</p><blockquote><p>镜像（Image）别人存放好文档的地方</p><p>容器（Container）实现具体操作程序的地方</p><p>仓库（Repository） 自己本地下载别人的镜像</p></blockquote><p>就以运维中举例，我们可能会看到多种语言写出来的各种各样的东西，并且可能还有历史遗留的不同版本导致的错误</p><p>这个时候，标准化管理显得尤其重要，这个时候就需要一个统一的操作方法。就算你只用php写程序，php的版本不同，加上sql的不同，使用容器的不同，nginx或者apache，甚至有不知名的web容器，还有自己写的web容器</p><br/><h3 id="docker运行helloworld"><a href="#docker运行helloworld" class="headerlink" title="docker运行helloworld"></a>docker运行helloworld</h3><br/><p>docker指令的运行需要管理员root身份</p><p>Docker 允许你在容器内运行应用程序， 使用 <strong>docker run</strong> 命令来在容器内运行一个应用程序</p><br/><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">runoob@runoob:~$ docker run ubuntu:15.10 &#x2F;bin&#x2F;echo &quot;Hello world&quot;Hello world# 存在镜像之后，就不需要指定版本了runoob@runoob:~$ docker run ubuntu &#x2F;bin&#x2F;echo &quot;Hello world&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><blockquote><p>docker: Docker 的二进制执行文件</p><p>run: 与前面的 docker 组合来运行一个容器</p><p>ubuntu:15.10 指定要运行的镜像，Docker 首先从本地主机上查找镜像是否存在，如果不存在，Docker 就会从镜像仓库 Docker Hub 下载公共镜像</p><p>/bin/echo “Hello world”: 在启动的容器里执行的命令</p></blockquote><br/><h4 id="进行交互式的容器"><a href="#进行交互式的容器" class="headerlink" title="进行交互式的容器"></a>进行交互式的容器</h4><br/><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">runoob@runoob:~$ docker run -i -t ubuntu:15.10 &#x2F;bin&#x2F;bashroot@0123ce188bd8:&#x2F;#<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><br/><blockquote><p>-t: 在新容器内指定一个伪终端或终端</p><p>-i: 允许你对容器内的标准输入 (STDIN) 进行交互</p></blockquote><p>此时我们已经进入了ubuntu:15.10系统的容器中，可以通过查询版本的指令来查看</p><br/><h4 id="启动容器（后台）"><a href="#启动容器（后台）" class="headerlink" title="启动容器（后台）"></a>启动容器（后台）</h4><br/><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">runoob@runoob:~$ docker run -d ubuntu:15.10 &#x2F;bin&#x2F;sh -c &quot;while true; do echo hello world; sleep 1; done&quot;2b1b7a428627c51ab8810d541d759f072b4fc75487eed05812646b8534a2fe63<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><br/><p>这是容器在后台运行，这时我们可以通过docker ps来查询容器的运行情况</p><p>后台运行的容器都会有一个独一无二的id，在下面的操作都是使用这个id进行的</p><br/><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">runoob@runoob:~$ docker logs 2b1b7a428627 #查看容器内的标准输入输出runoob@runoob:~$ docker stops 2b1b7a428627 #暂停容器的运行<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><br/><h3 id="docker容器的使用"><a href="#docker容器的使用" class="headerlink" title="docker容器的使用"></a>docker容器的使用</h3><br/><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">runoob@runoob:~# docker# 可以使用这个指令，查看所有的docker指令runoob@runoob:~# docker command --help# 查询特定指令的提示<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><br/><p>虽然是纯英文的，但是用来训练六级水平也不错（</p><p>咳咳，这是可以让你快速查询这些命令的意思的，毕竟没有人一上来就能熟练掌握这些东西</p><br/><h4 id="拉取镜像，启动容器"><a href="#拉取镜像，启动容器" class="headerlink" title="拉取镜像，启动容器"></a>拉取镜像，启动容器</h4><br/><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ docker pull ubuntu # 拉取ubuntu镜像$ docker run -it ubuntu &#x2F;bin&#x2F;bash # 启动交互式容器 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><br/><p>在进入交互式容器的时候，也会显示其独一无二的id，在退出时，这个容器也会对应关闭</p><p>这是可以使用docker statrt指令来在幕后运行的</p><p>当然，你也可以加入-d来使对应的docker容器在后台操作</p><br/><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">root@VM-0-3-ubuntu:&#x2F;# docker start f994a769ac63# 可以随时停止并重启容器$ docker stop &lt;容器 ID&gt;$ docker restart &lt;容器 ID&gt;$ docker attach 1e560fca3906 # 在容器进入后台之后，可以使用这个指令进入容器$ docker exec -it 243c32535da7 &#x2F;bin&#x2F;bash #这个方式也可以进入容器# 两者区别就是，前者退出时会停止容器，后者则不会，具体可以通过help来查询<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><h4 id="导入导出容器"><a href="#导入导出容器" class="headerlink" title="导入导出容器"></a>导入导出容器</h4><br/><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ docker export 1e560fca3906 &gt; ubuntu.tar # 导出本地容器$ cat docker&#x2F;ubuntu.tar | docker import - test&#x2F;ubuntu:v1 # 将快照文件导入到镜像test&#x2F;unbuntu:v1中$ docker import http:&#x2F;&#x2F;example.com&#x2F;exampleimage.tgz example&#x2F;imagerepo # 导出入到URL也未尝不可$ docker rm -f 1e560fca3906 # 删除终止的容器 -f输出容器内部的标准输出$ docker container prune # 清除所有终止状态的容器<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><h4 id="web应用"><a href="#web应用" class="headerlink" title="web应用"></a>web应用</h4><br/><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">runoob@runoob:~# docker run -d -P training&#x2F;webapp python app.py # -P将容器中的网络端口随机映射我们的主机上，即对应的服务器iprunoob@runoob:~$ docker run -d -p 5000:5000 training&#x2F;webapp python app.py # 也可以设置不同的端口参数runoob@runoob:~$ docker port &#123;containerid&#125; # 查看容器端口的映射情况runoob@runoob:~$ docker top wizardly_chandrasekhar # 使用 docker top 查看内部运行情况runoob@runoob:~$ docker inspect wizardly_chandrasekhar # 使用inspect查看底层信息# 这个会返回记录容器配置和状态的json信息<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><h3 id="docker镜像的使用"><a href="#docker镜像的使用" class="headerlink" title="docker镜像的使用"></a>docker镜像的使用</h3><br/>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 快速上手</title>
      <link href="2021/03/26/Python-%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/"/>
      <url>2021/03/26/Python-%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h3><br/><p>在python这里，你就可以尝试文本编程和命令行编程了（x</p><p>你可以直接在python官网安装python，然后在命令行使用指令（也可用自带的IDLE，用shell写代码）</p><br/><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">python #输入该指令进入python界面print(&quot;Hello World&quot;) #直接输入对应指令运行，适用于比较短的代码python D:\CXY\EXE\练习\学习\python\HellloWorld类练习\hello.py #可以调用已经写好的程序<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><br/><p>当然，这个东西肯定不方便，毕竟这样生产效率很低，这是就可以用第三方集成式开发工具</p><p>这里推荐使用pycharm，由JetBrains公司开发的工具（和Java的idea是同一个公司）</p><p>然后还有就是vs系列，虽然最早是作为c++开发的工具平台，但是可以直接使用辅助插件扩展功能（vs极其不方便）。如果不想换编译器，可以直接vscode装扩展完事（x</p><p>不过vscode这种集成式开发确实很方便，但终归还是不及专业的第三方软件，毕竟他们是对单个语言进行编译，追求效率肯定不会选择使用vscode，况且真正的大佬都是直接txt编程</p><br/><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><br/><p>根据黄老板的简单叙述，其他的语言语法判定因为有了括号，所以编译器可以清楚地认识到编译的次序</p><p>而python中，为了语法的方便，取消了括号，也就对缩进进行了严格的规定</p><br/><h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><br/><blockquote><p>单行注释 #</p><p>多行注释 “ “</p><p>中文注释 在python3.x中，已经支持使用中文</p><p>为了让别人知道你的代码用的是什么格式，需要加上中文注释，一共两种写法</p><p>1.<code>#-*-conding:编码-*-</code></p><p>2.<code>#coding=编码</code></p></blockquote><br/><h4 id="缩进"><a href="#缩进" class="headerlink" title="缩进"></a>缩进</h4><br/><p>其他语言的时候，只有需要使用单语句时才可以省略括号</p><p>而python实现通过缩进判断是否从属于这个语句，所以一定要注意书写规范</p><br/><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><br/><p>python的语法格式是我见过的最可以随心所欲的</p><p>在php中本身就可以使用比较特殊的变量名了，而在python你甚至可以使用中文符号作为变量</p><br/><pre class="line-numbers language-python" data-language="python"><code class="language-python">我直接好家伙&#x3D;1.75# 这个语句是合法的<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><br/><p>所以在python中，变量更像是“名称”，也可以按照以前的变量规则进行定义</p><p>慎用小写字母1&amp;大写字母O</p><blockquote><p>type() 用来返回变量的类型</p><p>id() 获取变量的地址</p></blockquote><br/><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><br/><p>在这里，只讲一些python特有的语法特征</p><blockquote><p>八进制 python3.x中的八进制必须以”0o”|”0O”开头</p><p>这和python2.x不同，老版本还是像c一样，使用0开头标志八进制数</p><p>字符串 在python中的字符串是可以使用” “|’ ‘的（这点倒有点像php），只需要保证前后引号类型相等</p><p>数据类型转换 python提供了格式各样的数据类型转换函数，这里挑几个不常见的列举出来</p></blockquote><br/><table><thead><tr><th align="center">函数</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">str(x)</td><td align="center">将x转换为字符串类型</td></tr><tr><td align="center">repr(x)</td><td align="center">将x转化为表达式字符串（此时的输出结果是对应的字符串的表达式）</td></tr><tr><td align="center">eval(str)</td><td align="center">计算在字符串中的有效python表达式，并返回一个对象</td></tr><tr><td align="center">ord(x)</td><td align="center">将字符x转换为对应的整形</td></tr><tr><td align="center">hex(x)</td><td align="center">整数x转换为十六进制的字符串</td></tr><tr><td align="center">oct(x)</td><td align="center">将一个整形x转换为八进制字符串</td></tr></tbody></table><br/><h4 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h4><br/><p>python使用input()进行输入操作</p><p>最方便的是，这个里面可以直接输入提示文字（到这里应该能大致理解python为什么这么吃内存了）</p><br/><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><br/><table><thead><tr><th align="center">运算符</th><th align="center">说明</th><th align="center">实例</th><th align="center">结果</th></tr></thead><tbody><tr><td align="center">/</td><td align="center">除（和其他语言不同，不管是什么类型，都会返回小数）</td><td align="center">7/2</td><td align="center">3.5</td></tr><tr><td align="center">//</td><td align="center">取整数，即其他语言”/“的用法</td><td align="center">7//2</td><td align="center">3</td></tr><tr><td align="center">**</td><td align="center">求幂</td><td align="center">2**4</td><td align="center">16</td></tr></tbody></table><br/><p>在python中，甚至直接放弃了原本的逻辑运算符，使用更加简单易懂的符号形式</p><blockquote><p>and 逻辑与</p><p>or 逻辑或</p><p>not 逻辑非</p></blockquote><br/><h3 id="流程控制语句"><a href="#流程控制语句" class="headerlink" title="流程控制语句"></a>流程控制语句</h3><br/><h4 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h4><br/><p>python虽然省略了括号这样的判断指示，但是在if判断语句中仍然要使用”:”作为分辨的依据</p><p>（不过，如果不考虑可读性的话，可以直接简写（x）</p><p>并且，在指定变量时还是要规定一下类型，不然编译器会默认为string类型</p><br/><pre class="line-numbers language-python" data-language="python"><code class="language-python">height &#x3D; float(input(&quot;输入你的身高&quot;))if height &lt; 1.7:    print(&quot;你这不行啊（x&quot;)else:    print(&quot;好家伙&quot;)# 在某种情况下可以进行这种简写 height &#x3D; float(input(&quot;输入你的身高&quot;))b &#x3D; height if height &gt; 2 else -heightprint(b)# python中专门设置了elif 来代替else if。这可以理解，毕竟如果是两个判断叠加一起，处理太过于麻烦if : coding1elif:    coding2else:coding3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><h4 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h4><br/><p>python的for循环应该是最具有特色的语法了</p><p>语法结构为<code>for in</code>可以根据需求，对不同的方向进行循环</p><br/><h5 id="对数值进行循环"><a href="#对数值进行循环" class="headerlink" title="对数值进行循环"></a>对数值进行循环</h5><br/><p>使用<code>for i in range(start, end, step)</code></p><blockquote><p>start 设定初始值，可以忽略，如果忽略就是从零开始</p><p>end 设定结束值，不能忽略，如果range只存在一个参数，那就默认为end（注意如果你设定了100，i只会到99）</p><p>step 设定步长，即两个数之间的间隔，可以忽略</p></blockquote><br/><h5 id="对字符串进行循环"><a href="#对字符串进行循环" class="headerlink" title="对字符串进行循环"></a>对字符串进行循环</h5><br/><pre class="line-numbers language-python" data-language="python"><code class="language-python">string &#x3D; &quot;我是傻逼&quot;print(string) # 横向输出for i in string:    print(i) # 纵向输出<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><br/><h5 id="end-的使用"><a href="#end-的使用" class="headerlink" title="end =的使用"></a>end =的使用</h5><br/><pre class="line-numbers language-python" data-language="python"><code class="language-python">for i in range(1, 10):    for j in range(1, i + 1):        print(str(i) + &quot;X&quot; + str(j) + &quot;&#x3D;&quot; + str(i * j) + &quot;\t&quot;, end &#x3D; &#39;&#39;)         #print默认是打印一行，结尾加换行。end&#x3D;&#39; &#39;意思是末尾不换行，加空格    print(&#39;&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><h5 id="pass"><a href="#pass" class="headerlink" title="pass"></a>pass</h5><br/><p>pass表示一个空语句，不做任何事情，一般是占位作用</p><br/><h3 id="序列概述"><a href="#序列概述" class="headerlink" title="序列概述"></a>序列概述</h3><br/><h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><br/><p>在python中，在数组中的键名可以使用负数，表示倒数第几个</p><br/><pre class="line-numbers language-python" data-language="python"><code class="language-python">a &#x3D; [&quot;我是傻逼&quot;, &quot;常陆茉子是我老婆&quot;]print(a[-1])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><br/><h4 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h4><br/><p>可以访问序列元素，并且将指定的一部分分离出来</p><p>语法为<code>sname[start : end : step]</code></p><blockquote><p>sname 序列的名称</p><p>start 切片开始的位置，如果不做指定，默认为0</p><p>end 切片的截至位置，如果不指定，则会默认为序列长度</p><p>step 切片的步长，可以省略，:也要去除</p></blockquote><br/><pre class="line-numbers language-python" data-language="python"><code class="language-python">a &#x3D; [&quot;我是傻逼&quot;, &quot;常陆茉子是我老婆&quot;, &quot;我太拉了&quot;, ]print(a)print(a[1 : 3]) # 获取第二个&amp;第三个元素print(a[:]) # 如果想要复制完整的，其余的什么都不需要写，但是:还是要补上<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><br/><h4 id="序列操作"><a href="#序列操作" class="headerlink" title="序列操作"></a>序列操作</h4><br/><p>如同其他语言一样可以使用序列相加，但是你知道python实现了序列想成吗？</p><p>这个算法的实质是让序列扩张几倍，如同复制粘贴一样</p><p>以下是一些其他函数，十分的实用，解决了以往的函数需要多行代码才能判断的事情</p><br/><pre class="line-numbers language-python" data-language="python"><code class="language-python">b &#x3D; [1, 2, 3, 4, 5]print(1 in b) # 判断1是否存在b当中print(1 not in b) # 同时提供了一个相反的概念，判断是否不在序列里面print(len(b), max(b), min(b)) #返回序列的长度、最大值、最小值# 这里提醒一个细节的点print(len(b) + &quot; &quot; + max(b) + &quot; &quot; + min(b))# 此时编译器是会报错的，因为这样写里面的值会默认为string类型# 实在不行，可以写成以下形式print(len(b), &quot; &quot;, max(b), &quot; &quot;, min(b))# 不过其实没有必要，因为python输出时会自动添加空格<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><table><thead><tr><th align="center">函数</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">list()</td><td align="center">将序列转换为列表</td></tr><tr><td align="center">str()</td><td align="center">将序列转化为字符串</td></tr><tr><td align="center">sum()</td><td align="center">计算元素和</td></tr><tr><td align="center">sorted()</td><td align="center">对元素进行排序</td></tr><tr><td align="center">reversed()</td><td align="center">反序序列中的元素</td></tr><tr><td align="center">enumerate()</td><td align="center">将序列组合为一个索引序列，多用在for循环中</td></tr></tbody></table><br/><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><br/><pre class="line-numbers language-python" data-language="python"><code class="language-python"># 可以通过直接赋值的方式定义列表a &#x3D; [20, 50, 80]# 创建空列表EmptyList &#x3D; []# 通过range函数并且使用list转化为序列直接输出print(list(range(10, 20, 2)))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/> ]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>将hexo部署到Ubuntu服务器上</title>
      <link href="2021/03/25/%E5%B0%86hexo%E9%83%A8%E7%BD%B2%E5%88%B0Ubuntu%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A/"/>
      <url>2021/03/25/%E5%B0%86hexo%E9%83%A8%E7%BD%B2%E5%88%B0Ubuntu%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A/</url>
      
        <content type="html"><![CDATA[<p>对于刚刚搭建服务器，缺少经验或者觉得下面的文章过于简略，可以看<a href="https://mistill.com/posts/hexo-lay-tencent-cvm/#%E6%9C%AC%E5%9C%B0%E5%AE%89%E8%A3%85Hexo-node-js-git">这个博客</a></p><p>如果服务器中已经设置了基本的LNMP，请看<a href="https://mistill.com/posts/hexo-lay-tencent-cvm/#%E6%9C%AC%E5%9C%B0%E5%AE%89%E8%A3%85Hexo-node-js-git">这个文章</a></p><p>博主在第一篇文章中看了差不多不少的东西，解释的也比较详细，但是还是有些细节并没有解释到位</p><p>而自己又搭建了LNMP，所以显示的是lnmp搭建成功的网站，可能考虑会使用这个搭建新的wordpress博客（x</p><h3 id="服务器操作"><a href="#服务器操作" class="headerlink" title="服务器操作"></a>服务器操作</h3><br/><h4 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h4><br/><p>首先，在 服务器 上安装 Git 和 nginx</p><br/><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">apt-get update -yapt-get install git-core nginx -y<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><br/><h4 id="配置用户"><a href="#配置用户" class="headerlink" title="配置用户"></a>配置用户</h4><br/><p>然后新增一个名为 <code>git</code> 的用户，过程中需要设置登录密码，先输入两次密码，然后按几次回车就可。<br><code>adduser git</code><br>给用户 <code>git</code> 赋予无需密码操作的权限（否则到后面 Hexo 部署的时候会提示无权限）</p><br/><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">chmod 740 &#x2F;etc&#x2F;sudoersvi &#x2F;etc&#x2F;sudoers<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><br/><p>在图示位置<code>root ALL=(ALL:ALL) ALL</code>的下方添加</p><br/><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">git ALL&#x3D;(ALL:ALL) ALL<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br/><p>然后保存。然后更改读写权限</p><br/><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">chmod 440 &#x2F;etc&#x2F;sudoers<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br/><h4 id="上传-SSH-公钥"><a href="#上传-SSH-公钥" class="headerlink" title="上传 SSH 公钥"></a>上传 SSH 公钥</h4><br/><p>接下来要把本地的 ssh 公钥上传到 服务器 。执行</p><br/><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">su gitcd ~mkdir .ssh &amp;&amp; cd .sshtouch authorized_keysvi authorized_keys<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>现在要打开本地的 <code>Git Bash</code>，输入<code>vi ~/.ssh/id_rsa.pub</code>，把里面的内容复制下来粘贴到上面打开的文件里。<br>然后建立放部署的网页的 Git 库</p><br/><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cd ~mkdir hexo.git &amp;&amp; cd hexo.gitgit init --bare<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><br/><p>测试一下，如果在 Git Bash 中输入 <code>ssh git@服务器的IP地址</code> 能够远程登录的话，则表示设置成功了<br>如果不成功，并且你的 服务器 的 ssh 端口不是 <code>22</code> 的话，请在<code>Git Bash</code>执行<code>vi ~/.ssh/config</code>，输入以下内容并保存：（成功就跳过这一步）</p><br/><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Host #服务器 的 IPHostName #服务器 的 IPUser gitPort #SSH 端口IdentityFile ~&#x2F;.ssh&#x2F;id_rsa<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>ps: 如果配置完成还是提示要输入密码，可以使用 <code>ssh-copy-id</code>，在本地打开 Git Bash 输入：</p><br/><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ssh-copy-id -i ~&#x2F;.ssh&#x2F;id_rsa.pub git@服务器ip地址<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br/><p>这个密码忽略指的是服务器中git的所需的密码，所以在使用<code>hexo d</code>指令的时候，你依然需要输入服务器的密码（这未必不是一件好事，因为我本人总喜欢没事<code>hexo g</code> <code>hexo d</code>，这其实不能算是一个好习惯）</p><br/><h4 id="用户授权"><a href="#用户授权" class="headerlink" title="用户授权"></a>用户授权</h4><br/><p>接下来要给用户 git 授予操作 nginx 放网页的地方的权限：</p><br/><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sucd &#x2F;var&#x2F;www #创建博客存放的地址mkdir hexochown git:git -R &#x2F;var&#x2F;www&#x2F;hexo <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><br/><h4 id="配置钩子"><a href="#配置钩子" class="headerlink" title="配置钩子"></a>配置钩子</h4><br/><p>现在就要向 Git Hooks 操作，配置好钩子：</p><br/><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">su gitcd &#x2F;home&#x2F;git&#x2F;hexo.git&#x2F;hooksvi post-receive<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><br/><p>输入内容并保存：（里面的路径看着换吧，上面的命令没改的话也不用换）</p><br/><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#!&#x2F;bin&#x2F;bashGIT_REPO&#x3D;&#x2F;home&#x2F;git&#x2F;hexo.gitTMP_GIT_CLONE&#x3D;&#x2F;tmp&#x2F;hexoPUBLIC_WWW&#x3D;&#x2F;var&#x2F;www&#x2F;hexorm -rf $&#123;TMP_GIT_CLONE&#125;git clone $GIT_REPO $TMP_GIT_CLONErm -rf $&#123;PUBLIC_WWW&#125;&#x2F;*cp -rf $&#123;TMP_GIT_CLONE&#125;&#x2F;* $&#123;PUBLIC_WWW&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>赋予可执行权限：</p><br/><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">chmod +x post-receive<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br/><h4 id="配置-nginx"><a href="#配置-nginx" class="headerlink" title="配置 nginx"></a>配置 nginx</h4><br/><p>然后是配置 nginx。执行</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">suvi &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;hexo.confserver &#123;  listen  80 ;  listen [::]:80;  root &#x2F;var&#x2F;www&#x2F;hexo;  server_name bore.vip www.bore.vip;  access_log  &#x2F;var&#x2F;log&#x2F;nginx&#x2F;hexo_access.log;  error_log   &#x2F;var&#x2F;log&#x2F;nginx&#x2F;hexo_error.log;  error_page 404 &#x3D;  &#x2F;404.html;  location ~* ^.+\.(ico|gif|jpg|jpeg|png)$ &#123;    root &#x2F;var&#x2F;www&#x2F;hexo;    access_log   off;    expires      1d;  &#125;  location ~* ^.+\.(css|js|txt|xml|swf|wav)$ &#123;    root &#x2F;var&#x2F;www&#x2F;hexo;    access_log   off;    expires      10m;  &#125;  location &#x2F; &#123;    root &#x2F;var&#x2F;www&#x2F;hexo;    if (-f $request_filename) &#123;    rewrite ^&#x2F;(.*)$  &#x2F;$1 break;    &#125;  &#125;  location &#x2F;nginx_status &#123;    stub_status on;    access_log off; &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因为放中文进去会乱码所以就不在里面注释了。代码里面配置了默认的根目录，绑定了域名，并且自定义了 404 页面的路径<br>最后就重启 nginx 服务器：</p><br/><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&#x2F;etc&#x2F;init.d&#x2F;nginx restart<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br/><p>ps: 最好做一个301跳转，把bore.vip和<code>www.bore.vip</code>合并，并把之前的域名也一并合并. 有两种实现方法,第一种方法是判断nginx核心变量host(老版本是http_host)：</p><br/><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">server &#123;server_name bore.vip www.bore.vip ;if ($host !&#x3D; &#39;bore.vip&#39; ) &#123;rewrite ^&#x2F;(.*)$ http:&#x2F;&#x2F;bore.vip&#x2F;$1 permanent;&#125;...&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><h3 id="通过-Git-部署"><a href="#通过-Git-部署" class="headerlink" title="通过 Git 部署"></a>通过 Git 部署</h3><br/><p>先在任意位置处打开 powershell, 从服务器上把 <code>hexo_static</code> 仓库克隆下来，以此来将服务器地址添加到受信任的站点中</p><p>（注意，这里是第二个网站的教程，）</p><br/><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">SHELLgit clone ubuntu@server_ip:&#x2F;var&#x2F;repo&#x2F;hexo_static.git<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><br/><p>注意在第一次进行这一步时会提示是否继续，选 yes 即可</p><p>在登录博客的url设置中，如果没有域名，可以直接只用服务器公网ip，如果已经购买域名，建议使用（如果购买了域名却无法使用，）</p><p>再编辑 Hexo 的 <code>config.yml</code> 文件，找到 Deployment, 修改为</p><br/><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml">YMLdeploy:  type: git   repo: ubuntu@server_ip:&#x2F;var&#x2F;repo&#x2F;hexo_static.git  branch: master<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后记得安装 Hexo 部署到 Git 仓库的包</p><br/><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">SHELLnpm install hexo-deployer-git --save<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><br/><p>于是就可用 <code>hexo d</code> 命令来部署了</p><br/><h3 id="这里能帮你解决一部分问题"><a href="#这里能帮你解决一部分问题" class="headerlink" title="这里能帮你解决一部分问题"></a>这里能帮你解决一部分问题</h3><br/><h4 id="安装nodejs问题"><a href="#安装nodejs问题" class="headerlink" title="安装nodejs问题"></a>安装nodejs问题</h4><br/><p>lnmp安装包中是不会包含nodejs的，而且两篇教程不会告诉你要安装nodejs</p><p><a href="https://blog.csdn.net/qq_40713537/article/details/89267375">参考网站</a></p><br/><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo apt-get install nodejssudo apt-get install npm #继续安装npm包管理工具sudo npm install npm -gnpm install express -g<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><br/><h4 id="安装npm报错"><a href="#安装npm报错" class="headerlink" title="安装npm报错"></a>安装npm报错</h4><br/><p>现象：Ubuntu 18.04安装npm 报错npm : Depends: node-gyp (&gt;= 0.10.9) but it is not going to be installed</p><p><img src="https://img-blog.csdnimg.cn/20190711133353211.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjM5NjYyMQ==,size_16,color_FFFFFF,t_70" alt="报错示例"></p><br/><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo apt remove --purge nodejs npmsudo apt cleansudo apt autocleansudo apt install -fsudo apt autoremovesudo apt install curlcurl -sL https:&#x2F;&#x2F;deb.nodesource.com&#x2F;setup_10.x | sudo -E bash -sudo apt-get install -y nodejscurl -sL https:&#x2F;&#x2F;dl.yarnpkg.com&#x2F;debian&#x2F;pubkey.gpg | sudo apt-key add -sudo apt-get update &amp;&amp; sudo apt-get install yarn<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#输入以下两段代码检验是否成功npm --versionnodejs -v<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><br/><h4 id="Linux挂起程序恢复"><a href="#Linux挂起程序恢复" class="headerlink" title="Linux挂起程序恢复"></a>Linux挂起程序恢复</h4><br/><p>进程的挂起及恢复</p><p>#ctrl+z:挂起，程序放到后台，程序没有结束</p><p>#jobs:查看被挂起的程序工作号</p><p>恢复进程执行时，有两种选择：fg命令将挂起的作业放回到前台执行；用bg命令将挂起的作业放到后台执行</p><p>格式：fg 工作号；bg 工作号</p><p>进程：正在执行的一个程序</p><p>程序：是一种写好的代码或脚本</p><p>&amp;:后台执行，不占用终端</p><p>如：xeyes &amp;</p><p>ps命令进程查看命令</p><p>ps命令：process status</p><p>-e 显示所有进程</p><p>-f 全格式</p><p>-h 不显示标题</p><p>-l 长格式</p><p>-w 宽输出</p><p>a 显示终端上的所有进程，包括其他用户的进程</p><p>r 只显示正在运行的进程</p><p>x 显示没有控制终端的进程</p><p>最常用三个参数是u、a、x</p><p>#ps axu的输出格式<br>USER：进程拥有者</p><p>PID：进程号</p><p>%CPU：占用的CPU使用率</p><p>%MEM：占用的内存使用率</p><p>VSZ；占用的虚拟内存大小</p><p>RSS：占用的内存大小</p><p>TTY：终端设备号</p><p>STAT：改进程状态</p><p>START：进程开始时间</p><p>TIME：执行的时间</p><p>COMMAND：所执行的指令</p><p>D:不可中断的休眠（通常表示该进程正在进行I/O动作）</p><p>R:正在执行中</p><p>S:休眠状态</p><p>T:暂停执行</p><p>W:没有足够的内存分页可分配</p><p>&lt;:高优先顺序的进程</p><p>N:低优先顺序的进程</p><p>L:有内存分页分配并锁在内存内（即时系统或定制I/O）</p><p>Kill:中断一个处理进程(process)</p><p>当中断一个前台进程是通常用ctrl+c；对于后台进程用kill命令</p><p>kill命令是通过向进程发送指定的信号来结束的。默认为TERM信号。TERM信号将终止所有不能捕获该信号的进程，对于能捕获该信号的进程需要使用kill –9信号，该信号是不能被捕获的</p><p>kill杀终端，只能可以把终端的shell杀死，而退出终端，但终端不关闭</p><p>pkill 命令名 可以直接杀死进程</p><p>pkill qmail //直接杀死qmail程序进程</p><br/><h4 id="git更新操作"><a href="#git更新操作" class="headerlink" title="git更新操作"></a>git更新操作</h4><br/><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo add-apt-repository ppa:git-core&#x2F;ppa #添加源sudo apt-get update #更新安装列表sudo apt-get install git #升级GIt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> git </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA Swing程序设计 p2</title>
      <link href="2021/03/23/JAVA-Swing%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-p2/"/>
      <url>2021/03/23/JAVA-Swing%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-p2/</url>
      
        <content type="html"><![CDATA[<h3 id="按钮组件"><a href="#按钮组件" class="headerlink" title="按钮组件"></a>按钮组件</h3><br/><p>学到这里，你已经发现了，这种窗体是一环套着一环的，先从小的基本属性入手，然后在将小的组件到窗体中</p><p>这样实现大化小，将编程的过程进行极大的简化</p><br/><h4 id="提交按钮"><a href="#提交按钮" class="headerlink" title="提交按钮"></a>提交按钮</h4><br/><p>由JButton对象表示</p><blockquote><p>public JButton()</p><p>public JButton(String text, Icon icon)</p></blockquote><blockquote><p>setIcon() 为按钮定制一个图标</p><p>setToolTipText() 为按钮设置提示文字</p><p>setBorderPainter(new Dimension()) 设置按钮边界是否显示，该方法需要参数类Dimension类对象</p><p>setMaximumSize() 设置按钮的大小与图标的大小一致</p><p>setEnabled() 设置按钮是否可用</p></blockquote><br/><h4 id="单选按钮组件"><a href="#单选按钮组件" class="headerlink" title="单选按钮组件"></a>单选按钮组件</h4><br/><blockquote><p>public JRadioButton()</p><p>public JRadioButton(String text, Icon icon, boolean selected) 最后一个就是显示是否默认选中</p></blockquote><p>如果窗体中的按钮比较多，一个个添加可能比较麻烦，这时候就可以使用按钮组</p><br/><pre class="line-numbers language-java" data-language="java"><code class="language-java">JRadioButton jr1 &#x3D; new JRadioButtion();JRadioButton jr2 &#x3D; new JRadioButtion();JRadioButton jr3 &#x3D; new JRadioButtion();ButtonGroup group &#x3D; new ButtonGroup();group.add(jr1);group.add(jr2);group.add(jr3);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><h4 id="复选框组件"><a href="#复选框组件" class="headerlink" title="复选框组件"></a>复选框组件</h4><br/><blockquote><p>public JCheckBox()</p><p>public JCheckBox(Icon icon, boolean checked)</p><p>public JCheckBox(String text, boolean checked)</p></blockquote><h3 id="列表组件"><a href="#列表组件" class="headerlink" title="列表组件"></a>列表组件</h3><br/><h4 id="下拉列表框组件"><a href="#下拉列表框组件" class="headerlink" title="下拉列表框组件"></a>下拉列表框组件</h4><br/><blockquote><p>public JComboBox()</p><p>public JComboBox(ComboBoxModel dataModel)</p><p>public JComboBox(Object[] arrayData)</p><p>public JComboBox(Vector vector)</p></blockquote><p>在初始化下拉表框时，可以选择同时指定下拉列表中的项目内容</p><br/><p>下拉列表框的项目封装为ComboBoxModel的情况比较多，可以在初始化对象时调用这个接口</p><p>调用接口的同时，必须实现以下两种方法</p><blockquote><p>public void setSelectedItem(Object item)</p><p>public Object getSelectedItem() 用于返回下拉列表种的选中项</p><p>getSize()</p><p>getElementAt(int index) 返回指定索引处的值</p></blockquote><br/><pre class="line-numbers language-java" data-language="java"><code class="language-java">import javax.swing.*;import java.awt.*;public class JComboBoxModelTest extends JFrame &#123;    JComboBox&lt;String&gt; jComboBox &#x3D; new JComboBox&lt;&gt;(new MyComboBox());&#x2F;&#x2F;应用了JDK7的新特性    JLabel jLabel &#x3D; new JLabel(&quot;请选择证件&quot;);    public JComboBoxModelTest()&#123;        Container container &#x3D; getContentPane();        setTitle(&quot;下拉列表组件&quot;);        container.setLayout(new FlowLayout());        container.add(jLabel);        container.add(jComboBox);        setVisible(true);        setSize(1000, 1000);        setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);    &#125;    public static void main(String[] args) &#123;        new JComboBoxModelTest();    &#125;&#125;class MyComboBox extends AbstractListModel&lt;String&gt; implements ComboBoxModel&lt;String&gt;&#123;    String selecteditem &#x3D; null;    String[] test &#x3D; &#123;&quot;身份证&quot;, &quot;军人证&quot;, &quot;学生证&quot;, &quot;工作证&quot;&#125;;    @Override    public String getElementAt(int index) &#123;&#x2F;&#x2F;根据索引值返回值        return test[index];    &#125;    @Override    public int getSize() &#123;        return test.length;    &#125;    @Override    public void setSelectedItem(Object item) &#123;&#x2F;&#x2F;设置下拉列表框项目        selecteditem &#x3D; (String) item;    &#125;    @Override    public Object getSelectedItem() &#123;&#x2F;&#x2F;获取下拉列表框种的项目        return selecteditem;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><h4 id="列表框组件"><a href="#列表框组件" class="headerlink" title="列表框组件"></a>列表框组件</h4><br/><blockquote><p>public void JList()</p><p>public void JList(ListModel dataModel)</p><p>public void JList(Vector listData)</p><p>public void JList(Object[] listData)</p></blockquote><p>使用vector类型数据作为初始化列表框的参数</p><br/><h3 id="文本组件"><a href="#文本组件" class="headerlink" title="文本组件"></a>文本组件</h3><br/><h4 id="文本框组件"><a href="#文本框组件" class="headerlink" title="文本框组件"></a>文本框组件</h4><br/><p>文本框用来显示或编辑一个单行文本，所以设置参数的时候只能设定对应的宽度</p><blockquote><p>public JTextField()</p><p>public JTextField(Document docModel, String text, int fieldWidth)</p></blockquote><br/><pre class="line-numbers language-java" data-language="java"><code class="language-java">import javax.swing.*;import java.awt.*;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;public class JTextFieldTest extends JFrame &#123;    public JTextFieldTest()&#123;        final JTextField jTextField &#x3D; new JTextField(&quot;aaa&quot;, 20);        final JButton jButton &#x3D; new JButton(&quot;清除&quot;);        setLayout(new FlowLayout());&#x2F;&#x2F;使用流式排序        Container container &#x3D; getContentPane();        container.add(jTextField);        container.add(jButton);        jTextField.setVisible(true);        setTitle(&quot;文本域的练习&quot;);        setSize(100, 100);        setVisible(true);        setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);        jButton.addActionListener(new ActionListener() &#123;            @Override            public void actionPerformed(ActionEvent e) &#123;                jTextField.setText(&quot;&quot;);&#x2F;&#x2F;通过设置为“无”，将文本框置空                jTextField.requestFocus();&#x2F;&#x2F;焦点回归到文本框            &#125;        &#125;);    &#125;    public static void main(String[] args) &#123;        new JTextFieldTest();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><h4 id="密码框组件"><a href="#密码框组件" class="headerlink" title="密码框组件"></a>密码框组件</h4><br/><p>密码框(JPasswordField)与文本框的定义和用法基本相同</p><p>唯一的不同，就是既然被称作密码框，那肯定是有着某种符号的加密</p><blockquote><p>public JPassword()</p><p>public JPassword(Document docModel, String text, int fieldWidth)</p><p>setEchoChar() 可以改变密码框的回显字符</p></blockquote><br/><h4 id="文本域组件"><a href="#文本域组件" class="headerlink" title="文本域组件"></a>文本域组件</h4><br/><blockquote><p>public JTextArea()</p><p>public JTextArea(Document doc, String Text, int rows, int columns)</p></blockquote><br/><h3 id="事件监听器"><a href="#事件监听器" class="headerlink" title="事件监听器"></a>事件监听器</h3><br/><p>在Swing程序中，通常有三个对象，分别完成事情的处理</p><p>1.事件源 2.事件 3.监听器触发对应事件</p><p>动作事件就会使用ActionEvent类对象，这个类对应的接口是ActionListener</p><blockquote><p>public addActionListener()</p><p>public removeActionListener()</p></blockquote><br/><h4 id="动作监视器"><a href="#动作监视器" class="headerlink" title="动作监视器"></a>动作监视器</h4><br/><pre class="line-numbers language-java" data-language="java"><code class="language-java">import javax.swing.*;import java.awt.*;import java.awt.event.ActionEvent;import java.awt.event.ActionListener;public class ListenerTest extends JFrame&#123;    private JButton jButton &#x3D; new JButton(&quot;点我有惊喜&quot;);    public ListenerTest()&#123;        Container container &#x3D; getContentPane();        container.add(jButton);        container.setLayout(new FlowLayout());        setTitle(&quot;动作监视器的练习&quot;);        setVisible(true);        setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);        setSize(1000, 1000);        jButton.addActionListener(new ActionListener() &#123;            @Override            public void actionPerformed(ActionEvent e) &#123;                jButton.setText(&quot;ヽ(✿ﾟ▽ﾟ)ノ&quot;);            &#125;        &#125;);    &#125;        public static void main(String[] args) &#123;        new ListenerTest();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><h4 id="焦点监视器"><a href="#焦点监视器" class="headerlink" title="焦点监视器"></a>焦点监视器</h4><br/><blockquote><p>addFocusListener()</p><p>removeFocusListener()</p></blockquote><p>当用户的焦点离开对应框时，就执行对应的操作</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搭建LNMP的LINUX服务器</title>
      <link href="2021/03/21/%E6%90%AD%E5%BB%BALNMP%E7%9A%84LINUX%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
      <url>2021/03/21/%E6%90%AD%E5%BB%BALNMP%E7%9A%84LINUX%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>在学长的大致方向的指导下，博主开始搭建了Linux服务器</p><p>使用镜像：腾讯云（孩子买不起阿里云并且不会白嫖腾讯云）</p><p>服务器配置：1核2g+chenxinyang.ltd域名 50g系统硬盘</p><p>价格：拥有学生优惠的腾讯云算很便宜，108一年加六块钱配置域名</p><p>搭建的环境：LNMP（linux nginx php myqsl）</p><p>LNMP的保姆级教程来自于<a href="https://lnmp.org/install.html">这个网站</a>、下载文件所在位置来自于<a href="https://lnmp.org/faq/lnmp-software-list.html">这个网站</a></p><br/><p><img src="https://www.runoob.com/wp-content/uploads/2014/06/1511849829609658.jpg" alt="Linux发行版本"></p><p><img src="https://www.runoob.com/wp-content/uploads/2014/06/wKioL1bvVPWAu7hqAAEyirVUn3c446.jpg-wh_651x-s_3197843091.jpg" alt="Linux大家族"></p><br/><h3 id="了解Linux文件"><a href="#了解Linux文件" class="headerlink" title="了解Linux文件"></a>了解Linux文件</h3><br/><blockquote><p><strong>/bin：</strong></p><p>bin 是 Binaries (二进制文件) 的缩写, 这个目录存放着最经常使用的命令</p><p>在使用docker时，可以直接调用这里的指令进行交互</p><p><strong>/boot</strong>：</p><p>这里存放的是启动 Linux 时使用的一些核心文件，包括一些连接文件以及镜像文件</p><p><strong>/dev ：</strong></p><p>dev 是 Device(设备) 的缩写, 该目录下存放的是 Linux 的外部设备，在 Linux 中访问设备的方式和访问文件的方式是相同的</p><p><strong>/etc：</strong></p><p>etc 是 Etcetera(等等) 的缩写,这个目录用来存放所有的系统管理所需要的配置文件和子目录</p><p>可以类比一下window系统中的etc文件，里面往往存放着hosts等极其重要的文件</p><p><strong>/home</strong>：</p><p>用户的主目录，在 Linux 中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的，如上图中的 alice、bob 和 eve</p><p>Linux配置的环境都是在这里</p><p>包括像是自己搭建的lnmp也是放置在这里，然后主页面显示的就是lnmp成功搭建网站（类似laravel配置完成之后的样子）</p><p><strong>/lib</strong>：</p><p>lib 是 Library(库) 的缩写这个目录里存放着系统最基本的动态连接共享库，其作用类似于 Windows 里的 DLL 文件。几乎所有的应用程序都需要用到这些共享库</p><p><strong>/lost+found</strong>：</p><p>这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件</p><p><strong>/media</strong>：</p><p>linux 系统会自动识别一些设备，例如U盘、光驱等等，当识别后，Linux 会把识别的设备挂载到这个目录下</p><p>看到这里我想起了laravel&amp;spring boot的一些类似的东西</p><p><strong>/mnt</strong>：</p><p>系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在 /mnt/ 上，然后进入该目录就可以查看光驱里的内容了</p><p><strong>/opt</strong>：</p><p>opt 是 optional(可选) 的缩写，这是给主机额外安装软件所摆放的目录</p><p>比如你安装一个ORACLE数据库则就可以放到这个目录下。默认是空的</p><p>  <strong>/proc</strong>：</p><p>  proc 是 Processes(进程) 的缩写，/proc 是一种伪文件系统（也即虚拟文件系统），存储的是当前内核运行状态的一系列特殊文件，这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。比如说这里存放了version指令，可以直接使用cat使用查询系统版本</p><p>  这个目录的内容不在硬盘上而是在内存里，我们也可以直接修改里面的某些文件，比如可以通过下面的命令来屏蔽主机的ping命令，使别人无法ping你的机器：</p></blockquote><br/>  <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">echo 1 &gt; &#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;icmp_echo_ignore_all<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br/><blockquote><p><strong>/root</strong>：</p><p>该目录为系统管理员，也称作超级权限者的用户主目录</p><p><strong>/sbin</strong>：</p><p>s 就是 Super User 的意思，是 Superuser Binaries (超级用户的二进制文件) 的缩写，这里存放的是系统管理员使用的系统管理程序</p><p><strong>/selinux</strong>：</p><p>这个目录是 Redhat/CentOS 所特有的目录，Selinux 是一个安全机制，类似于 windows 的防火墙，但是这套机制比较复杂，这个目录就是存放selinux相关的文件的</p><p><strong>/srv</strong>：</p><p>该目录存放一些服务启动之后需要提取的数据</p><p><strong>/sys</strong>：</p><p>这是 Linux2.6 内核的一个很大的变化。该目录下安装了 2.6 内核中新出现的一个文件系统 sysfs </p><p>sysfs 文件系统集成了下面3种文件系统的信息：针对进程信息的 proc 文件系统、针对设备的 devfs 文件系统以及针对伪终端的 devpts 文件系统</p><p>该文件系统是内核设备树的一个直观反映，steam的黑客模拟重要的也是这种东西，并且类似可视化的东西也会存在在这里</p><p>当一个内核对象被创建的时候，对应的文件和目录也在内核对象子系统中被创建</p><p><strong>/tmp</strong>：</p><p>tmp 是 temporary(临时) 的缩写这个目录是用来存放一些临时文件的</p><p><strong>/usr</strong>：</p><p>usr 是 unix shared resources(共享资源) 的缩写，这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于 windows 下的 program files 目录</p><p><strong>/usr/bin：</strong></p><p>系统用户使用的应用程序</p><p><strong>/usr/sbin：</strong></p><p>超级用户使用的比较高级的管理程序和系统守护程序</p><p><strong>/usr/src：</strong></p><p>内核源代码默认的放置目录</p><p><strong>/var</strong>：</p><p>var 是 variable(变量) 的缩写，这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件</p><p>在部署git等系统环境时，系统也会默认将修改目录存放在这里</p><p><strong>/run</strong>：</p><p>是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。如果你的系统上有 /var/run 目录，应该让它指向 run</p></blockquote><br/><h3 id="Linux常用指令"><a href="#Linux常用指令" class="headerlink" title="Linux常用指令"></a>Linux常用指令</h3><br/><h4 id="cd"><a href="#cd" class="headerlink" title="cd"></a>cd</h4><br/><p>这是一个非常基本，也是大家经常需要使用的命令，它用于切换当前目录，它的参数是要切换到的目录的路径，可以是绝对路径，也可以是相对路径。如：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cd &#x2F;root&#x2F;Docements # 切换到目录&#x2F;root&#x2F;Docementscd .&#x2F;path          # 切换到当前目录下的path目录中，“.”表示当前目录  cd ..&#x2F;path         # 切换到上层目录中的path目录中，“..”表示上一层目录<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><br/><h4 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h4><br/><p>这是一个非常有用的查看文件与目录的命令，list之意，它的参数非常多，下面就列出一些我常用的参数吧，如下：</p><p>-l ：列出长数据串，包含文件的属性与权限数据等</p><p>-a ：列出全部的文件，连同隐藏文件（开头为.的文件）一起列出来（常用）</p><p>-d ：仅列出目录本身，而不是列出目录的文件数据</p><p>-h ：将文件容量以较易读的方式（GB，kB等）列出来</p><p>-R ：连同子目录的内容一起列出（递归列出），等于该目录下的所有文件都会显示出来</p><p>注：这些参数也可以组合使用，下面举两个例子：</p><br/><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ls -l #以长数据串的形式列出当前目录下的数据文件和目录ls -lR #以长数据串的形式列出当前目录下的所有文件<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><br/><h4 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h4><br/><p>该命令常用于分析一行的信息，若当中有我们所需要的信息，就将该行显示出来，该命令通常与管道命令一起使用，用于对一些命令的输出进行筛</p><p>选加工等等，它的简单语法为</p><p>grep [-acinv] [–color=auto] ‘查找字符串’ filename</p><p>它的常用参数如下：</p><p>-a ：将binary文件以text文件的方式查找数据</p><p>-c ：计算找到‘查找字符串’的次数</p><p>-i ：忽略大小写的区别，即把大小写视为相同</p><p>-v ：反向选择，即显示出没有‘查找字符串’内容的那一行</p><p>例如：</p><p>取出文件/etc/man.config中包含MANPATH的行，并把找到的关键字加上颜色</p><p>grep –color=auto ‘MANPATH’ /etc/man.config</p><p>把ls -l的输出中包含字母file（不区分大小写）的内容输出</p><p>ls -l | grep -i file</p><br/><h4 id="find"><a href="#find" class="headerlink" title="find"></a>find</h4><br/><p>find是一个基于查找的功能非常强大的命令，相对而言，它的使用也相对较为复杂，参数也比较多，所以在这里将给把它们分类列出，它的基本语法如下：</p><p>find [PATH] [option] [action]</p><p>与时间有关的参数：</p><p>-mtime n : n为数字，意思为在n天之前的“一天内”被更改过的文件；</p><p>-mtime +n : 列出在n天之前（不含n天本身）被更改过的文件名；</p><p>-mtime -n : 列出在n天之内（含n天本身）被更改过的文件名；</p><p>-newer file : 列出比file还要新的文件名</p><p>例如：</p><p>find /root -mtime 0 # 在当前目录下查找今天之内有改动的文件（0天之内就是今天）</p><p>与用户或用户组名有关的参数：</p><p>-user name : 列出文件所有者为name的文件</p><p>-group name : 列出文件所属用户组为name的文件</p><p>-uid n : 列出文件所有者为用户ID为n的文件</p><p>-gid n : 列出文件所属用户组为用户组ID为n的文件</p><p>例如：</p><p>find /home/ljianhui -user ljianhui # 在目录/home/ljianhui中找出所有者为ljianhui的文件</p><p>与文件权限及名称有关的参数：</p><p>-name filename ：找出文件名为filename的文件</p><p>-size [+-]SIZE ：找出比SIZE还要大（+）或小（-）的文件</p><p>-tpye TYPE ：查找文件的类型为TYPE的文件，TYPE的值主要有：一般文件（f)、设备文件（b、c）、目录（d）、连接文件（l）、socket（s）、FIFO管道文件（p）；</p><p>-perm mode ：查找文件权限刚好等于mode的文件，mode用数字表示，如0755；</p><p>-perm -mode ：查找文件权限必须要全部包括mode权限的文件，mode用数字表示</p><p>-perm +mode ：查找文件权限包含任一mode的权限的文件，mode用数字表示</p><p>例如：</p><br/><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">find &#x2F; -name passwd # 查找文件名为passwd的文件find . -perm 0755 # 查找当前目录中文件权限的0755的文件find . -size +12k # 查找当前目录中大于12KB的文件，注意c表示byte<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><br/><h4 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h4><br/><p>该命令用于复制文件，copy之意，它还可以把多个文件一次性地复制到一个目录下， 它的常用参数如下：</p><p>-a ：将文件的特性一起复制</p><p>-p ：连同文件的属性一起复制，而非使用默认方式，与-a相似，常用于备份</p><p>-i ：若目标文件已经存在时，在覆盖时会先询问操作的进行</p><p>-r ：递归持续复制，用于目录的复制行为</p><p>-u ：目标文件与源文件有差异时才会复制</p><p>例如 ：</p><br/><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cp -a file1 file2 #连同文件的所有特性把文件file1复制成文件file2cp file1 file2 file3 dir #把文件file1、file2、file3复制到目录dir中<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><br/><h4 id="mv"><a href="#mv" class="headerlink" title="mv"></a>mv</h4><br/><p>该命令用于移动文件、目录或更名，move之意，它的常用参数如下：</p><p>-f ：force强制的意思，如果目标文件已经存在，不会询问而直接覆盖</p><p>-i ：若目标文件已经存在，就会询问是否覆盖</p><p>-u ：若目标文件已经存在，且比目标文件新，才会更新</p><p>注：该命令可以把一个文件或多个文件一次移动一个文件夹中，但是最后一个目标文件一定要是“目录”</p><p>例如：</p><br/><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mv file1 file2 file3 dir # 把文件file1、file2、file3移动到目录dir中mv file1 file2 # 把文件file1重命名为file2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><br/><h4 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h4><br/><p>该命令用于删除文件或目录，remove之间，它的常用参数如下：</p><p>-f ：就是force的意思，忽略不存在的文件，不会出现警告消息</p><p>-i ：互动模式，在删除前会询问用户是否操作</p><p>-r ：递归删除，最常用于目录删除，它是一个非常危险的参数</p><p>例如：</p><br/><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">rm -i file # 删除文件file，在删除之前会询问是否进行该操作rm -fr dir # 强制删除目录dir中的所有文件rm * #删除当前目录下的所有文件，小心出错<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><br/><h4 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h4><br/><p>查看当前时间的运行中的程序，在docker中也会有涉及</p><p>该命令用于将某个时间点的进程运行情况选取下来并输出，process之意，它的常用参数如下：</p><p>-A ：所有的进程均显示出来</p><p>-a ：不与terminal有关的所有进程</p><p>-u ：有效用户的相关进程</p><p>-x ：一般与a参数一起使用，可列出较完整的信息</p><p>-l ：较长，较详细地将PID的信息列出</p><p>其实我们只要记住ps一般使用的命令参数搭配即可，它们并不多，如下：</p><br/><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ps aux # 查看系统所有的进程数据ps ax # 查看不与terminal有关的所有进程ps -lA # 查看系统所有的进程数据ps axjf # 查看连同一部分进程树状态<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><br/><h4 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h4><br/><p>（第一看见这个命令我就想让的以为是终止，结果发现事实远超于此）</p><p>该命令用于向某个工作（%jobnumber）或者是某个PID（数字）传送一个信号，它通常与ps和jobs命令一起使用，它的基本语法如下：</p><p>kill -signal PID</p><p>signal的常用参数如下：</p><p>注：最前面的数字为信号的代号，使用时可以用代号代替相应的信号</p><p>1：SIGHUP，启动被终止的进程</p><p>2：SIGINT，相当于输入ctrl+c，中断一个程序的进行</p><p>9：SIGKILL，强制中断一个进程的进行</p><p>15：SIGTERM，以正常的结束进程方式来终止进程</p><p>17：SIGSTOP，相当于输入ctrl+z，暂停一个进程的进行</p><p>例如：</p><p>以正常的结束进程方式来终于第一个后台工作，可用jobs命令查看后台中的第一个工作进程</p><p>kill -SIGTERM %1 </p><p>重新改动进程ID为PID的进程，PID可用ps命令通过管道命令加上grep命令进行筛选获得</p><p>kill -SIGHUP PID</p><br/><h4 id="killall"><a href="#killall" class="headerlink" title="killall"></a>killall</h4><br/><p>该命令用于向一个命令启动的进程发送一个信号，它的一般语法如下：</p><p>killall [-iIe] [command name]</p><p>它的参数如下：</p><p>-i ：交互式的意思，若需要删除时，会询问用户</p><p>-e ：表示后面接的command name要一致，但command name不能超过15个字符</p><p>-I ：命令名称忽略大小写</p><p>例如：</p><br/><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">killall -SIGHUP syslogd # 重新启动syslogd<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br/><h4 id="file"><a href="#file" class="headerlink" title="file"></a>file</h4><br/><p>该命令用于判断接在file命令后的文件的基本数据，因为在Linux下文件的类型并不是以后缀为分的，所以这个命令对我们来说就很有用了，它的用法非常简单，基本语法如下：</p><p>file filename</p><br/><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">#例如：file .&#x2F;test<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><br/><h4 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h4><br/><p>该命令用于对文件进行打包，默认情况并不会压缩，如果指定了相应的参数，它还会调用相应的压缩程序（如gzip和bzip等）进行压缩和解压。它的常用参数如下：</p><p>-c ：新建打包文件</p><p>-t ：查看打包文件的内容含有哪些文件名</p><p>-x ：解打包或解压缩的功能，可以搭配-C（大写）指定解压的目录，注意-c,-t,-x不能同时出现在同一条命令中</p><p>-j ：通过bzip2的支持进行压缩/解压缩</p><p>-z ：通过gzip的支持进行压缩/解压缩</p><p>-v ：在压缩/解压缩过程中，将正在处理的文件名显示出来</p><p>-f filename ：filename为要处理的文件</p><p>-C dir ：指定压缩/解压缩的目录dir</p><p>上面的解说可以已经让你晕过去了，但是通常我们只需要记住下面三条命令即可：</p><p>压缩：tar -jcv -f filename.tar.bz2 要被处理的文件或目录名称</p><p>查询：tar -jtv -f filename.tar.bz2</p><p>解压：tar -jxv -f filename.tar.bz2 -C 欲解压缩的目录</p><p>注：文件名并不定要以后缀tar.bz2结尾，这里主要是为了说明使用的压缩程序为bzip2</p><br/><h4 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h4><br/><p>这个还是很常用的，毕竟是查看文件内容（爷搞完骇客模拟之后就彻底忘了这个指令（X）</p><p>该命令用于查看文本文件的内容，后接要查看的文件名，通常可用管道与more和less一起使用，从而可以一页页地查看数据。例如：</p><br/><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">cat text | less # 查看text文件中的内容<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br/><p>注：这条命令也可以使用less text来代替</p><br/><h4 id="chgrp"><a href="#chgrp" class="headerlink" title="chgrp"></a>chgrp</h4><br/><p>该命令用于改变文件所属用户组，它的使用非常简单，它的基本用法如下：</p><p>chgrp [-R] dirname/filename</p><p>-R ：进行递归的持续对所有文件和子目录更改</p><p>例如：</p><p>chgrp users -R ./dir # 递归地把dir目录下中的所有文件和子目录下所有文件的用户组修改为users</p><br/><h4 id="chown"><a href="#chown" class="headerlink" title="chown"></a>chown</h4><br/><p>该命令用于改变文件的所有者，与chgrp命令的使用方法相同，只是修改的文件属性不同，不再详述</p><p>在hexo的部署中，需要用到该指令更改git所在文件的权限</p><br/><h4 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a>chmod</h4><br/><p>该命令用于改变文件的权限，一般的用法如下：</p><p>chmod [-R] xyz 文件或目录</p><p>-R：进行递归的持续更改，即连同子目录下的所有文件都会更改</p><p>同时，chmod还可以使用u（user）、g（group）、o（other）、a（all）和+（加入）、-（删除）、=（设置）跟rwx搭配来对文件的权限进行更改。</p><p>例如：</p><br/><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">chmod 0755 file # 把file的文件权限改变为-rxwr-xr-xchmod g+w file # 向file的文件权限中加入用户组可写权限<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><br/><h4 id="vim"><a href="#vim" class="headerlink" title="vim"></a>vim</h4><br/><p>该命令主要用于文本编辑，它接一个或多个文件名作为参数，如果文件存在就打开，如果文件不存在就以该文件名创建一个文件。vim是一个非常好用的文本编辑器，它里面有很多非常好用的命令，在这里不再多说。你可以从这里下载 vim常用操作 的详细说明。</p><br/><h4 id="gcc"><a href="#gcc" class="headerlink" title="gcc"></a>gcc</h4><br/><p>对于一个用Linux开发C程序的人来说，这个命令就非常重要了，它用于把C语言的源程序文件，编译成可执行程序，由于g++的很多参数跟它非常相似，所以这里只介绍gcc的参数，它的常用参数如下：</p><p>-o ：output之意，用于指定生成一个可执行文件的文件名</p><p>-c ：用于把源文件生成目标文件（.o)，并阻止编译器创建一个完整的程序</p><p>-I ：增加编译时搜索头文件的路径</p><p>-L ：增加编译时搜索静态连接库的路径</p><p>-S ：把源文件生成汇编代码文件</p><p>-lm：表示标准库的目录中名为libm.a的函数库</p><p>-lpthread ：连接NPTL实现的线程库</p><p>-std= ：用于指定把使用的C语言的版本</p><p>例如：</p><p>把源文件test.c按照c99标准编译成可执行程序test</p><br/><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">gcc -o test test.c -lm -std&#x3D;c99#把源文件test.c转换为相应的汇编程序源文件test.sgcc -S test.c<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><br/><h4 id="time"><a href="#time" class="headerlink" title="time"></a>time</h4><br/><p>该命令用于测算一个命令（即程序）的执行时间。它的使用非常简单，就像平时输入命令一样，不过在命令的前面加入一个time即可，例如：</p><p>time ./process</p><p>time ps aux</p><p>在程序或命令运行结束后，在最后输出了三个时间，它们分别是：</p><p>user：用户CPU时间，命令执行完成花费的用户CPU时间，即命令在用户态中执行时间总和；</p><p>system：系统CPU时间，命令执行完成花费的系统CPU时间，即命令在核心态中执行时间总和；</p><p>real：实际时间，从command命令行开始执行到运行终止的消逝时间；</p><p>注：用户CPU时间和系统CPU时间之和为CPU时间，即命令占用CPU执行的时间总和。实际时间要大于CPU时间，因为Linux是多任务操作系统，往往在执行一条命令时，系统还要处理其它任务。另一个需要注意的问题是即使每次执行相同命令，但所花费的时间也是不一样，其花费时间是与系统运行相关的。</p><br/><h3 id="最基本的命令"><a href="#最基本的命令" class="headerlink" title="最基本的命令"></a>最基本的命令</h3><br/><h4 id="sudo进入特定界面"><a href="#sudo进入特定界面" class="headerlink" title="sudo进入特定界面"></a>sudo进入特定界面</h4><br/><p>Linux sudo命令以系统管理者的身份执行指令，也就是说，经由 sudo 所执行的指令就好像是 root 亲自执行</p><p>有些操作是需要管理员权限的，所以需要通过指令来进入该界面</p><p>还有一些文档是存放在某些特定地方的，这样也需要使用该指令来实现该操作</p><br/><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">sudo su #进入管理员界面sudo git #进入git界面<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><br/><h4 id="shutdown关机"><a href="#shutdown关机" class="headerlink" title="shutdown关机"></a>shutdown关机</h4><br/><p>你可以用这个命令实现Linux的关机（虽然直接关闭界面也是可以的（x）</p><br/><h4 id="退出界面"><a href="#退出界面" class="headerlink" title="退出界面"></a>退出界面</h4><br/><p>使用指令exit可以回退到上一个状态</p><p>也可以使用ctrl+d的快捷键（某人之前不知道这个指令就很蠢（x）</p><br/><h4 id="touch-amp-mkdir-amp-w"><a href="#touch-amp-mkdir-amp-w" class="headerlink" title="touch&amp;mkdir&amp;w"></a>touch&amp;mkdir&amp;w</h4><br/><p>前者用来创建文件，后者用来建立文件夹</p><p>这个最简单的w指令，用来查询当前情况下的存在的用户</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> php </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sast平台 后端</title>
      <link href="2021/03/19/sast%E5%B9%B3%E5%8F%B0-%E5%90%8E%E7%AB%AF/"/>
      <url>2021/03/19/sast%E5%B9%B3%E5%8F%B0-%E5%90%8E%E7%AB%AF/</url>
      
        <content type="html"><![CDATA[<h2 id="Github与原仓库同步"><a href="#Github与原仓库同步" class="headerlink" title="Github与原仓库同步"></a>Github与原仓库同步</h2><br/><p>实在是……有太多人同时在帮忙修订错别字或优化 xiaolai 的 <code>the-craft-of-selfteaching</code> 了。如果你提交的 pull request 未被接受且得到回复说：“重新fork”，其实是你遇到一个问题：</p><blockquote><ul><li>在你 fork 之后， xiaolai 的仓库又更新了</li><li>但 github 不会自动帮你把 xiaolai 的仓库 同步给你 fork 后的仓库</li><li>导致你提交 pull request 时的版本和 xiaolai 的版本不一致</li></ul></blockquote><p>这个问题，用显得更“专业点”的说法，叫做：<code>Github进行fork后如何与原仓库同步</code>。那到底怎么做呢</p><br/><p>最省事的办法可能是</p><blockquote><ul><li>在你fork的仓库setting页翻到最下方，然后delete这个仓库</li><li>然后重新fork xiaolai 的仓库，并 git clone 到你的本地</li></ul></blockquote><p>有时候，你需要用到这个省事的办法，比如 xiaolai 的仓库再次整理了 commit 。但在更多情况下，删掉自己fork的库，应该是你的最后选择，而不应该是首选</p><p>和很多人一起向 xiaolai 提交 pull request，这实在是一个反复练习 <code>merge</code> （中文说法：合并，或版本合并）的机会。毫不夸张地讲，版本管理是软件工程极其重要的规范，也是极其基础的必备技能。而 <code>merge</code> 则是版本管理中最必须也最常用的场景</p><p>那要不然，就多练练？以下是傻瓜版操作步骤，还细心配了截图，保管你从 0 也能上手。至于原理嘛，慢慢再搞懂吧</p><br/><h3 id="merge前的设定"><a href="#merge前的设定" class="headerlink" title="merge前的设定"></a>merge前的设定</h3><br/><p>step 1、进入到本地仓库的目录</p><p>下面所有操作，如无特别说明，都是在你的本地仓库的目录下操作。比如我的本地仓库为<code>/from-liujuanjuan-the-craft-of-selfteaching</code></p><br/><p><a href="https://user-images.githubusercontent.com/31027645/54422899-6938e880-474a-11e9-8768-27ac24673e28.png"><img src="https://user-images.githubusercontent.com/31027645/54422899-6938e880-474a-11e9-8768-27ac24673e28.png" alt="进入本地仓库"></a></p><br/><p>step 2、执行命令 <code>git remote -v</code> 查看你的远程仓库的路径：</p><br/><p><a href="https://user-images.githubusercontent.com/31027645/54422975-95ed0000-474a-11e9-96bf-1018d6bc06f2.png"><img src="https://user-images.githubusercontent.com/31027645/54422975-95ed0000-474a-11e9-96bf-1018d6bc06f2.png" alt="查看upstream是否连接远程仓库"></a></p><br/><p>如果只有上面2行，说明你未设置 <code>upstream</code> （中文叫：上游代码库）。一般情况下，设置好一次 <code>upstream</code> 后就无需重复设置</p><p>step 3、执行命令 <code>git remote add upstream https://github.com/selfteaching/the-craft-of-selfteaching.git</code> 把 xiaolai 的仓库设置为你的 <code>upstream</code> 。这个命令执行后，没有任何返回信息；所以再次执行命令 <code>git remote -v</code> 检查是否成功</p><br/><p><a href="https://user-images.githubusercontent.com/31027645/54423107-d8aed800-474a-11e9-9ab8-7bb901181283.png"><img src="https://user-images.githubusercontent.com/31027645/54423107-d8aed800-474a-11e9-9ab8-7bb901181283.png" alt="检验操作是否成功"></a></p><br/><p>step 4、执行命令 <code>git status</code> 检查本地是否有未提交的修改。如果有，则把你本地的有效修改，先从本地仓库推送到你的github仓库。最后再执行一次 <code>git status</code> 检查本地已无未提交的修改。</p><p><code>git add -A</code> 或者 <code>git add filename</code><br><code>git commit -m &quot;your note&quot;</code><br><code>git push origin master</code><br><code>git status</code></p><p>注1：这一步作为新手，建议严格执行，是为了避免大量无效修改或文本冲突带来的更复杂局面</p><p>注2：如果你已经在fork后的仓库提交了大量对 xiaolai 的仓库并没有价值的修改，那么想要pull request，还是重新回到本文最初的“最省事办法”吧</p><br/><h3 id="merge-的关键命令"><a href="#merge-的关键命令" class="headerlink" title="merge 的关键命令"></a>merge 的关键命令</h3><br/><p>以下操作紧接着上面的步骤。</p><p>step 5、执行命令 <code>git fetch upstream</code> 抓取 xiaolai 原仓库的更新：</p><br/><p><a href="https://user-images.githubusercontent.com/31027645/54448734-60b2d300-4787-11e9-9fdf-90fcc2e66052.png"><img src="https://user-images.githubusercontent.com/31027645/54448734-60b2d300-4787-11e9-9fdf-90fcc2e66052.png" alt="抓取原仓库更新的内容"></a></p><br/><p>step 6、执行命令 <code>git checkout master</code> 切换到 master 分支：</p><br/><p><a href="https://user-images.githubusercontent.com/31027645/54448759-6dcfc200-4787-11e9-8bbc-a5beef23ea88.png"><img src="https://user-images.githubusercontent.com/31027645/54448759-6dcfc200-4787-11e9-8bbc-a5beef23ea88.png" alt="切换到你自己的分支"></a></p><br/><p>step 7、执行命令 <code>git merge upstream/master</code> 合并远程的master分支：</p><br/><p><a href="https://user-images.githubusercontent.com/31027645/54449526-47128b00-4789-11e9-9add-09217eb91a68.png"><img src="https://user-images.githubusercontent.com/31027645/54449526-47128b00-4789-11e9-9add-09217eb91a68.png" alt="合并操作"></a></p><br/><p>step 8、执行命令 <code>git push </code>把本地仓库向github仓库（你fork到自己名下的仓库）推送修改</p><p>如果担心自己不小心改了哪里，可以再次执行命令 <code>git status</code> 检查哪些文件有变化。这个操作仅是检查，不会改变任何状态，放心用</p><br/><p><a href="https://user-images.githubusercontent.com/31027645/54449665-a07aba00-4789-11e9-9181-bdcc814fffe6.png"><img src="https://user-images.githubusercontent.com/31027645/54449665-a07aba00-4789-11e9-9181-bdcc814fffe6.png" alt="最后检测一次"></a></p><br/><p>现在你已经解决了fork的仓库和原仓库版本不一致的问题。可以放心向 xiaolai 发起 pull request 了。如果以上操作你花了不少时间，而 xiaolai 的仓库 又恰好更新了。很好，一次新的练习机会来了……</p><br/><h2 id="解决报错500-Server-Error："><a href="#解决报错500-Server-Error：" class="headerlink" title="解决报错500 Server Error："></a>解决报错500 Server Error：</h2><br/><p>.env.example将其复制一份重命名为env</p><p>1.打开配置文件 laravel/config/app.php</p><p>2.找到 ‘debug’项 设置为 true</p><p>3.刷新网页 抛出运行异常：No application encryption key has been specified.(未指定应用加密密钥)</p><p>4.在laravel下找到 .env.example，将其复制一份重命名为 “.env”</p><p>5.在laravel下执行命令：php artisan key:generate，后刷新页面（如果无法执行该命令，可以直接在报错页面一键生成key）</p><br/><h2 id="中间件对输入的数据进行检验"><a href="#中间件对输入的数据进行检验" class="headerlink" title="中间件对输入的数据进行检验"></a>中间件对输入的数据进行检验</h2><br/><p>主要是为了记录自己做锅的一些代码，也算对laravel基本知识的复刻</p><br/><h3 id="路由的编写"><a href="#路由的编写" class="headerlink" title="路由的编写"></a>路由的编写</h3><br/><p>这次的路由是指定在api.php中写一个指向控制器的路由，一般我们都是写在web.php上</p><p>这两者的区别，就是api.php需要在跳转的时候添加一个api前缀</p><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">Route::middleware(&#39;work.feng&#39;)-&gt;any(&#39;&#x2F;work&#39;,[WorkController::class,&#39;GodWu&#39;]);&#x2F;&#x2F;学长的例子Route::middleware(&#39;check.cxy&#39;)&#x2F;&#x2F;给中间件的定义-&gt;any(&#39;&#x2F;user&#x2F;&#123;username?&#125;&#x2F;&#123;password?&#125;&#39;, [WorkController::class,&#39;check&#39;])-&gt;where([&#39;password&#39; &#x3D;&gt; &#39;[0-9]+&#39;, &#39;username&#39; &#x3D;&gt; &#39;[a-z]+&#39;]);&#x2F;&#x2F;使用正则规定输入的值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><h3 id="中间件的使用"><a href="#中间件的使用" class="headerlink" title="中间件的使用"></a>中间件的使用</h3><br/><p>可以使用artisan命令创建一个中间件，系统会帮你设置好要使用的接口</p><p>但是先不要着急，你现在需要在kernel.php中定义中间件的名称，并规定对应位置</p><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">protected $routeMiddleware &#x3D; [&#39;work.feng&#39; &#x3D;&gt; \App\Http\Middleware\Work\work::class,&#39;check.cxy&#39; &#x3D;&gt; \App\Http\Middleware\Work\check::class&#x2F;&#x2F;将对应名称指向中间件];<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">class check&#123;    &#x2F;**     * 判断传入的类型是否是post     *     * @param  \Illuminate\Http\Request  $request     * @param  \Closure  $next     * @return mixed     *&#x2F;    public function handle(Request $request, Closure $next)&#123;        &#x2F;&#x2F;将输入的数据传入到指定的变量中，以便判断使用        $username &#x3D; $request-&gt;username;        $password &#x3D; $request-&gt;password;        if($request-&gt;method() &#x3D;&#x3D; &#39;GET&#39;)&#123;            abort(404, &#39;not support for GET&#39;);&#x2F;&#x2F;报错函数，可以设置报错信息        &#125;else&#123;            if($username &amp;&amp; $password)&#123;                 return response()-&gt;json([&#x2F;&#x2F;设置返回json数据的信息                &#39;ret&#39;  &#x3D;&gt; 200,                &#39;desc&#39; &#x3D;&gt; &#39;success!&#39;,                &#39;data&#39; &#x3D;&gt; &#39;a good saster&#39;                ], 200);            &#125;else&#123;                abort(403, &#39;the message was not complete&#39;);            &#125;        &#125;        return $next($request);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><h3 id="postman测试"><a href="#postman测试" class="headerlink" title="postman测试"></a>postman测试</h3><br/><p>可以模拟前端页面，对传入的数据进行分析返回对应的前端页面和json数据</p><p>（在前端制作天气demo的时候使用过，不过当时的天气api太拉了）</p><p>最后成功显示对应的403，404&amp;json格式，完成这个锅（好耶）</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> php </tag>
            
            <tag> laravel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA Swing程序设计 p1</title>
      <link href="2021/03/18/JAVA-Swing%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-p1/"/>
      <url>2021/03/18/JAVA-Swing%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-p1/</url>
      
        <content type="html"><![CDATA[<p>GUI（图形用户界面）为程序提供图形界面，原本的目的是为用户提供一个通用的GUI</p><p>但是Java中原来的AWT（抽象窗口工具箱）并没有达到这一点，Swing作为AWT的增强组件出现了</p><br/><h3 id="Swing概述"><a href="#Swing概述" class="headerlink" title="Swing概述"></a>Swing概述</h3><br/><p>Swing主要拥有以下特点：</p><blockquote><p>轻量级组件✔</p><p>可插入外观组件✔</p></blockquote><br/><p>Swing常用组件概述</p><br/><table><thead><tr><th align="center">组件名称</th><th align="center">定义</th></tr></thead><tbody><tr><td align="center">JButton</td><td align="center">Swing按钮，按钮中可以使用文字和图片</td></tr><tr><td align="center">JCheckBox</td><td align="center">复选框组件</td></tr><tr><td align="center">JComBox</td><td align="center">下拉列表框，可以在下拉区域显示多个选项</td></tr><tr><td align="center">JFrame</td><td align="center">框架类</td></tr><tr><td align="center">JDialog</td><td align="center">对话框</td></tr><tr><td align="center">JLabel</td><td align="center">标签组件</td></tr><tr><td align="center">JRadioButton</td><td align="center">单选按钮</td></tr><tr><td align="center">JList</td><td align="center">在用户界面中显示一系列条目</td></tr><tr><td align="center">JTextField</td><td align="center">文本框</td></tr><tr><td align="center">JPasswordField</td><td align="center">密码框</td></tr><tr><td align="center">JTextArea</td><td align="center">文本区域</td></tr><tr><td align="center">JOptionPane</td><td align="center">一些对话区域</td></tr></tbody></table><br/><h3 id="常用窗体"><a href="#常用窗体" class="headerlink" title="常用窗体"></a>常用窗体</h3><br/><h4 id="JFrame窗体"><a href="#JFrame窗体" class="headerlink" title="JFrame窗体"></a>JFrame窗体</h4><br/><p>可以说，这个是Swing的基础，可以类比于html，建立一个基本的框架，之后才好在里面进行图像界面的完善</p><p>下面是一个标准的创建格式（未设置其他参数，只有标题）</p><br/><pre class="line-numbers language-java" data-language="java"><code class="language-java">JFrame jf &#x3D; new JFrame(title);Container container &#x3D; jf.getContentPane();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><br/><p><code>getContentPane()</code>方法将窗体转化为容器，并在其中进行操作</p><p>例如<code>container.add(new JButton(&quot;按钮&quot;));</code>  <code>container.remove(new JButton(&quot;按钮&quot;));</code></p><p>可以实现类似的基本操作</p><br/><pre class="line-numbers language-java" data-language="java"><code class="language-java">import javax.swing.*;import java.awt.*;public class JF_Practice extends JFrame &#123;&#x2F;&#x2F;类中需要继承JFrame，不然无法使用相应对象    public void CreateFrame(String title)&#123;        JFrame jf &#x3D; new JFrame(title);&#x2F;&#x2F;实例化对象，并给其一个标题        Container container &#x3D; jf.getContentPane();&#x2F;&#x2F;获取容器        JLabel jl &#x3D; new JLabel(&quot;简单练习JFrame&quot;);&#x2F;&#x2F;添加标签，使得窗体中显示出文字        jl.setHorizontalAlignment(SwingConstants.CENTER);&#x2F;&#x2F;设定标签上的文字居中显示        &#x2F;&#x2F;以下是设定框架中的基本参数        container.add(jl);        container.setBackground(Color.white);        jf.setSize(200, 150);        jf.setVisible(true);&#x2F;&#x2F;设置窗体是否可视        jf.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);&#x2F;&#x2F;设定关闭方式    &#125;    public static void main(String[] args) &#123;        new JF_Practice().CreateFrame(&quot;创建一个JFrame&quot;);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>在Java的旧版本中，可以调用show()方法使得窗体可见，但是在新版jdk被舍去了</p><p>就从上述的代码来看，JFrame类可以构造有参或者无参的方法</p><br/><p>创建窗体，需要配置一个关闭方式，Java提供了多种，这里写4个常用的</p><blockquote><p>DO_NOTHING_ON_CLOSE 不关闭窗体</p><p>EXIT_ON_CLOSE 右上角按钮关闭,并且结束程序</p><p>HIDE_ON_CLOSE 窗体关闭之后只是隐藏，并不停止程序</p><p>DISPOSE_ON_CLOSE 调用任意已注册 WindowListener 的对象后自动隐藏并释放该窗体</p></blockquote><p>程序默认为第三种关闭</p><br/><h4 id="JDialog窗体"><a href="#JDialog窗体" class="headerlink" title="JDialog窗体"></a>JDialog窗体</h4><br/><p>JDialog的功能是从一个窗体中弹出另一个窗体，本质是另一种类型的窗体，与JFrame窗体类似</p><p>使用的时候也需要使用getContentPane()将窗体转化为容器</p><p>JDialog的创建和初始化和JFrame类似</p><blockquote><p>public JDiaog() 创建一个没有标题和父窗体的对话框</p><p>public JDiaog() 创建一个指定标题、窗体和模式的对话框</p></blockquote><br/><pre class="line-numbers language-java" data-language="java"><code class="language-java">import javax.swing.*;import java.awt.*;import java.awt.event.ActionEvent;public class JD_Practice &#123;    public static void main(String[] args) &#123;        MyFrame myFrame &#x3D; new MyFrame();    &#125;&#125;class MyJDialog extends JDialog&#123;    public MyJDialog(MyFrame frame)&#123;        &#x2F;&#x2F;实例化一个JDialog对象，指定对话框的父窗体、窗体标题和类型        super(frame, &quot;第一个JDialog窗体&quot;, true);        Container container &#x3D; getContentPane();        container.add(new JLabel(&quot;这是一个对话框&quot;));        setBounds(120, 120, 100, 100);&#x2F;&#x2F;通过这个方法可以设定xy轴和大小    &#125;&#125;class MyFrame extends JFrame&#123;    public MyFrame()&#123;        JFrame jFrame &#x3D; new JFrame();        Container container &#x3D; jFrame.getContentPane();        jFrame.setSize(500,500);        jFrame.setBackground(Color.white);        JLabel jLabel &#x3D; new JLabel(&quot;这是一个JFrame窗体&quot;);        jLabel.setHorizontalAlignment(SwingConstants.CENTER);        container.add(jLabel);        JButton jButton &#x3D; new JButton(&quot;弹出对话框&quot;);        jButton.setBounds(10, 10, 100, 50);        jButton.addActionListener(new AbstractAction() &#123;&#x2F;&#x2F;为按钮添加鼠标单击事件            @Override            public void actionPerformed(ActionEvent e) &#123;                new MyJDialog(MyFrame.this).setVisible(true);            &#125;        &#125;);        container.add(jButton);        jFrame.setVisible(true);        jFrame.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><h3 id="标签组件与图标"><a href="#标签组件与图标" class="headerlink" title="标签组件与图标"></a>标签组件与图标</h3><br/><p>Swing中显示文本或提示信息的方法是使用标签，支持文本和图标</p><blockquote><p>public JLabel() 创建一个不带图标和文本的JLabel对象</p><p>public JLabel(Icon icon) 创建一个带图标的JLabel对象</p><p>public JLabel(String text, Icon icon, int aligment) 创建一个带文本、带图标的JLabel对象，并设定文字水平对齐方式</p></blockquote><br/><p>Swing中通过<code>Icon接口</code>来创建图标，可以在创建时给定图标的大小、颜色</p><p>在创建时，必须实现接口的三个方法</p><blockquote><p>public int getIconHeight()</p><p>public int getIconWidth()</p><p>public void paintIcon(Component arg0, Graphics arg1, int arg2, int args)</p></blockquote><br/><pre class="line-numbers language-java" data-language="java"><code class="language-java">import javax.swing.*;import java.awt.*;public class Icon_Practice &#123;    public static void main(String[] args) &#123;        DrawIcon drawIcon &#x3D; new DrawIcon(15, 15);        JLabel jLabel &#x3D; new JLabel(&quot;测试&quot;, drawIcon, SwingConstants.CENTER);        JFrame jFrame &#x3D; new JFrame(&quot;Icon_Practice&quot;);        Container container &#x3D; jFrame.getContentPane();        jFrame.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);        jFrame.setVisible(true);        jFrame.setSize(500, 500);        jFrame.setBackground(Color.white);        container.add(jLabel);    &#125;    &#125;class DrawIcon implements Icon&#123;    private int height;    private int width;    &#x2F;&#x2F;以下操作涵盖Icon接口中必需的方法    @Override    public int getIconHeight() &#123;        return this.height;    &#125;    @Override    public int getIconWidth() &#123;        return this.width;    &#125;    public DrawIcon(int width, int height)&#123;        this.width &#x3D; width;        this.height &#x3D; height;    &#125;    &#x2F;&#x2F;Graphics包含了各种的图形    @Override    public void paintIcon(Component c, Graphics g, int x, int y) &#123;        g.fillOval(x, y, width, height);&#x2F;&#x2F;调用方法画圆    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>介绍的时候有提过，除了文字之外，JLabel还可以使用Icon</p><p>利用ImageIcon类根据现有图片创建图标</p><blockquote><p>public ImageIcon() 创建一个通用对象，等到需要时可以使用setImage(Image image)</p><p>public ImageIcon(Image image, String description) 从图源创建图片，还可以为图片创建描述，可以使用getDescription()来获取对应信息</p><p>publice ImageIcon(URL url) 利用图像文件创建</p></blockquote><br/><pre class="line-numbers language-java" data-language="java"><code class="language-java">import javax.swing.*;import java.awt.*;import java.net.URL;public class MyImageIcon extends JFrame &#123;&#x2F;&#x2F;继承JFrame之后，下面写的方法就是对整个窗体操作了    public MyImageIcon()&#123;        Container container &#x3D; getContentPane();        JLabel jLabel &#x3D; new JLabel(&quot;这是一个JLabel&quot;, JLabel.CENTER);&#x2F;&#x2F;在标签定义时规定样式        URL url &#x3D; MyImageIcon.class.getResource(&quot;.&#x2F;Pictures&#x2F;1.jpg&quot;);&#x2F;&#x2F;实例化一个URL实例，读取图片所在的位置        Icon icon &#x3D; new ImageIcon(url);        jLabel.setIcon(icon);        jLabel.setHorizontalAlignment(SwingConstants.CENTER);        jLabel.setVisible(true);        container.add(jLabel);        setSize(250, 100);        setVisible(true);        setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);    &#125;    public static void main(String[] args) &#123;        new MyImageIcon();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><h3 id="布局管理"><a href="#布局管理" class="headerlink" title="布局管理"></a>布局管理</h3><br/><p>在这一块的内容就有点像前端的css了（子绝父相），使用布局管理比直接控制Swing组件的位置和大小要方便得多</p><p>主要包括流布局管理器、边界管理器&amp;网络布局管理器</p><br/><h4 id="绝对布局"><a href="#绝对布局" class="headerlink" title="绝对布局"></a>绝对布局</h4><br/><blockquote><p>1.Container.setLayout(null) 取消布局管理器</p><p>2.Component.setBounds() 设置每个组件的大小与位置</p></blockquote><br/><h4 id="流布局管理器"><a href="#流布局管理器" class="headerlink" title="流布局管理器"></a>流布局管理器</h4><br/><p>流布局就如起名，容器中的布局想”流“一样从左到右摆放组件，知道占据了这一行的所有空间</p><blockquote><p>public FlowLayout()</p><p>public FlowLayout(int alignment, int horizGap, int vertGap)</p></blockquote><p>alignment参数可以被赋予三个值之一</p><blockquote><p>0 左对齐</p><p>1 居中</p><p>2 右对齐</p></blockquote><br/><pre class="line-numbers language-java" data-language="java"><code class="language-java">import javax.swing.*;import java.awt.*;public class FlowLayoutPosition extends JFrame &#123;    public FlowLayoutPosition()&#123;        setTitle(&quot;流布局管理器&quot;);        Container container &#x3D; getContentPane();        setLayout(new FlowLayout(1, 50, 50));&#x2F;&#x2F;后两个参数主要设定高低间隔的大小        for (int i &#x3D; 0; i &lt; 10; i ++)&#123;            container.add(new JButton(&quot;button&quot; + i));        &#125;        setSize(1000, 1000);        setVisible(true);        setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);    &#125;    public static void main(String[] args) &#123;        new FlowLayoutPosition();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>流布局中，如果改变整个窗体的大小，其中组件的摆放位置也会相应发生变化</p><br/><h4 id="边界布局管理器"><a href="#边界布局管理器" class="headerlink" title="边界布局管理器"></a>边界布局管理器</h4><br/><p>边界（border），你可能会想到前端的盒式模型。margin、padding等等（虽然博主在前端考核时没去，但我也算半个前端人（x）</p><blockquote><p>BorderLayout.NORTH 组件置于顶端</p><p>BorderLayout.SOUTH 组件置于底端</p><p>BorderLayout.EAST 组件右端</p><p>BorderLayout.WEST 组件置于左端</p><p>BorderLayout.CENTER 组件从中间开始填充</p></blockquote><br/><h4 id="网格组布局管理器"><a href="#网格组布局管理器" class="headerlink" title="网格组布局管理器"></a>网格组布局管理器</h4><br/><p>由GridLayout类实现的布局管理</p><p><code>public GridLayout(int rows, int columns, int horizGap, int vertGap)</code> 网格如其名，自然是设定行和列&amp;每个布局布局的间隔</p><p>如果尝试改变窗体大小，组件的大小也会跟着改变</p><p>左上角的索引为0，此时组件左上角的点为起始点</p><blockquote><p>gridx&amp;girdy 设置组件起始点所在单元格的索引值</p><p>girdwidth&amp;gridheight 设置组件占用网格的行数和列数</p><p>anchor 用来设置组件在显示区域的显示位置</p><p>fill 设置组件的填充方式，因为组件不一定填满整个区域</p></blockquote><p>1.默认为NONE</p><p>2.设置为HORIZONTAL时，只调整组件水平方向的大小</p><p>3.设置为VERTICAL，只调整组件垂直方向的大小</p><p>4.BOTH，简而易懂，同时调整组件的水平方向&amp;垂直方向大小</p><blockquote><p>insets 设置组件四周与单元格边缘之间的最小距离Insets(int top, int left, int bottom, int right)设置组件的最小距离</p><p>ipadx&amp;ipady 修改组件的首选大小，分别修改组件的宽度和高度</p><p>weightx&amp;weighty 设置额外的空间，在窗体跳到足够大的情况下，避免出现窗体过大导致的大面积空白的情况</p></blockquote><br/><h3 id="常用面板"><a href="#常用面板" class="headerlink" title="常用面板"></a>常用面板</h3><br/><h4 id="JPanel面板"><a href="#JPanel面板" class="headerlink" title="JPanel面板"></a>JPanel面板</h4><br/><p>在JPanel中可以聚集一些组件来布局，面板本身也是容器的一种、</p><p>所以你单独设计面板，将组件放在面板中，然后将整体面板放在容器中</p><br/><pre class="line-numbers language-java" data-language="java"><code class="language-java">import javax.swing.*;import java.awt.*;public class JPanel_Practice extends JFrame &#123;    public JPanel_Practice()&#123;        Container container &#x3D; getContentPane();        container.setLayout(new GridLayout(2, 1, 10, 10));        JPanel p1 &#x3D; new JPanel(new GridLayout(1, 3, 10, 10));        JPanel p2 &#x3D; new JPanel(new GridLayout(1, 2, 10, 10));        p1.add(new JButton(&quot;1&quot;));        p1.add(new JButton(&quot;2&quot;));        p1.add(new JButton(&quot;3&quot;));        p2.add(new JButton(&quot;4&quot;));        p2.add(new JButton(&quot;5&quot;));        container.add(p1);        container.add(p2);        setTitle(&quot;只是一个JPanel面板练习&quot;);        setVisible(true);        setSize(1000, 1000);        setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);    &#125;    public static void main(String[] args) &#123;        new JPanel_Practice();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><h4 id="JScrollPane面板"><a href="#JScrollPane面板" class="headerlink" title="JScrollPane面板"></a>JScrollPane面板</h4><br/><p>在设置界面时，有可能会遇到在较小容器的窗体中显示一个较大部分内容的情况</p><p>带有滚动条的JScrollPane就适合这样的场景，但是该面板只能放置一个组件，并且不能使用布局管理器</p><p>当然，你可以先将组件放在JPane面板中，然后将其作为一个整体添加到JScrollPane面板中</p><br/><pre class="line-numbers language-java" data-language="java"><code class="language-java">import javax.swing.*;import java.awt.*;public class JScrollPane_Practice extends JFrame &#123;    public JScrollPane_Practice()&#123;        Container container &#x3D; getContentPane();        JTextArea jTextArea &#x3D; new JTextArea(20, 50);        JScrollPane jScrollPane &#x3D; new JScrollPane(jTextArea);        container.add(jScrollPane);        setTitle(&quot;带滚动条的文字编译器&quot;);        setSize(200, 200);        setVisible(true);        setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);    &#125;    public static void main(String[] args) &#123;        new JScrollPane_Practice();    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++ 类和动态内存分配</title>
      <link href="2021/03/15/c-%E7%B1%BB%E5%92%8C%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/"/>
      <url>2021/03/15/c-%E7%B1%BB%E5%92%8C%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/</url>
      
        <content type="html"><![CDATA[<p>在一切的开始，我们了解了动态内存，通过定义指针并给其创建动态内存</p><p>因为数组的内存创建是在编译中，这会加大对计算机的负荷，所以我们倾向于在运行时创建，之后便可以在结束之后释放</p><p>既然c++都有类了，那必然要学习类中创建动态内存</p><br/><h3 id="基本的写法"><a href="#基本的写法" class="headerlink" title="基本的写法"></a>基本的写法</h3><br/><p>构造函数中，我们为类中表示的属性分配动态内存</p><p>在析构函数中，我们使用delete释放内存，并可以加上提示信息，表示运行过程</p><p><code>int a = new int(1);</code>表示初始化一个整形a，并且赋值为0</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;using namespace std;class StringBad&#123;    private:        char * str;        static int num_string;        int len;    public:        StringBad(const char * s);&#x2F;&#x2F;为输入的字符串分配动态内存        ~StringBad();&#x2F;&#x2F;释放内存        friend ostream &amp; operator &lt;&lt; (ostream &amp; os, const StringBad &amp; sb);&#x2F;&#x2F;创建友元，重载&lt;&lt;（详细可以看上一篇博客）&#125;;int StringBad :: num_string &#x3D; 0;&#x2F;&#x2F;对静态成员进行初始化，不然会报错StringBad :: StringBad(const char * s)&#123;    len &#x3D; strlen(s);    str &#x3D; new char[len + 1];&#x2F;&#x2F;len的长度不包括末尾字符的长度，所以要加一    strcpy(str, s);&#x2F;&#x2F;这里不能直接使用str &#x3D; s;，因为这只是传递了地址（指针通过地址传值），没有创建新的副本    num_string ++;    cout &lt;&lt; num_string &lt;&lt; &quot; &quot; &lt;&lt; str &lt;&lt; &quot; created &quot; &lt;&lt; endl;&#125;StringBad :: ~StringBad()&#123;    cout &lt;&lt; num_string &lt;&lt; &quot; &quot; &lt;&lt; str &lt;&lt; &quot; deleted &quot; &lt;&lt; endl;    num_string --;    cout &lt;&lt; num_string &lt;&lt; &quot; lefted &quot; &lt;&lt; endl;&#x2F;&#x2F;通过提示信息，方便显示程序有没有正确执行    delete [] str;&#125;ostream &amp; operator &lt;&lt; (ostream &amp; os, const StringBad &amp; sb)&#123;    os &lt;&lt; sb.str &lt;&lt; endl;&#x2F;&#x2F;重载内容        return os;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>对于静态变量一定要赋值，否则会出现错误<code>ld returned 1 exit status</code></p><p>当将类的某个数据成员声明为static时，该静态数据成员只能被定义一次，而且要被同类的所有对象共享。各个对象都拥有类中每一个普通数据成员的副本，但静态数据成员只有一个实例存在，与定义了多少类对象无关</p><p>静态数据成员的用途之一是统计有多少个对象实际存在</p><p>静态数据成员不能在类中初始化，实际上类定义只是在描述对象的蓝图，在其中指定初值是不允许的。也不能在够造函数中初始化该成员，因为静态数据成员为类的各个对象共享，那么每次创建一个类的对象则静态数据成员都要被重新初始化</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;#include &quot;StringBad.h&quot;using namespace std;int main()&#123;    StringBad news1(&quot;cxy married mako&quot;);    StringBad news2(&quot;cxy got 1 billion dollars in the company&quot;);    StringBad news3(&quot;cxy passed away in the hospital&quot;);&#x2F;&#x2F;我骂我自己    cout &lt;&lt; news1;    cout &lt;&lt; news2;    cout &lt;&lt; news3;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>在程序的最后，主函数会自动调用析构函数</p><p>所以，在上一篇博客中所说，析构函数的主要用途就是释放内存，提示信息</p><br/><h3 id="复制构造函数"><a href="#复制构造函数" class="headerlink" title="复制构造函数"></a>复制构造函数</h3><br/><p>如果没有定义默认构造函数，编译器会自动创建一个，进行所谓的浅复制，这不足以应付所有的情况</p><p>复制构造函数作用于将一个对象的常量引用，它使用于初始化过程中，这就是我们需要的深复制</p><p>复制构造函数有三种应用场景：</p><blockquote><p>显示调用，即像一般构造函数使用一样</p><p>将对象赋值时</p><p>函数的返回值是对象时</p></blockquote><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">StringBad(const StringBad &amp;);&#x2F;&#x2F;接受指向类对象的常量引用作为参数StringBad ditto(motto);StringBad metoo &#x3D; motto;StringBad also &#x3D; StringBad(motto);StringBad * pStringBad &#x3D; new StringBad(motto);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>默认的复制构造函数逐个复制非静态成员，复制的是成员的值</p><p>所以复制过去之后，可以直接成员的进行操作</p><p>接下来，准备使用复制构造函数对上面的类进行一些代码上的优化</p><br/><h3 id="对上述代码优化"><a href="#对上述代码优化" class="headerlink" title="对上述代码优化"></a>对上述代码优化</h3><br/><p>1.如果有时定义错误的函数，并且调用了，可能会导致计数问题</p><p>（vscode中，这些错误会提示出来并且将程序终止，可能会引起难以预知的错误）</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void callme(StringBad sb)&#123;cout &lt;&lt; sb &lt;&lt; &quot;created&quot;;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>该函数被调用时，不仅初始化了函数中的形参，而且在其后面的赋值也通过此创建了新的对象</p><p>所以计数就会多2，导致程序的计数不准确</p><p>解决方法便是构造一个显示复制构造函数，如果放任使用默认构造函数，不会构建对象，这是十分危险的</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">StringBad :: StringBad(const StringBad &amp; sd)&#123;    num_string ++;        len &#x3D; sd.len;    str &#x3D; new char[len + 1];    strcpy(str, sd.str);    cout &lt;&lt; str &lt;&lt; &quot; created &quot; &lt;&lt; endl;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>2.在其他编译器中，就算能运行，也会出现显示乱码的情况</p><p>如果直接定义StringBad类的对象并且赋值同类的另一个对象，可能会导致析构函数调用两次导致的程序异常终止</p><p>（在vscode中，这个错误是不显示的，vs2010中显示消息错误窗口）</p><p>因为赋值的过程只是传递了字符串的指针而没有创建副本，所以会释放已经被释放的内存</p><p>这样，析构函数就执行了两次，而这样的对象不是通过构造函数的，所以最后会显示负数的值并且出现乱码</p><br/><p>这时候，聪明的你一定想到了解决方法，就是重载赋值运算符</p><p>使得在同类对象可以直接使用赋值关键词进行连接</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">StringBad &amp; operator &#x3D; (const StringBad &amp; st);&#x2F;&#x2F;声明的时候不需要加StringBad :: 编译器会报重复定义错误StringBad &amp; StringBad :: operator &#x3D; (const StringBad &amp; st)&#123;    if(this &#x3D;&#x3D; &amp;sb)&#123;&#x2F;&#x2F;this是指针地址，代表该类对象        return * this;&#x2F;&#x2F;如果是对象本身，就自己分配给自己    &#125;        delete [] str;&#x2F;&#x2F;因为是赋值，就把老的string去掉    len &#x3D; sb.len;    str &#x3D; new char[len + 1];    strcpy(str, sb.str);    return * this;&#x2F;&#x2F;还是再提一句，不是传递地址，而是创建新的副本&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>这里补充一点，如果想在主函数中，只用函数传递对象，一定要使用引用</p><p>不然就是按值传递，这样可能会出大问题</p><br/><h3 id="StringBad-gt-String"><a href="#StringBad-gt-String" class="headerlink" title="StringBad-&gt;String"></a>StringBad-&gt;String</h3><br/><p>鉴于默认构造可能会出问题的原因，我们可以对其进行适当修改</p><p>这里，就需要了解一下空指针的概念</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">StringBad :: StringBad()&#123;   len &#x3D; 0;   str &#x3D; new char[1];   str[0] &#x3D; &#39;\0&#39;;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>除了上面的<code>str = new char[1];</code>之外，还可以写成<code>str = new char;</code></p><p>这两者所定义的内存量相同，区别在于，前者是兼容析构函数的</p><p>使用delete和new初始化的指针和空指针都兼容，所以可以修改为<code>str = 0;</code></p><p>c++中，0既可以表示数字值零，也可以表示空指针，不过现在建议使用<code>nullptr</code>表示空指针</p><br/><h4 id="比较成员函数"><a href="#比较成员函数" class="headerlink" title="比较成员函数"></a>比较成员函数</h4><br/><p>在一般的字符串比较中，一般都是使用之前c语言的<code>strcmp</code></p><p>理所当然地，为了方便，我们可以重载<code>&lt;</code> <code>&gt;</code> <code>==</code>等比较符，由于是逻辑运算符，需要使用bool类型</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">friend bool operator &lt; (const StringBad &amp; st1, const StringBad &amp; st2);friend bool operator &gt; (const StringBad &amp; st1, const StringBad &amp; st2);bool operator &lt; (const StringBad &amp; st1, const StringBad &amp; st2)&#123;    return strcmp(st1.str, st2.str);&#x2F;&#x2F;因为strcmp本身的返回值就是布尔值        &#x2F;*        当然，也可以写得稍微复杂一点    if(strcmp(st1.str, st2.str) &lt; 0)&#123;        return true;        &#125;else&#123;        return false;        &#125;        *&#x2F;&#125;bool operator &gt; (const StringBad &amp; st1, const StringBad &amp; st2)&#123;        return st2 &lt; st1;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>其他的判断关键词同理也可以，进行相似地重载</p><p>如同上述所说，也可以在上述定义好的情况下，进行重载操作</p><br/><h4 id="使用中括号访问字符"><a href="#使用中括号访问字符" class="headerlink" title="使用中括号访问字符"></a>使用中括号访问字符</h4><br/><p>c语言风格的编程中，可以使用<code>a[i]</code>返回特定位置的字符</p><p>在c++中，特别是类中，也可以通过重载<code>[]</code>符号的方式来执行这种操作</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">char &amp; String :: operator[](int i) const&#123;&#x2F;&#x2F;使用const定义可以读取常量        return str[i];    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>在这之后，就可以不用<code>String a(&quot;interesting&quot;);</code> <code>a.str[0] = &#39;r&#39;;</code>了</p><p>直接<code>a[0] = &#39;r&#39;;</code></p><br/><h4 id="gt-gt-字符重载"><a href="#gt-gt-字符重载" class="headerlink" title="&gt;&gt;字符重载"></a>&gt;&gt;字符重载</h4><br/><p>io流的输出有重载了，输入自然也少不了</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">static const int CINLIM &#x3D; 80;friend istream  &amp; operator &gt;&gt; (istream &amp; is, String &amp; st);&#x2F;&#x2F;由于输入的数值是不定值，所以不需要用const修饰istream &amp; operator &gt;&gt; (istream &amp; is, String &amp; st)&#123;        char temp[String :: CINLIM];    is.get(temp, CINLIM);        if(is)&#123;                st &#x3D; temp;            &#125;        while(is &amp;&amp; is.get() !&#x3D; &#39;\n&#39;)&#123;                continue;            &#125;        return is;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><h3 id="对返回对象的说明"><a href="#对返回对象的说明" class="headerlink" title="对返回对象的说明"></a>对返回对象的说明</h3><br/><p>1.返回值指向非const对象的引用（重载赋值运算符&amp;cout使用的&lt;&lt;运算符）</p><p>（前者是旨在提高效率，而后者是必须这么干）</p><p>在这之中，有两种用法</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;version 1Vector Max(const Vector &amp; v1, const Vector &amp; v2);&#x2F;&#x2F;version 2const &amp; Vector Max(const Vector &amp; v1, const Vector &amp; v2)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>2.如果返回对象是被调用函数中的局部变量，就不能使用引用方式返回</p><p>3.其他的返回类型可以使用const加快效率</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA 异常处理</title>
      <link href="2021/03/13/JAVA-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
      <url>2021/03/13/JAVA-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>每个编译器中都会存在报错提示，而且现在的整合型编译器提示的信息往往非常详细</p><p>如果遇到问题，可以在网上查询意思并尝试自己寻找</p><p>但在Java中，我们可以捕捉并抛出错误</p><br/><h3 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h3><br/><p>Java的异常捕获由<code>try</code>、<code>catch</code>和<code>finally</code>组成</p><p>当然，finally可以省略</p><br/><table><thead><tr><th align="center">关键字</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">try</td><td align="center">规定捕获的代码块</td></tr><tr><td align="center">catch</td><td align="center">捕获之后，如果存在错误，就激发捕获的异常</td></tr><tr><td align="center">finally</td><td align="center">异常处理最后执行的部分</td></tr></tbody></table><br/><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class ErrorTest &#123;    public static void main(String[] args) &#123;        try &#123;            String str &#x3D; &quot;cxy&quot;;            System.out.println(str + &quot;的年龄是&quot;);            int age &#x3D; Integer.parseInt(&quot;20L&quot;);            System.out.println(age);        &#125;catch (Exception e)&#123;&#x2F;&#x2F;Exception是try代码传递给catch代码块的变量类型            e.printStackTrace();&#x2F;&#x2F;输出异常信息，指出异常的类型、性质、栈层次以及出现在程序中的位置            &#x2F;&#x2F;System.out.println(e.getMessage()); 输出错误性质，整个使得错误的原因更加直观            &#x2F;&#x2F;System.out.println(e.toString()); 输出异常的类型和性质，能帮助程序员知道错误属于那个包中，比上面一个略具体些        &#125;        System.out.println(&quot;game over&quot;);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>当try语句出现问题是，就会终止操作，跳转到catch语句</p><p>Java的异常是结构化的，不会因为一个异常就会影响整个程序的执行</p><br/><h3 id="Java-内置异常类"><a href="#Java-内置异常类" class="headerlink" title="Java 内置异常类"></a>Java 内置异常类</h3><br/><p>Java 语言定义了一些异常类在 java.lang 标准包中</p><p>标准运行时异常类的子类是最常见的异常类。由于 java.lang 包是默认加载到所有的 Java 程序的，所以大部分从运行时异常类继承而来的异常都可以直接使用</p><br/><p>Java 根据各个类库也定义了一些其他的异常，下面的表中列出了 Java 的非检查性异常</p><p>这些异常，往往一看都能明白原因，不知道的也可以查询相关网站，这里的异常内容来自于<a href="https://www.runoob.com/java/java-exceptions.html">菜鸟教程</a></p><br/><table><thead><tr><th align="center"><strong>异常</strong></th><th align="center"><strong>描述</strong></th></tr></thead><tbody><tr><td align="center">ArithmeticException</td><td align="center">当出现异常的运算条件时，抛出此异常。例如，一个整数”除以零”时，抛出此类的一个实例</td></tr><tr><td align="center">ArrayIndexOutOfBoundsException</td><td align="center">用非法索引访问数组时抛出的异常。如果索引为负或大于等于数组大小，则该索引为非法索引</td></tr><tr><td align="center">ArrayStoreException</td><td align="center">试图将错误类型的对象存储到一个对象数组时抛出的异常</td></tr><tr><td align="center">ClassCastException</td><td align="center">当试图将对象强制转换为不是实例的子类时，抛出该异常</td></tr><tr><td align="center">IllegalArgumentException</td><td align="center">抛出的异常表明向方法传递了一个不合法或不正确的参数</td></tr><tr><td align="center">IllegalMonitorStateException</td><td align="center">抛出的异常表明某一线程已经试图等待对象的监视器，或者试图通知其他正在等待对象的监视器而本身没有指定监视器的线程</td></tr><tr><td align="center">IllegalStateException</td><td align="center">在非法或不适当的时间调用方法时产生的信号。换句话说，即 Java 环境或 Java 应用程序没有处于请求操作所要求的适当状态下</td></tr><tr><td align="center">IllegalThreadStateException</td><td align="center">线程没有处于请求操作所要求的适当状态时抛出的异常</td></tr><tr><td align="center">IndexOutOfBoundsException</td><td align="center">指示某排序索引（例如对数组、字符串或向量的排序）超出范围时抛出</td></tr><tr><td align="center">NegativeArraySizeException</td><td align="center">如果应用程序试图创建大小为负的数组，则抛出该异常</td></tr><tr><td align="center">NullPointerException</td><td align="center">当应用程序试图在需要对象的地方使用 <code>null</code> 时，抛出该异常</td></tr><tr><td align="center">NumberFormatException</td><td align="center">当应用程序试图将字符串转换成一种数值类型，但该字符串不能转换为适当格式时，抛出该异常</td></tr><tr><td align="center">SecurityException</td><td align="center">由安全管理器抛出的异常，指示存在安全侵犯</td></tr><tr><td align="center">StringIndexOutOfBoundsException</td><td align="center">此异常由 <code>String</code> 方法抛出，指示索引或者为负，或者超出字符串的大小</td></tr><tr><td align="center">UnsupportedOperationException</td><td align="center">当不支持请求的操作时，抛出该异常</td></tr></tbody></table><br/><p>下面的表中列出了 Java 定义在 java.lang 包中的检查性异常类</p><br/><table><thead><tr><th align="center"><strong>异常</strong></th><th align="center"><strong>描述</strong></th></tr></thead><tbody><tr><td align="center">ClassNotFoundException</td><td align="center">应用程序试图加载类时，找不到相应的类，抛出该异常</td></tr><tr><td align="center">CloneNotSupportedException</td><td align="center">当调用 <code>Object</code> 类中的 <code>clone</code> 方法克隆对象，但该对象的类无法实现 <code>Cloneable</code> 接口时，抛出该异常</td></tr><tr><td align="center">IllegalAccessException</td><td align="center">拒绝访问一个类的时候，抛出该异常</td></tr><tr><td align="center">InstantiationException</td><td align="center">当试图使用 <code>Class</code> 类中的 <code>newInstance</code> 方法创建一个类的实例，而指定的类对象因为是一个接口或是一个抽象类而无法实例化时，抛出该异常</td></tr><tr><td align="center">InterruptedException</td><td align="center">一个线程被另一个线程中断，抛出该异常</td></tr><tr><td align="center">NoSuchFieldException</td><td align="center">请求的变量不存在</td></tr><tr><td align="center">NoSuchMethodException</td><td align="center">请求的方法不存在</td></tr></tbody></table><br/><h3 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h3><br/><p>Java内置的异常可以解决编程时出现的错误</p><p>程序员可以根据自己想法自定义异常，使得程序在数据不符合预期时，抛出异常</p><br/><p>首先创建自己的异常类，该类继承<code>Exception</code></p><p>字符串<code>ErrorMessage</code>则是要输出的错误信息，通过super调用父类的构造方法</p><br/><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class MyError extends Exception&#123;    public MyError(String ErrorMessage)&#123;        super(ErrorMessage);&#x2F;&#x2F;调用父类构造函数    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>在所要实现程序中，则需要使用<code>throw</code>、<code>throws</code>关键字来抛出对应的错误</p><p>throws定义在对应的方法中，使得在自定义时能够更改对应的异常信息</p><br/><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class ExceptionTest &#123;    static void avg(int num1, int num2) throws MyError&#123;&#x2F;&#x2F;定义方法，抛出异常        if (num1 &lt; 0 || num2 &lt; 0)&#123;            throw new MyError(&quot;数值太小了&quot;);&#x2F;&#x2F;MyError中的异常信息        &#125;else if (num1 &gt; 100 || num2 &gt; 100)&#123;            throw new MyError(&quot;数值太大了&quot;);        &#125;else&#123;            System.out.println(&quot;大小正好&quot;);        &#125;    &#125;    public static void main(String[] args) &#123;        try &#123;            avg(102, 101);        &#125;catch(MyError e)&#123;            System.out.println(e);        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>当然，如果要抛出系统内置的异常，也是需要throws定义对应方法的</p><p>（如果是<code>Error</code>、<code>RuntimeException</code>或它们的子类，则可以不使用throws关键字，会被系统抛出）</p><p>当然catch是可以捕获多种异常的，可以根据异常不同执行不同的代码块</p><br/><pre class="line-numbers language-java" data-language="java"><code class="language-java">try &#123;        avg(102, 101);    &#125;catch(MyError e)&#123;        System.out.println(e);    &#125;catch (Exception e)&#123;            System.out.println(&quot;发生了其它异常&quot;);        System.out.println(e.toString());        &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA 继承性与多态</title>
      <link href="2021/03/13/JAVA-%E7%BB%A7%E6%89%BF%E6%80%A7%E4%B8%8E%E5%A4%9A%E6%A0%B7%E6%80%A7/"/>
      <url>2021/03/13/JAVA-%E7%BB%A7%E6%89%BF%E6%80%A7%E4%B8%8E%E5%A4%9A%E6%A0%B7%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<p>继承性：即在一个定义一个父类，在这之后，这个父类的子类会自动拥有父类中包含的属性</p><p>多态性：同一个指令，在不同代码中处理的结果有所不同</p><p>（封装性：数据都被保存起来，无法随意调用，起到保护作用）</p><br/><h3 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h3><br/><p>用户创建一个类时，除非已经指定要从其他类继承，否则它就是从Object类继承而来</p><p>String、Integer等类都是继承于Object，所以在定义类的时候不需要使用<code>extends</code>关键字</p><p>（Object类中的getClass()、notify()、notifyAll()、wait()等方法不能被重写，因为这些方法被定义为<code>final</code>）</p><br/><h4 id="getClass"><a href="#getClass" class="headerlink" title="getClass()"></a>getClass()</h4><br/><p>getClass()会返回对象执行时的Class实例，然后调用getName()方法可以取得类的名称</p><br/><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Test&#123;        public void show()&#123;                System.out.println(getClass.getName());            &#125;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><h4 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h4><br/><p>toString()是将一个对象返回位字符串的形式，返回一个String实例</p><p>当这个类转换位字符串或字符串连接时，将自动调用重写的toString()方法</p><br/><h3 id="对象类型的转换"><a href="#对象类型的转换" class="headerlink" title="对象类型的转换"></a>对象类型的转换</h3><br/><p>对象类型的转化，就是在类中父类子类的转化</p><p>可以类比一下一般的int，double类型的转化</p><br/><h4 id="向上转型"><a href="#向上转型" class="headerlink" title="向上转型"></a>向上转型</h4><br/><p>这里书中举了”平行四边形”和”四边形类”的例子</p><p>将子类对象赋给父类对象是允许的</p><p>所以将子类对象看作父类对象被称为”向上转型”，这是安全的</p><br/><h4 id="向下转型"><a href="#向下转型" class="headerlink" title="向下转型"></a>向下转型</h4><br/><p>反过来，将子类对象赋值给父类有可能会报安全方面的错误</p><p>这时就需要强制转化</p><br/><h4 id="instanceof判断对象类型"><a href="#instanceof判断对象类型" class="headerlink" title="instanceof判断对象类型"></a>instanceof判断对象类型</h4><br/><p>可以使用<code>myobject instanceof ExampleClass</code></p><p>某个类的对象的引用+某个类</p><p>（注意：该操作符都是小写字母）</p><br/><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><br/><p>根据Java这些继承性和转化的特征</p><p>如果只定义一个父类，让它处理所有继承该类的对象，根据<code>向上转型</code>的原则就可以使每个子类都是用对应的方法</p><p>这种特性省去了冗余的代码，也使得程序本身更易于维护</p><br/><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><br/><p>在解决实际问题时，我们一般将父类定义为抽象类，需要使用这个父类进行继承与多态处理</p><p>抽象父类不需要将父类初始化对象，不需要创建构造函数，我们需要的只是子类对象</p><p>因为是”抽象”的类，所以抽象父类不能实例化，但是子类可以</p><p>抽象类用<code>abstract</code>来定义，抽象方法也是</p><br/><pre class="line-numbers language-java" data-language="java"><code class="language-java">public abstract class Test&#123;        abstract void TestAbstract();&#x2F;&#x2F;定义抽象方法    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>同理，定义的抽象方法也是不能有参数</p><p>所以继承的子类一定要覆写父类定义的抽象方法</p><br/><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><br/><p>接口是抽象类的延伸，可以将它看作是纯粹的抽象类</p><p>接口使用<code>interface</code>定义（接口中省略<code>abstract</code>）</p><p>如果是在某个类中调用接口，则是使用<code>implements</code>关键字</p><br/><pre class="line-numbers language-java" data-language="java"><code class="language-java">public interface Test&#123;void Test();&#125;&#x2F;&#x2F;接口允许这样继承public interface test extends Test&#123;        ...        &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class a extends b implements c, d&#123;&#x2F;&#x2F;一个类不能多次继承，但可以调用多个接口...&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>（接口中定义的任何字段自动都是static和final）</p><br/><h3 id="this-amp-super"><a href="#this-amp-super" class="headerlink" title="this&amp;super"></a>this&amp;super</h3><br/><p>this对象表示的是当前的对象的一个引用，这个在php和c++中已经解释过了</p><p>不过c++并没有取消指针，所以使用的是this指针，而Java中可以直接用this调用，算是比较方便的一个点</p><p>特别的，在构造方法中，通过this关键字调用其他构造方法时，必须放在第一行，否则编译器会报错。且在构造方法中，只能通过this调用一次其他构造方法。编译器会自动添加<code>this()</code>，不需要手动写出来</p><br/><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Animal &#123;        private String name;    private int age;    public Animal()&#123;        System.out.println(&quot;动物属于地球&quot;);    &#125;    public void run()&#123;        System.out.println(&quot;动物有不同的走路方法&quot;);    &#125;    public void setName(String name) &#123;                this.name &#x3D; name;            &#125;        public void setAge(int age)&#123;                this.age &#x3D; age;            &#125;    public String getName() &#123;                return name;            &#125;    public int getAge() &#123;                return age;            &#125;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>super则是专门指向父类的引用，如果没有明确父类的构造方法，编译器会自动添加<code>super()</code></p><p>如果想调用父类的对象，可以直接使用super进行调用</p><p>定义一个子类对象时，先调用子类构造函数，再调用父类构造函数，一直调用到最终的父类构造函数</p><br/><h3 id="覆写"><a href="#覆写" class="headerlink" title="覆写"></a>覆写</h3><br/><p>如果你对父类的对象不满意，可以对其进行”覆盖“</p><p>可以再对象面前加上<code>@override</code>关键字，表示一种强调</p><br/><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Bird extends Animal &#123;    public Bird()&#123;        System.out.println(&quot;鸟类属于动物的一种&quot;);    &#125;    @Override    public void run()&#123;        super.run();&#x2F;&#x2F;调用父类的run对象        System.out.println(&quot;鸟还可以飞&quot;);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++ 类的使用</title>
      <link href="2021/03/11/c-%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>2021/03/11/c-%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h3><br/><p>运算符重载允许c++运算符用于类对象，是一种形式的c++多态</p><p>c++可以使用+来使两个对象相加，编译器将根据操作数的数目和类型决定使用哪种加法定义</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;例如，一般将数组相加需要使用for循环for(int i &#x3D; 0; i &lt; 20; i ++)&#123;evening[i] &#x3D; sam[i] + janet[i];    &#125;&#x2F;&#x2F;c++中可以定义一个表示数组的类，并重载+运算符evening &#x3D; sam + janet;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>想要让运算符重载，需要<code>operator+()重载+运算符</code></p><p>如果你定义了一个这样的成员函数，你可以通过一般的调用方式，也可以重载</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;一般的运算符的处理方式Time Time :: sum(const Time &amp; t) const&#123;&#x2F;&#x2F;构建Time类的对象，实现同类型对象相加    Time sum;    sum.minutes &#x3D; minutes + t.minutes;    sum.hours &#x3D; hours + t.hours + sum.minutes &#x2F; 60;    sum.minutes %&#x3D; 60;    return sum;&#125;&#x2F;&#x2F;主函数中调用语句Time total;total &#x3D; b.sum(c);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">Time Time :: operator+(const Time &amp; t) const&#123;&#x2F;&#x2F;operator + 表示加法重载    Time sum;    sum.minutes &#x3D; minutes + t.minutes;    sum.hours &#x3D; hours + t.hours + sum.minutes &#x2F; 60;    sum.minutes %&#x3D; 60;    return sum;&#125;total &#x3D; b + c;&#x2F;&#x2F;这里使用total &#x3D; b.operator(c);也是ok的，不过运算符重载让程序更加简洁total.show();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>你甚至可以a + b + c + d</p><p>系统是默认判断多重重载的，所以此句子是合法的</p><br/><h3 id="重载限制"><a href="#重载限制" class="headerlink" title="重载限制"></a>重载限制</h3><br/><p>1.重载后的运算符至少有一个操作数是用户定义的类型，防止用户重载标准运算符</p><p>因此，你不能用-重载来表示两个数字的和，而不是差，这样的限制保证了程序的正常运行</p><p>2.重载之后不能违背原来的运算法则</p><p>3.不能使用重载凭空创造一个运算法则出来</p><p>4.有些像指针之类的是不能被重载的</p><p>5.= -&gt; () []只能通过成员函数进行重载，一般的运算符也可以使用非成员函数重载</p><br/><h3 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h3><br/><p>上述举了运算符重载的例子中，如果我们定义两个Time类的对象A、B</p><p>执行重载语句<code>A = B * 2.5</code> 或 <code>A = B.operator(2.5)</code> 是完全没有问题的</p><p>但是如果写成 <code>A = 2.5 * B</code> 就会报错</p><br/><p>创建友元函数的第一步，就是用friend定义类中的声明</p><p><code>friend Time operator*(const Time &amp; t);</code>（该定义的函数不是成员函数，所以无法使用const限定符）</p><p>虽然友元函数不是成员函数，但是权限和成员函数一样</p><br/><p>在编写函数定义时，因为不是成员函数，所以不需要添加Time :: 限定符</p><p>当然，后面的const也是不能加的（另外，不要在定义中使用friend关键词）</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">Time operator*(double m, const Time &amp; t)&#123;&#x2F;&#x2F;定义函数不能使用friend    Time result;    int totalminutes &#x3D; t.hours * m * 60 + t.minutes * m;        result.minutes &#x3D; totalminutes % 60;    result.hours &#x3D; totalminutes &#x2F; 60;        return result;    &#125;total &#x3D; 2.75 * b;&#x2F;&#x2F;重载之后，相当于operator*(2.75,)total.show();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><h3 id="常用友元：重载-lt-lt-运算符"><a href="#常用友元：重载-lt-lt-运算符" class="headerlink" title="常用友元：重载&lt;&lt;运算符"></a>常用友元：重载&lt;&lt;运算符</h3><br/><p>cout是一个<code>ostream</code>对象，是能智能识别所有c++基本类型</p><p>当然，想要重载需要cout识别Time对象，一种方法是直接将对象添加到ostream中，但是这样修改系统很容易造成c++整体出现错误，所以我们便通过Time声明来使用cout</p><br/><p>1.如果是这样的重载写成<code>cout &lt;&lt; trip</code>必须使用友元</p><p>因为如果使用的一般的重载，正确的格式应该是<code>trip &lt;&lt; cout</code>，毕竟是让Time类重载</p><p>使用友元的话，顺序奇怪的问题就解决了</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">friend void operator&lt;&lt;(ostream &amp; os, const Time &amp; t);&#x2F;&#x2F;友元声明void operator&lt;&lt;(ostream &amp; os, const Time &amp; t)&#123;    os &lt;&lt; &quot;hours: &quot; &lt;&lt; t.hours &lt;&lt; &quot; minutes: &quot; &lt;&lt; t.minutes &lt;&lt; endl;&#x2F;&#x2F;os输出重载定义&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>新的Time类声明使operator&lt;&lt;()函数称为Time类</p><p>因为operator&lt;&lt;()可以直接访问Time对象的私有成员，所以其必须使用友元</p><br/><p>2.刚刚那种方法有一种弊端，就是无法让cout和其他字符串等一起使用</p><p><code>cout &lt;&lt; &quot;Trip time:&quot; &lt;&lt; trip &lt;&lt; &quot; cxy&quot; &lt;&lt; endl;</code>这种句子会报错</p><p>这里，我们需要先了解以下cout的机制，即在一些连续输入情况时，具体判定标准</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int x &#x3D; 5, y &#x3D; 8;cout &lt;&lt; x &lt;&lt; y;&#x2F;&#x2F;相当于(cout &lt;&lt; x) &lt;&lt; y;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><br/><p>因为cout &lt;&lt; x 位于 &lt;&lt; y 的左侧，所以输出也是相当于ostream的对象</p><p>因此cout &lt;&lt; x 本身就是ostream的对象，所以可以使用&lt;&lt;</p><p>同理，我们需要重载的字符串返回一个ostream的对象的引用</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">friend ostream &amp; operator&lt;&lt;(ostream &amp; os, const Time &amp; t);&#x2F;&#x2F;声明操作的函数，使其返回ostream对象的引用ostream &amp; operator&lt;&lt;(ostream &amp; os, const Time &amp; t)&#123;&#x2F;&#x2F;应用可以使变量改变，但不会有指针的那么多安全问题    os &lt;&lt; &quot;hours: &quot; &lt;&lt; t.hours &lt;&lt; &quot; minutes: &quot; &lt;&lt; t.minutes &lt;&lt; endl;       return os;&#125;cout &lt;&lt; &quot;cxy: &quot; &lt;&lt; total &lt;&lt; endl;&#x2F;&#x2F;这样就可添加其他东西了<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++ 类和对象</title>
      <link href="2021/03/07/c-%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/"/>
      <url>2021/03/07/c-%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h3 id="类与对象的概念"><a href="#类与对象的概念" class="headerlink" title="类与对象的概念"></a>类与对象的概念</h3><br/><p>一般来说，类规范由两个部分组成</p><p>1.类声明：以数据成员的方式描述数据部分，以成员函数的方式描述公有接口</p><p>2.类方法定义：描述如何实现类成员函数</p><br/><h4 id="私有公有"><a href="#私有公有" class="headerlink" title="私有公有"></a>私有公有</h4><br/><p>c++定义私有和公有的方式相比于Java而言，还是有小部分区别</p><p>数据定义为私有，成员函数定义为公有</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Count&#123;        private:    string company;    double price_val;    static int num_string;        public:    void buy(double price);    void nice(int number);    void kk();   &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><h4 id="静态类成员"><a href="#静态类成员" class="headerlink" title="静态类成员"></a>静态类成员</h4><br/><p>上述例子中，我定义了一个静态的类成员</p><p>这样规定有一个特点，静态类成员共享一个副本（如果我创建多个Count类，其他的成员都会新建副本，但是该静态成员共用一个）</p><p>不能说c++的静态对象就是为了扩大作用域</p><br/><h4 id="类成员函数"><a href="#类成员函数" class="headerlink" title="类成员函数"></a>类成员函数</h4><br/><p>定义成员函数时，使作用域解析运算符”::”来标识所属的类</p><p>类方法可以访问类的private组件</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void Count :: buy(double price)&#x2F;&#x2F;标记表示buy是Count类的成员<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br/><p>想使用这些对象，首先要创建对象</p><p>最简单的方法就是声明类变量，最后像Java一样调用</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">Count a, b;a.kk();b.kk();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><br/><h3 id="类的构造函数和析构函数"><a href="#类的构造函数和析构函数" class="headerlink" title="类的构造函数和析构函数"></a>类的构造函数和析构函数</h3><br/><p>对类中定义私有的对象不能直接访问</p><p>（如果改成公有，虽然可以方便，但是违背了类的初衷-数据初衷）</p><p>这就需要一个特殊的函数-类构造函数，专门构造新对象，将值赋给它们的数据成员</p><br/><h4 id="声明和定义构造函数"><a href="#声明和定义构造函数" class="headerlink" title="声明和定义构造函数"></a>声明和定义构造函数</h4><br/><p>在定义构造函数时，不能创建的变量名不能等于成员变量</p><p>为了避免这种，在数据成员中有加前缀或后缀的情况</p><p>1.使用”m_”前缀 <code>m_company</code></p><p>2.使用”_”后缀 <code>company_</code></p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Line&#123;   public:        void setLength(double len);        double getLength(void);        Line(const string company);&#x2F;&#x2F; 这是构造函数     private:        double length;        string company;&#125;;&#x2F;&#x2F; 成员函数定义，包括构造函数Line::Line(const string company)&#123;    cout &lt;&lt; &quot;Object is being created&quot; &lt;&lt; endl;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>构造函数的名称与类的名称是完全相同的，并且不会返回任何类型，也不会返回 void</p><p>构造函数可用于为某些成员变量设置初始值</p><br/><h4 id="使用构造函数"><a href="#使用构造函数" class="headerlink" title="使用构造函数"></a>使用构造函数</h4><br/><p>对一个封装的成员数据，是不能直接定义类变量修改值的</p><p>这种面向对象程序的特点，就是使用set，get来进行更改和输出（Java等都是一样的）</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void Line::setLength(double len)&#123;    length &#x3D; len;&#125; double Line::getLength(void)&#123;    return length;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><h4 id="默认构造函数"><a href="#默认构造函数" class="headerlink" title="默认构造函数"></a>默认构造函数</h4><br/><p>默认构造函数，即不提供初始值来创建对象的构造函数</p><p>默认构造函数没有参数，声明中不含值</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Stock&#123;private:    string company;    double shares;    int number;        public:    Stock();    void sell(const string &amp; co, double s, int num);    &#125;Stock::Stock()&#123;        company &#x3D; &quot;no name&quot;;    shares &#x3D; 0.0;    number &#x3D; 0;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><h4 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h4><br/><p>类的析构函数是类的一种特殊的成员函数，它会在每次删除所创建的对象时执行</p><p>析构函数的名称与类的名称是完全相同的，只是在前面加了个波浪号（~）作为前缀，它不会返回任何值，也不能带有任何参数</p><p>析构函数有助于在跳出程序（比如关闭文件、释放内存等）前释放资源,像是如果有构造函数用new来创建内存，析构函数就会使用delete</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class Line&#123;       public:     void setLength(double len);     double getLength(void);    void show();      Line();        ~Line();&#x2F;&#x2F; 这是析构函数声明    private:      double length;    &#125;;Line::~Line(void)&#123;        cout &lt;&lt; &quot;Object is being deleted&quot; &lt;&lt; endl;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><h3 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h3><br/><p>在 C++ 中，每一个对象都能通过this指针来访问自己的地址</p><p>this指针是所有成员函数的隐含参数。因此，在成员函数内部，它可以用来指向调用对象</p><p>（在函数的括号后面使用const限定符讲this限定为const，这样不能使用this来修改对象的值）</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void Line :: Setlength(double length)&#123;    this-&gt;length &#x3D; length;&#125;double Line :: Getlength(void)&#123;    return length;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>通过this指针，指向原本类中的成员变量</p><p>（这里一看，可能觉得很想结构体的写法）</p><p>在这里，题型一下，学习一门语言不要学学停停，不然很容易串味（x</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;成员函数（内联函数）&#x2F;&#x2F;inline double total() constdouble total() const&#123;return total_val;&#125;const Stock &amp; Stock :: topval(const Stock &amp; s) const&#123;    ...    &#x2F;&#x2F;如果不使用this指针，难以用不同的对象访问类        &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><h3 id="对象数组"><a href="#对象数组" class="headerlink" title="对象数组"></a>对象数组</h3><br/><p>当然，我们创建对象并不是每次都创建单体，有时直接定义多个对象，可以是使用对象数组</p><p>不过，这就越来越像结构体了（以前刚接触Java类与对象时，还没有c的经验，当时学的实在是太痛苦了）</p><p>数组中的每个元素都是类的对象，也就可以访问类中方法</p><br/><h3 id="类的作用域"><a href="#类的作用域" class="headerlink" title="类的作用域"></a>类的作用域</h3><br/><h4 id="定义常量"><a href="#定义常量" class="headerlink" title="定义常量"></a>定义常量</h4><br/><p>如果想在类中定义一个常量，不能直接使用<code>const int Month = 12;</code></p><p>这种声明知识描述了对象的形式，并没有创建对象，c++提供了两种方式创建类常量</p><p>1.声明一个枚举（一般推荐使用这个，原因后面的文章会有提及，优于define）</p><p>2.在前面加上<code>static</code>修饰</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">class A&#123;        private:    static int x;&#x2F;&#x2F;类中不能直接对数据进行初始化        public:    ...            &#125;;int A :: x &#x3D; 100;&#x2F;&#x2F;在这里初始化的时候不需要使用关键词static<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><h4 id="静态成员函数"><a href="#静态成员函数" class="headerlink" title="静态成员函数"></a>静态成员函数</h4><br/><p>将某个成员函数声明为static，只能访问静态数据成员</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#ifndef STATICCPP_H#define STATICCPP_H#include &lt;iostream&gt;using namespace std;class A&#123;    private:        static int x;        int y;        public:        A(int yy &#x3D; 0) : y(yy)&#123;&#125;        static void Print();&#125;;int A :: x &#x3D; 100;void A :: Print()&#123;&#x2F;&#x2F;在方法的定义中不使用static关键字    cout &lt;&lt; x &lt;&lt; endl;    &#x2F;&#x2F;cout &lt;&lt; y; 使用这个代码会报无法调用的错误&#125;#endif<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><h4 id="常对象"><a href="#常对象" class="headerlink" title="常对象"></a>常对象</h4><br/><p>类和对象中可以创建一个固定的对象，一般用作测试使用</p><p><code>const A a(&quot;cxy&quot;, 18);</code></p><br/><h4 id="常数据成员"><a href="#常数据成员" class="headerlink" title="常数据成员"></a>常数据成员</h4><br/><p>const的定义也适用于类中的私有数据，要注意的是，这种数据只能在构造函数使用初始化列表的方式来进行初始化</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#ifndef CONSTCPP_H#define CONSTCPP_H#include &lt;iostream&gt;using namespace std;class Student&#123;    private:        const string name;        const double socres;    public:        Student(string na &#x3D; &quot;NoName&quot;, double s &#x3D; 100) : name(na), socres(s)&#123; cout &lt;&lt; &quot;called completed&quot; &lt;&lt; endl;&#125;        ~Student()&#123; cout &lt;&lt; &quot;deleted completed&quot; &lt;&lt; endl;&#125;        void display() const;&#125;;#endif#include &quot;ConstCpp.h&quot;void Student :: display() const&#123;    cout &lt;&lt; socres &#x2F; 2 &lt;&lt; endl;    &#125;#include &quot;ConstCpp.h&quot;#include &quot;ConstCpp.cpp&quot;int main()&#123;    const Student stu(&quot;cxy&quot;, 75);    stu.display();    return 0;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><h4 id="常成员函数"><a href="#常成员函数" class="headerlink" title="常成员函数"></a>常成员函数</h4><br/><p>正如常对象所阐述的一样，如果直接定义一个const的类变量，想要直接调用成员函数是不被允许的</p><p>因为计算机比较“笨”，不会判断里面的东西是否有对值的修改</p><p>（讲得专业一些，就是在成员函数中是会隐式调用this指针的，而const设定为一个常指针，所以这样写会出现问题）</p><p>可以对方法定一个常量，保证对内部的值不会修改</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">const Stock a &#x3D; Stock(&quot;King Land&quot;);land.show();&#x2F;&#x2F;wrong&#x2F;&#x2F;需要改成这样void show() const;void stock :: show() const&#123;        ......        &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>接受一个参数的构造函数允许使用赋值语法将对象初始化一个值</p><p>这个特性可能会导致问题，不过可以关闭</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>正则表达式</title>
      <link href="2021/03/05/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>2021/03/05/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>本文章的内容，援引自<a href="https://www.cnblogs.com/zery/p/3438845.html">某博客</a></p><br/><h3 id="一-前言"><a href="#一-前言" class="headerlink" title="一 前言"></a>一 前言</h3><br/><p>　　对于正则表达式，相信很多人都知道，但是很多人的第一感觉就是难学，因为看第一眼时，觉得完全没有规律可寻，而且全是一堆各种各样的特殊符号，完全不知所云。</p><p>其实只是对正则不了解而以，了解了你就会发现，原来就这样啊正则所用的相关字符其实不多，也不难记，更不难懂，唯一难的就是组合起来之后，可读性比较差，而且不容易理解，本文旨在让大家对正则有一个基本的了解，能看得懂简单的正则表达式，写得出简单的正则表达式，用以满足日常开发中的需求即可。</p><p>0\d{2}-\d{8}|0\d{3}-\d{7} 先来一段正则，如果你对正则不了解，是不是完全不知道这一串字符是什么意思？这不要紧文章会详细解释每个字符的含义的。</p> <br/><p><strong>1.1 什么是正则表达式</strong></p><br/><p>   正则表达式是一种特殊的字符串模式，用于匹配一组字符串，就好比用模具做产品，而正则就是这个模具，定义一种规则去匹配符合规则的字符。</p><br/><p><strong>1.2 常用的正则匹配工具</strong> </p><br/><p>   在线匹配工具：</p><p>　1 <a href="http://www.regexpal.com/">http://www.regexpal.com/</a> </p><p>   2 <a href="http://rubular.com/">http://rubular.com/</a> </p><p>   正则匹配软件</p><p>   <a href="http://pan.baidu.com/s/19Yn49">McTracer</a> </p><p>   用过几个之后还是觉得这个是最好用的，支持将正则导成对应的语言如java C# js等还帮你转义了，Copy直接用就行了很方便，另外支持把正则表达式用法解释，如哪一段是捕获分组，哪段是贪婪匹配等等，总之用起来 So Happy .</p> <br/><h3 id="二-正则字符简单介绍"><a href="#二-正则字符简单介绍" class="headerlink" title="二 正则字符简单介绍"></a>二 正则字符简单介绍</h3><br/><p><strong>2.1 元字符介绍</strong></p><br/><p>  <strong>“^”</strong> ：^会匹配行或者字符串的起始位置，有时还会匹配整个文档的起始位置。 </p><p>  <strong>“$”</strong> ：$会匹配行或字符串的结尾</p><br/><p>​     而且被匹配的字符必须是以This开头有空格也不行，必须以Regex结尾，也不能有空格与其它字符</p><p><img src="https://images0.cnblogs.com/blog/366784/201311/23112422-56df0ef3f54c42abb55e7cabd5278824.png" alt="img">   <img src="https://images0.cnblogs.com/blog/366784/201311/23112601-f5e9f5c0ddd7417eb28ac7d0734f8b8f.png" alt="img"></p> <br/><p> <strong>“\b”</strong> :不会消耗任何字符只匹配一个位置，常用于匹配单词边界 如 我想从字符串中”This is Regex”匹配单独的单词 “is” 正则就要写成 “\bis\b”  </p><p>　　  \b 不会匹配is 两边的字符，但它会识别is 两边是否为单词的边界 </p><p> <strong>“\d”</strong>: 匹配数字，</p><p>　　  例如要匹配一个固定格式的电话号码以0开头前4位后7位，如0737-5686123  正则:^0\d\d\d-\d\d\d\d\d\d\d$ 这里只是为了介绍”\d”字符，实际上有更好的写法会在   下面介绍。</p><p> **”\w”**：匹配字母，数字，下划线.</p><p>　　  例如我要匹配”a2345BCD__TTz” 正则：”\w+”  这里的”+”字符为一个量词指重复的次数，稍后会详细介绍。</p><p> **”\s”**：匹配空格 </p><p>　　  例如字符 “a b c” 正则：”\w\s\w\s\w”  一个字符后跟一个空格，如有字符间有多个空格直接把”\s” 写成 “\s+” 让空格重复</p><p> **”.”**：匹配除了换行符以外的任何字符</p><p>　　  这个算是”\w”的加强版了”\w”不能匹配 空格 如果把字符串加上空格用”\w”就受限了，看下用 “.”是如何匹配字符”a23 4 5 B C D__TTz”  正则：”.+”</p><p> <strong>“[abc]”</strong>: 字符组  匹配包含括号内元素的字符 </p><p>​    这个比较简单了只匹配括号内存在的字符，还可以写成[a-z]匹配a至z的所以字母就等于可以用来控制只能输入英文了，</p> <br/><p><strong>2.2 几种反义</strong></p><br/><p>　　<strong>写法很简单改成大写就行了，意思与原来的相反，这里就不举例子了</strong></p><p>  <strong>“\W”</strong> 匹配任意不是字母，数字，下划线 的字符</p><p>  <strong>“\S”</strong>  匹配任意不是空白符的字符</p><p>　<strong>“\D”</strong> 匹配任意非数字的字符</p><p>  <strong>“\B”</strong> 匹配不是单词开头或结束的位置</p><p>  <strong>“[^abc]”</strong> 匹配除了abc以外的任意字符</p> <br/><p> <strong>2.3  量词</strong></p><br/><p>　　先解释关于量词所涉及到的重要的三个概念</p><p>  贪婪(贪心) 如”*”字符 贪婪量词会首先匹配整个字符串，尝试匹配时，它会选定尽可能多的内容，如果 失败则回退一个字符，然后再次尝试回退的过程就叫做回溯，它会每次回退一个字符，直到找到匹配的内容或者没有字符可以回退。相比下面两种贪婪量词对资源的消耗是最大的，</p><p>  懒惰(勉强) 如 “?”  懒惰量词使用另一种方式匹配，它从目标的起始位置开始尝试匹配，每次检查一个字符，并寻找它要匹配的内容，如此循环直到字符结尾处。</p><p>  占有  如”+” 占有量词会覆盖事个目标字符串，然后尝试寻找匹配内容 ，但它只尝试一次，不会回溯，就好比先抓一把石头，然后从石头中挑出黄金</p><br/><p>   <strong>“*“(贪婪)</strong>  <strong>重复零次或更多</strong></p><p>　　　  例如”aaaaaaaa” 匹配字符串中所有的a  正则： “a*”  会出到所有的字符”a”</p><br/><p>   <strong>“+”(懒惰)</strong>  <strong>重复一次或更多次</strong></p><p>　　   例如”aaaaaaaa” 匹配字符串中所有的a  正则： “a+”  会取到字符中所有的a字符，  “a+”与”a*”不同在于”+”至少是一次而”*” 可以是0次，</p><p>　　   稍后会与”?”字符结合来体现这种区别</p><br/><p>   <strong>“?”(占有)</strong>  重复零次或一次</p><p>　　   例如”aaaaaaaa” 匹配字符串中的a 正则 ： “a?” 只会匹配一次，也就是结果只是单个字符a</p><br/><p>　  <strong>“{n}”</strong> 重复n次</p><p>　　   例如从”aaaaaaaa” 匹配字符串的a 并重复3次 正则：  “a{3}”  结果就是取到3个a字符  “aaa”;</p><br/><p>　  <strong>“{n,m}”</strong> 重复n到m次</p><p>　　   例如正则 “a{3,4}” 将a重复匹配3次或者4次 所以供匹配的字符可以是三个”aaa”也可以是四个”aaaa” 正则都可以匹配到</p><br/><p>   <strong>“{n,}”</strong> 重复n次或更多次</p><p> 　   与{n,m}不同之处就在于匹配的次数将没有上限，但至少要重复n次 如 正则”a{3,}” a至少要重复3次</p><p> 把量词了解了之后之前匹配电话号码的正则现在就可以改得简单点了^0\d\d\d-\d\d\d\d\d\d\d$ 可以改为”^0\d+-\d{7}$”。</p><p>这样写还不够完美如果因为前面的区号没有做限定，以至于可以输入很多们，而通常只能是3位或者4位，</p><p>现在再改一下 “^0\d{2,3}-\d{7}”如此一来区号部分就可以匹配3位或者4位的了</p><br/><p> <strong>2.4 懒惰限定符</strong></p><p>　　<strong>“*?”</strong>  重复任意次，但尽可能少重复 </p><p>　　   如 “acbacb”  正则  “a.*?b” 只会取到第一个”acb” 原本可以全部取到但加了限定符后，只会匹配尽可能少的字符 ，而”acbacb”最少字符的结果就是”acb” </p><p>　　<strong>“+?”</strong> 重复1次或更多次，但尽可能少重复</p><p>　　  与上面一样，只是至少要重复1次</p><p>　　<strong>“??”</strong> 重复0次或1次，但尽可能少重复</p><p>　　   如 “aaacb” 正则 “a.??b” 只会取到最后的三个字符”acb”</p><p>　　<strong>“{n,m}?”</strong> 重复n到m次，但尽可能少重复</p><p>​     如 “aaaaaaaa”  正则 “a{0,m}” 因为最少是0次所以取到结果为空</p><p>　　<strong>“{n,}?”</strong>   重复n次以上，但尽可能少重复</p><p>​     如 “aaaaaaa”  正则 “a{1,}” 最少是1次所以取到结果为 “a”</p> <br/><h3 id="三-正则进阶"><a href="#三-正则进阶" class="headerlink" title="三  正则进阶"></a>三  正则进阶</h3><br/><p>   <strong>3.1 捕获分组</strong></p><p>　　先了解在正则中捕获分组的概念，其实就是一个括号内的内容 如 “(\d)\d” 而”(\d)” 这就是一个捕获分组，可以对捕获分组进行 后向引用 (如果后而有相同的内容则可以直接引用前面定义的捕获组，以简化表达式) 如(\d)\d\1 这里的”\1”就是对”(\d)”的后向引用</p><p>那捕获分组有什么用呢看个例子就知道了</p><p>如  “zery zery” 正则 \b(\w+)\b\s\1\b 所以这里的”\1”所捕获到的字符也是 与(\w+)一样的”zery”，为了让组名更有意义，组名是可以自定义名字的</p><p>“\b(?<name>\w+)\b\s\k<name>\b” 用”?<name>“就可以自定义组名了而要后向引用组时要记得写成 “\k<name>“;自定义组名后,捕获组中匹配到的值就会保存在定义的组名里</p><p>下面列出捕获分组常有的用法</p> <br/><p><strong>“(exp)”</strong>   匹配exp,并捕获文本到自动命名的组里</p><p><strong>“(?<name>exp)”</strong>  匹配exp,并捕获文本到名称为name的组里</p><p><strong>“(?:exp)”</strong> 匹配exp,不捕获匹配的文本，也不给此分组分配组号</p><p>以下为零宽断言</p><p><strong>“(?=exp)”</strong> 匹配exp前面的位置</p><p>　　如 “How are you doing” 正则”(?<txt>.+(?=ing))” 这里取ing前所有的字符，并定义了一个捕获分组名字为 “txt” 而”txt”这个组里的值为”How are you do”;</p><p><strong>“(?&lt;=exp)”</strong> 匹配exp后面的位置</p><p>　　如 “How are you doing” 正则”(?<txt>(?&lt;=How).+)” 这里取”How”之后所有的字符，并定义了一个捕获分组名字为 “txt” 而”txt”这个组里的值为” are you doing”;</p><p><strong>“(?!exp)”</strong> 匹配后面跟的不是exp的位置</p><p>　　如 “123abc” 正则 “\d{3}(?!\d)”匹配3位数字后非数字的结果</p><p><strong>“(?&lt;!exp)”</strong> 匹配前面不是exp的位置</p><p>　　如 “abc123 “ 正则 “(?&lt;![0-9])123” 匹配”123”前面是非数字的结果也可写成”(?!&lt;\d)123”</p> <br/><h3 id="四-正则实战"><a href="#四-正则实战" class="headerlink" title="四  正则实战"></a>四  正则实战</h3><br/><p>　　正则在做验证，与数据过滤时体现的威力是巨大的，我想用过的朋友都知道，下面我们把刚刚了解的全部结合起来做一次实战 做数据采集用正则过滤Html标签并取相应的数据</p><p>我们的战场就选在博客园吧，假设现在要采集博客园首页的所有文章信息 包括文章标题，链接接 作者博客地址，文章简介，文章发布时间，阅读数据，评论数 ，推荐数。</p> <br/><p>先看博客园文章的Html格式</p><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>post_item<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>digg<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>diggit<span class="token punctuation">"</span></span> <span class="token attr-name">onclick</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>DiggIt(3439076,120879,1)<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>diggnum<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>digg_count_3439076<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>4<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>clear<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>digg_tip_3439076<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>digg_tip<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>post_item_body<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h3</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>titlelnk<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.cnblogs.com/swq6413/p/3439076.html<span class="token punctuation">"</span></span> <span class="token attr-name">target</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>_blank<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>分享完整的项目工程目录结构<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h3</span><span class="token punctuation">></span></span>                       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>post_item_summary<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.cnblogs.com/swq6413/<span class="token punctuation">"</span></span> <span class="token attr-name">target</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>_blank<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">width</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>48<span class="token punctuation">"</span></span> <span class="token attr-name">height</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>48<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>pfs<span class="token punctuation">"</span></span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://pic.cnitblog.com/face/142964/20131116170946.png<span class="token punctuation">"</span></span> <span class="token attr-name">alt</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span>    在项目开发过程中，如何有序的保存项目中的各类数据文件，建立一个分类清晰、方便管理的目录结构是非常重要的。 综合以前的项目和一些朋友的项目结构，我整理了一份我觉得还不错的项目目录结构。 在这里分享给大家，欢迎各位提出你宝贵的意见和建议。如果喜欢请“推荐”则个，感激万分！！ 整个目录设置到4级子目录，实...     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>                  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>post_item_foot<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>                        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.cnblogs.com/swq6413/<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>lightblue<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>七少爷<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span>     发布于 2013-11-23 15:48     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>article_comment<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.cnblogs.com/swq6413/p/3439076.html#commentform<span class="token punctuation">"</span></span> <span class="token attr-name">title</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>2013-11-23 16:40<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>gray<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>        评论(4)<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>article_view<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.cnblogs.com/swq6413/p/3439076.html<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>gray<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>阅读(206)<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>clear<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre> <br/><p> 通过构造一个Http请求来取到数据并对数据进行相应处理得到关键信息，在过滤Html标签取文章时正则的强大的威力就体现出来了，</p><p>正则的知识点也都基本用上了比如 “\s \w+ . * ? “还有捕获分组，零宽断言等等。喜欢的朋友可以试一试，然后自己看如何通过正则取相应数据的，代码中的正则都是很基本简单的，其意思与用法都在上文中详细写了。</p> <br/><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Program&#123;    static void Main(string[] args)    &#123;             string content &#x3D; HttpUtility.HttpGetHtml();        HttpUtility.GetArticles(content);    &#125;&#125;internal class HttpUtility&#123;    &#x2F;&#x2F;默认获取第一页数据    public static string HttpGetHtml()    &#123;        HttpWebRequest request &#x3D; (HttpWebRequest)WebRequest.Create(&quot;http:&#x2F;&#x2F;www.cnblogs.com&#x2F;&quot;);        request.Accept &#x3D; &quot;text&#x2F;plain, *&#x2F;*; q&#x3D;0.01&quot;;        request.Method &#x3D; &quot;GET&quot;;        request.Headers.Add(&quot;Accept-Language&quot;, &quot;zh-cn,zh;q&#x3D;0.8,en-us;q&#x3D;0.5,en;q&#x3D;0.3&quot;);        request.ContentLength &#x3D; 0;               request.Host &#x3D; &quot;www.cnblogs.com&quot;;        request.UserAgent &#x3D; &quot;Mozilla&#x2F;5.0 (Windows NT 6.1) AppleWebKit&#x2F;537.1 (KHTML, like Gecko) Maxthon&#x2F;4.1.3.5000 Chrome&#x2F;26.0.1410.43 Safari&#x2F;537.1&quot;;        HttpWebResponse response &#x3D; (HttpWebResponse)request.GetResponse();        Stream responStream &#x3D; response.GetResponseStream();        StreamReader reader &#x3D; new StreamReader(responStream, Encoding.UTF8);        string content &#x3D; reader.ReadToEnd();        return content;    &#125;    public static List&lt;Article&gt; GetArticles(string htmlString)    &#123;        List&lt;Article&gt; articleList &#x3D; new List&lt;Article&gt;();        Regex regex &#x3D; null;        Article article &#x3D; null;        regex &#x3D; new Regex(&quot;&lt;div class&#x3D;\&quot;post_item\&quot;&gt;(?&lt;content&gt;.*?)(?&#x3D;&lt;div class&#x3D;\&quot;clear\&quot;&gt;&quot; + @&quot;&lt;&#x2F;div&gt;\s*&lt;&#x2F;div&gt;)&quot;,                          RegexOptions.Singleline);        if (regex.IsMatch(htmlString))        &#123;            MatchCollection aritcles &#x3D; regex.Matches(htmlString);            foreach (Match item in aritcles)            &#123;                article &#x3D; new Article();                &#x2F;&#x2F;取推荐                regex &#x3D;                    new Regex(                        &quot;&lt;div class&#x3D;\&quot;digg\&quot;&gt;.*&lt;span.*&gt;(?&lt;digNum&gt;.*)&quot; + @&quot;&lt;&#x2F;span&gt;&quot; +                        &quot;.*&lt;div class&#x3D;\&quot;post_item_body\&quot;&gt;&quot;, RegexOptions.Singleline);                article.DiggNum &#x3D; regex.Match(item.Value).Groups[&quot;digNum&quot;].Value;                &#x2F;&#x2F;取文章标题 需要去除转义字符                regex &#x3D; new Regex(&quot;&lt;h3&gt;(?&lt;a&gt;.*)&lt;&#x2F;h3&gt;&quot;, RegexOptions.Singleline);                string a &#x3D; regex.Match(item.Value).Groups[&quot;a&quot;].Value;                regex &#x3D; new Regex(&quot;&lt;a\\s.*href&#x3D;\&quot;(?&lt;href&gt;.*?)\&quot;.*&gt;(?&lt;summary&gt;.*)&lt;&#x2F;a&gt;&quot;, RegexOptions.Singleline);                article.AritcleUrl &#x3D; regex.Match(a).Groups[&quot;href&quot;].Value;                article.AritcleTitle &#x3D; regex.Match(a).Groups[&quot;summary&quot;].Value;                &#x2F;&#x2F;取作者图片                 regex &#x3D; new Regex(&quot;&lt;a.*&gt;(?&lt;img&gt;&lt;img[^&gt;].*&gt;)&lt;&#x2F;a&gt;&quot;, RegexOptions.Singleline);                article.AuthorImg &#x3D; regex.Match(item.Value).Groups[&quot;img&quot;].Value;                &#x2F;&#x2F;取作者博客URL及链接的target属性                regex &#x3D; new Regex(&quot;&lt;a\\s*?href&#x3D;\&quot;(?&lt;href&gt;.*)\&quot;\\s*?target&#x3D;\&quot;(?&lt;target&gt;.*?)\&quot;&gt;.*&lt;&#x2F;a&gt;&quot;,                                  RegexOptions.Singleline);                article.AuthorUrl &#x3D; regex.Match(item.Value).Groups[&quot;href&quot;].Value;                string urlTarget &#x3D; regex.Match(item.Value).Groups[&quot;target&quot;].Value;                &#x2F;&#x2F;取文章简介                &#x2F;&#x2F;1 先取summary Div中所有内容                regex &#x3D; new Regex(&quot;&lt;p class&#x3D;\&quot;post_item_summary\&quot;&gt;(?&lt;summary&gt;.*)&lt;&#x2F;p&gt;&quot;, RegexOptions.Singleline);                string summary &#x3D; regex.Match(item.Value).Groups[&quot;summary&quot;].Value;                &#x2F;&#x2F;2 取简介                regex &#x3D; new Regex(&quot;(?&lt;indroduct&gt;(?&lt;&#x3D;&lt;&#x2F;a&gt;).*)&quot;, RegexOptions.Singleline);                article.AritcleInto &#x3D; regex.Match(summary).Groups[&quot;indroduct&quot;].Value;                &#x2F;&#x2F;取发布人与发布时间                regex &#x3D;                    new Regex(                        &quot;&lt;div class&#x3D;\&quot;post_item_foot\&quot;&gt;\\s*&lt;a.*?&gt;(?&lt;publishName&gt;.*)&lt;&#x2F;a&gt;(?&lt;publishTime&gt;.*)&lt;span class&#x3D;\&quot;article_comment\&quot;&gt;&quot;,                        RegexOptions.Singleline);                article.Author &#x3D; regex.Match(item.Value).Groups[&quot;publishName&quot;].Value;                article.PublishTime &#x3D; regex.Match(item.Value).Groups[&quot;publishTime&quot;].Value.Trim();                &#x2F;&#x2F;取评论数                regex &#x3D;                    new Regex(                        &quot;&lt;span class&#x3D;\&quot;article_comment\&quot;&gt;&lt;a.*&gt;(?&lt;comment&gt;.*)&lt;&#x2F;a&gt;&lt;&#x2F;span&gt;&lt;span class&#x3D;\&quot;article_view\&quot;&gt;&quot;,                        RegexOptions.Singleline);                article.CommentNum &#x3D; regex.Match(item.Value).Groups[&quot;comment&quot;].Value;                &#x2F;&#x2F;取阅读数                regex &#x3D; new Regex(&quot;&lt;span\\s*class&#x3D;\&quot;article_view\&quot;&gt;&lt;a.*&gt;(?&lt;readNum&gt;.*)&lt;&#x2F;a&gt;&quot;, RegexOptions.Singleline);                article.ReadNum &#x3D; regex.Match(item.Value).Groups[&quot;readNum&quot;].Value;                articleList.Add(article);            &#125;        &#125;        return articleList;    &#125;    public static string ClearSpecialTag(string htmlString)    &#123;        string htmlStr &#x3D; Regex.Replace(htmlString, &quot;\n&quot;, &quot;&quot;, RegexOptions.IgnoreCase);        htmlStr &#x3D; Regex.Replace(htmlStr, &quot;\t&quot;, &quot;&quot;, RegexOptions.IgnoreCase);        htmlStr &#x3D; Regex.Replace(htmlStr, &quot;\r&quot;, &quot;&quot;, RegexOptions.IgnoreCase);        htmlStr &#x3D; Regex.Replace(htmlStr, &quot;\&quot;&quot;, &quot;&#39;&quot;, RegexOptions.IgnoreCase);        return htmlStr;    &#125;&#125;public class Article&#123;    &#x2F;&#x2F;&#x2F; &lt;summary&gt;    &#x2F;&#x2F;&#x2F; 文章标题    &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;    public string AritcleTitle &#123; get; set; &#125;    &#x2F;&#x2F;&#x2F; &lt;summary&gt;    &#x2F;&#x2F;&#x2F; 文章链接    &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;    public string AritcleUrl &#123; get; set; &#125;    &#x2F;&#x2F;&#x2F; &lt;summary&gt;    &#x2F;&#x2F;&#x2F; 文章简介    &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;    public string AritcleInto &#123; get; set; &#125;    &#x2F;&#x2F;&#x2F; &lt;summary&gt;    &#x2F;&#x2F;&#x2F; 作者名    &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;    public string Author &#123; get; set; &#125;    &#x2F;&#x2F;&#x2F; &lt;summary&gt;    &#x2F;&#x2F;&#x2F; 作者地址    &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;    public string AuthorUrl &#123; get; set; &#125;    &#x2F;&#x2F;&#x2F; &lt;summary&gt;    &#x2F;&#x2F;&#x2F; 作者图片    &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;    public string AuthorImg &#123; get; set; &#125;    &#x2F;&#x2F;&#x2F; &lt;summary&gt;    &#x2F;&#x2F;&#x2F; 发布时间    &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;    public string PublishTime &#123; get; set; &#125;    &#x2F;&#x2F;&#x2F; &lt;summary&gt;    &#x2F;&#x2F;&#x2F; 推荐数    &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;    public string DiggNum &#123; get; set; &#125;    &#x2F;&#x2F;&#x2F; &lt;summary&gt;    &#x2F;&#x2F;&#x2F; 评论数    &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;    public string CommentNum &#123; get; set; &#125;    &#x2F;&#x2F;&#x2F; &lt;summary&gt;    &#x2F;&#x2F;&#x2F; 阅读数    &#x2F;&#x2F;&#x2F; &lt;&#x2F;summary&gt;    public string ReadNum &#123; get; set; &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p> 正则部分可能写得不很完美，但至少也匹配出来了，另外因为自己也是刚接触正则，也只能写出这种比较简单的正则。还望大家海涵~~</p> <br/><h3 id="五-总结"><a href="#五-总结" class="headerlink" title="五   总结"></a>五   总结</h3><br/><p>　　正则其实并不难，了解每个符号的意思后，自己马上动手试一试多写几次自然就明白了，正则是出了名的坑多，随便少写了个点就匹配不到数据了，我也踩了很多坑，踩着踩着就踩出经验了。</p><p>本文也只是对正则做了很基本的介绍，还有很多正则的字符没有介绍，只是写了比较常用的一些。如有错误之处，还望在评论中指出，我会马上修改。</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++ 引用、重载、模型和名称空间</title>
      <link href="2021/03/04/c-%E5%BC%95%E7%94%A8%E3%80%81%E9%87%8D%E8%BD%BD%E5%92%8C%E5%87%BD%E6%95%B0%E6%A8%A1%E5%9E%8B/"/>
      <url>2021/03/04/c-%E5%BC%95%E7%94%A8%E3%80%81%E9%87%8D%E8%BD%BD%E5%92%8C%E5%87%BD%E6%95%B0%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h3><br/><p>如果代码的长度很短，可以使用内联函数，可以节省一部分时间</p><p>但是节省时间其实很短，一般看不出什么差距，除非这个函数被多次调用</p><br/><p>要使用这个特性，必须采取使用以下方法之一：</p><p>​    在函数声明前加上inline</p><p>​    在函数定义前加上inline</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">inline double square(double x)&#123; return x * x; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br/><h3 id="引用变量"><a href="#引用变量" class="headerlink" title="引用变量"></a>引用变量</h3><br/><p>引用能起到指针的部分作用,但是比指针安全</p><p>一个引用可以看作是某个变量的一个”别名”。对引用进行操作就像对原变量进行操作一样</p><p>主要用于函数的参数传递时使用。因为C语言没有类似VB的“传引用调用”这个功能，所以C++的引用填补了这个空白。从此即使需要改动参数，也直接传递一个变量过去即可。这在操作符重载中有更重要的意义</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int a;  &#x2F;&#x2F;声明变量aint&amp; ra &#x3D; a; &#x2F;&#x2F;声明一个引用，名字是ra，ra引用了a<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><br/><p>注意，ra声明的时候必须同时给出它到底引用了谁<br>int&amp; ra; //只声明不指明是不对的</p><p>还有，引用一旦声明，就不能再修改到其他变量上了，这与指针不同。<br>ra = b; //这是不行的，因为已经int &amp;ra = a了</p><br/><h4 id="创建引用变量"><a href="#创建引用变量" class="headerlink" title="创建引用变量"></a>创建引用变量</h4><br/><p>‘&amp;’除了表示变量的地址之外，c++还让其可以表示引用</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int rats;int &amp; rodents &#x3D; rats<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><br/><p>看似，引用和指针很像。毕竟从直观上来看，这两个变量拥有相同的地址</p><p>但是还是有区别的，是可以针对引用变量定义对应指针的，而且声明变量时必须初始化</p><p>这样来看，引用更像const指针</p><br/><h4 id="引用的属性和特别之处"><a href="#引用的属性和特别之处" class="headerlink" title="引用的属性和特别之处"></a>引用的属性和特别之处</h4><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">double x &#x3D; 3.0;double recube(double &amp;ra)&#123;&#x2F;&#x2F;可以是传进来的变量值发生改变ra *&#x3D; ra * ra;return ra;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>ra相当于一个变量的别名，实参就是x</p><p>那么，以下代码就不合理了</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">recube(x + 3.0);&#x2F;&#x2F;这不是一个变量，所以编译器会报错<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br/><h4 id="引用作为返回值"><a href="#引用作为返回值" class="headerlink" title="引用作为返回值"></a>引用作为返回值</h4><br/><p>C++中，除了可以返回值，也可以返回一个引用</p><p>可以对函数使用引用，这样就可以使函数成为一个可以进行修改的<code>左值</code></p><p>这是C++特有的属性，这在之后的运算符重载之中也会用到，一般作为位置的变换</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;using namespace std;int &amp;Fun(const int &amp;a, int &amp;b, int c);int main()&#123;    int a &#x3D; 1, b &#x3D; 2, c &#x3D; 3;    Fun(a, b, c) &#x3D; 20;&#x2F;&#x2F;相对于b&#x3D;20;    cout &lt;&lt; b &lt;&lt; endl;    return 0;&#125;int &amp;Fun(const int &amp;a, int &amp;b, int c)&#123;    b++;    c++;    return b;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>1.&amp;不是取地址符，和定义指针变量时的*类似</p><p>2.如果不是作为函数参数，必须对引用进行初始化</p><p>3.引用被声明之后就像普通变量一样，无须再次添加&amp;符号</p><p>4.引用只是某一个变量的别名，系统不为其额外分配空间</p><p>5.不是任何类型都能使用引用，不能建立void类型引用、引用的引用、指向引用的指针、引用数组</p><br/><h4 id="临时变量"><a href="#临时变量" class="headerlink" title="临时变量"></a>临时变量</h4><br/><p>如果实参和引用参数不匹配，前提参数是const引用</p><p>编译器在以下两种情况下生成临时变量</p><p>​    实参的类型正确，但不是左值</p><p>​    实参的类型不正确，但可以转换为正确的类型</p><br/><p>（左值就是可以被引用的数据对象，例如变量、数组元素等；非左值包括字面常量和包含多项的表达式）</p><p>（常规变量属于可修改的左值，const变量属于不可修改的左值）</p><br/><h4 id="const声明的三个好处"><a href="#const声明的三个好处" class="headerlink" title="const声明的三个好处"></a>const声明的三个好处</h4><br/><p>1.const可以避免数据修改（因为引用也不能修改数据大小，const能够让编译器报错）</p><p>2.const使函数可以处理任意实参，否则只能处理非const数据</p><p>3.const引用使函数能正确生成并使用临时变量</p><p>总之，在引用的时候要多多使用const声明（如果条件允许的话，可以让安全性大大加强）</p><br/><h4 id="引用参数的使用场景"><a href="#引用参数的使用场景" class="headerlink" title="引用参数的使用场景"></a>引用参数的使用场景</h4><br/><p>使用引用参数的原因有两个</p><p>1.程序员需要修改调用函数中的数据对象</p><p>2.通过传递引用，可以提高程序运行效率</p><p>3.如果数据对象是类对象，则使用引用</p><br/><h3 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h3><br/><p>可以在声明函数时，给参数一个默认值，加快运行速度</p><p>后面调用时，也可以根据情况提供参数（设置默认参数必须要从右向左依次进行）</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int harpo(int n, int m &#x3D; 4, int j &#x3D; 5);beeps &#x3D; harpo(2);beeps &#x3D; harpo(1, 8);beeps &#x3D; harpo(8, 7, 6);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><br/><p>重载，具c++ primer所说，可以类似于“多义词”</p><p>通俗来说，你的函数声明可以有多种形态，根据内部定义，c++可以只能判断重载</p><p>（函数重载）</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void print(const char * str, int width);void print(double d, int width);void print(long l, int width);void print(int i, int width);void print(const char * str);print(&quot;cxy&quot;, 15);print(&quot;abc&quot;);print(1999.0, 10);print(1999, 12);print(1999L, 15);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><h3 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h3><br/><p>函数模板允许以任意类型的方式来定义函数</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">template &lt;typename AnyType&gt;void Swap(AnyType &amp; a, AnyType &amp; b)&#123;AnyType temp;temp &#x3D; a;a &#x3D; b;b &#x3D; temp;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><h3 id="单独编译"><a href="#单独编译" class="headerlink" title="单独编译"></a>单独编译</h3><br/><p>c++也允许和鼓励程序员将组建函数放在单独的文件中</p><p>将函数组件放在另一个单独的头文件里（.h后缀），可以将原来的程序分成三份</p><p>1.头文件：包括结构声明和使用机构的函数原型</p><p>2.源代码文件：包含与结构有关的函数代码</p><p>3.源代码文件：包含调用与结构相关的代码</p><br/><h3 id="名称空间"><a href="#名称空间" class="headerlink" title="名称空间"></a>名称空间</h3><br/><p>c++新增定义名称空间的功能，提供了一个声明名称的区域</p><p>名称空间可以是全局的，可以位于另一个名称空间中（套娃），但是不能位于代码块中</p><p>在使用名称空间是，就用using编译指令（在名称空间中也可以）</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">namespace Jack&#123;double pail;void fetch();int pal;struct Well&#123;string a;char b[];&#125;;&#125;int main()&#123;        using Jack;        cin &gt;&gt; pail;        cout &lt;&lt; pail;        return 0;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>和结构体一样，名称空间也可以没有名称，此时不能使用using</p><br/><p>使用名称空间的方法不止这一种</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">namespace one&#123;        int x;    double paper;    &#125;int a &#x3D; one::x;&#x2F;&#x2F;使用::来使x获取one名称空间using namespace one;&#x2F;&#x2F;以using在整个块程序内使用该名称空间<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>定义之后，主程序中不需要再定义对应的变量</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c/c++平时不会接触的知识点</title>
      <link href="2021/03/03/c-c-%E5%B9%B3%E6%97%B6%E4%B8%8D%E4%BC%9A%E6%8E%A5%E8%A7%A6%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
      <url>2021/03/03/c-c-%E5%B9%B3%E6%97%B6%E4%B8%8D%E4%BC%9A%E6%8E%A5%E8%A7%A6%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h3 id="1-pragmaonce这个宏有什么作用？"><a href="#1-pragmaonce这个宏有什么作用？" class="headerlink" title="1.#pragmaonce这个宏有什么作用？"></a>1.#pragmaonce这个宏有什么作用？</h3><br/><p>为了避免同一个头文件被包含（include）多次，C/C++中有两种宏实现方式：一种是#ifndef方式；另一种是#pragma once方式</p><p>在能够支持这两种方式的编译器上，二者并没有太大的区别。但两者仍然有一些细微的区别</p> <br/><h3 id="2-两者的使用方式有何区别？"><a href="#2-两者的使用方式有何区别？" class="headerlink" title="2.两者的使用方式有何区别？"></a>2.两者的使用方式有何区别？</h3><br/><p>示例代码如下：</p><p> 方式一：</p><p> #ifndef __SOMEFILE_H__</p><p>#define  __SOMEFILE_H__</p><p> … … // 声明、定义语句</p><p>#endif</p><br/><p>方式二：</p><p>#pragmaonce</p><p> … … // 声明、定义语句</p> <br/><h3 id="3．两者各有何特点？"><a href="#3．两者各有何特点？" class="headerlink" title="3．两者各有何特点？"></a>3．两者各有何特点？</h3><br/><p>（1）#ifndef</p><p> #ifndef的方式受C/C++语言标准支持。它不仅可以保证同一个文件不会被包含多次，也能保证内容完全相同的两个文件（或者代码片段）不会被</p><p>不小心同时包含</p><p> 当然，缺点就是如果不同头文件中的宏名不小心“撞车”，可能就会导致你看到头文件明明存在，但编译器却硬说找不到声明的状况——这种情况</p><p>有时非常让人郁闷</p><p> 由于编译器每次都需要打开头文件才能判定是否有重复定义，因此在编译大型项目时，ifndef会使得编译时间相对较长，因此一些编译器逐渐开始</p><p>支持#pragma once的方式</p><p>（2）#pragma once</p><p> #pragma once 一般由编译器提供保证：同一个文件不会被包含多次。注意这里所说的“同一个文件”是指物理上的一个文件，而不是指内容相同</p><p>的两个文件</p><p> <strong>你无法对一个头文件中的一段代码作pragma once声明，而只能针对文件</strong></p><p> 其好处是，你不必再担心宏名冲突了，当然也就不会出现宏名冲突引发的奇怪问题。大型项目的编译速度也因此提高了一些</p><p> 对应的缺点就是如果某个头文件有多份拷贝，本方法不能保证他们不被重复包含。当然，相比宏名冲突引发的“找不到声明”的问题，这种重复包</p><p>含很容易被发现并修正</p><p> 另外，这种方式不支持跨平台</p><br/><h3 id="4-两者之间有什么联系？"><a href="#4-两者之间有什么联系？" class="headerlink" title="4.两者之间有什么联系？"></a>4.两者之间有什么联系？</h3><br/><p> #pragma once 方式产生于#ifndef之后，因此很多人可能甚至没有听说过。目前看来#ifndef更受到推崇。因为#ifndef受C/C++语言标准的支</p><p>持，不受编译器的任何限制；</p><p> 而#pragma once方式却不受一些较老版本的编译器支持，一些支持了的编译器又打算去掉它，所以它的兼容性可能不够好</p><p> 一般而言，当程序员听到这样的话，都会选择#ifndef方式，为了努力使得自己的代码“存活”时间更久，通常宁愿降低一些编译性能，这是程序员</p><p>的个性，当然这是题外话啦</p><p> 还看到一种用法是把两者放在一起的：</p><p>   #pragma once</p><p>  #ifndef __SOMEFILE_H__</p><p>  #define __SOMEFILE_H__</p><p>  … … // 声明、定义语句</p><p>  #endif</p><p>总结：</p><p>​    看起来似乎是想兼有两者的优点。不过只要使用了#ifndef就会有宏名冲突的危险，也无法避免不支持#pragma once的编译器报错，所以混用两</p><p>种方法似乎不能带来更多的好处，倒是会让一些不熟悉的人感到困惑</p><p>​    选择哪种方式，应该在了解两种方式的情况下，视具体情况而定。只要有一个合理的约定来避开缺点，我认为哪种方式都是可以接受的。而这个</p><p>已经不是标准或者编译器的责任了，应当由程序员自己或者小范围内的开发规范来搞定</p><p>为了避免同一个文件被include多次</p><p>1  #ifndef方式</p><p>2  #pragma once方式</p><p>在能够支持这两种方式的编译器上，二者并没有太大的区别，但是两者仍然还是有一些细微的区别</p><p>  方式一：</p><p>  #ifndef __SOMEFILE_H__</p><p>  #define __SOMEFILE_H__</p><p>  … … // 一些声明语句</p><p>  #endif</p><p>  方式二：</p><p>  #pragma once</p><p>  … … // 一些声明语句</p><p>  #ifndef的方式依赖于宏名字不能冲突，这不光可以保证同一个文件不会被包含多次，也能保证内容完全相同的两个文件不会被不小心同时包含</p><p>当然，缺点就是如果不同头文件的宏名不小心“撞车”，可能就会导致头文件明明存在，编译器却硬说找不到声明的状况</p><p>  #pragma once则由编译器提供保证：同一个文件不会被包含多次。注意这里所说的“同一个文件”是指物理上的一个文件，而不是指内容相同的</p><p>两个文件。带来的好处是，你不必再费劲想个宏名了，当然也就不会出现宏名碰撞引发的奇怪问题。对应的缺点就是如果某个头文件有多份拷贝，</p><p>本方法不能保证他们不被重复包含。当然，相比宏名碰撞引发的“找不到声明”的问题，重复包含更容易被发现并修正</p><p>  方式一由语言支持所以移植性好，方式二 可以避免名字冲突</p><p>内容援引自<a href="https://www.cnblogs.com/qiang-upc/p/11407364.html">某博客园</a></p><br/><h3 id="写任务时，偶然遇到的函数"><a href="#写任务时，偶然遇到的函数" class="headerlink" title="写任务时，偶然遇到的函数"></a>写任务时，偶然遇到的函数</h3><br/><p>援引自<a href="https://blog.csdn.net/keith_bb/article/details/53055380">csdn</a></p><br/><h4 id="延时函数-sleep"><a href="#延时函数-sleep" class="headerlink" title="延时函数_sleep()"></a>延时函数_sleep()</h4><br/><p>执行该函数之后，将会在规定时间内暂停程序的运行，单位以毫秒计算</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">_sleep(1 * 1000);&#x2F;&#x2F;暂停1秒<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><br/><h4 id="计时函数clock-amp-time"><a href="#计时函数clock-amp-time" class="headerlink" title="计时函数clock()&amp;time()"></a>计时函数clock()&amp;time()</h4><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void timeConsume()&#123;    double start,stop,durationTime;    start &#x3D; clock();    &#x2F;*    ...代码片段    *&#x2F;    stop &#x3D; clock();    durationTime &#x3D; ((double)(stop-start))&#x2F;CLK_TCK;    cout &lt;&lt; &quot;程序耗时：&quot; &lt;&lt; durationTime &lt;&lt; &quot; s&quot; &lt;&lt; endl;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>clock()函数返回值类型为clock_t.该函数计算结果是以内部处理器时间为计量单位的，所以必须把它除以时钟频率，从而得到以秒为单位的时间</p><p>这种方法在机器上测量的很精确</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void timeConsume()&#123;    double start,stop,durationTime;    start &#x3D; time(NULL);    &#x2F;*    ...代码片段    *&#x2F;    stop &#x3D; time(NULL);    durationTime &#x3D; (double)difftime(stop, start);    cout &lt;&lt; &quot;程序耗时：&quot; &lt;&lt; durationTime &lt;&lt; &quot; s&quot; &lt;&lt; endl;    &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>time()函数返回值类型为time_t，所以也需要在输出前将其转换为double类型</p><p>与clock不同的是time()函数有一个参数，用来说明存放时间信息的位置</p><p>由于并不想保存这个时间，所以将参数设置为NULL。但是这种计时方法不如clock()函数精确，但是它不需要有关时钟频率的信息     </p><br/><h4 id="清屏函数system-“cls”"><a href="#清屏函数system-“cls”" class="headerlink" title="清屏函数system(“cls”)"></a>清屏函数system(“cls”)</h4><br/><p>这个函数就是能够将屏幕上的数据全部清除，纯粹是为了提高用户体验程度</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">system(&quot;cls&quot;);&#x2F;&#x2F;清除程序屏幕<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c </tag>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序算法归纳（进阶）</title>
      <link href="2021/03/02/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3%EF%BC%88%E8%BF%9B%E9%98%B6%EF%BC%89/"/>
      <url>2021/03/02/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%BD%92%E7%BA%B3%EF%BC%88%E8%BF%9B%E9%98%B6%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>算法的介绍和演示，均来自于<a href="https://www.runoob.com/cprogramming/c-sort-algorithm.html">菜鸟教程</a></p><p>补过在学会一句话排序之后，其实这些算法看不看意义已经不大了</p><br/><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><br/><p>在了解希尔排序之前，需要知道这样一个运算规则</p><p>右移运算符（&gt;&gt;）规则：</p><p>按二进制形式把所有的数字向右移动对应位移位数，低位移出(舍弃)，高位的空位补符号位，即正数补零，负数补1</p><p>计算过程：</p><p>11的二进制形式为：0000 0000 0000 0000 0000 0000 0000 1011，然后把低位的最后两个数字移出，因为该数字是正数，所以在高位补零。则</p><p>得到的最终结果是0000 0000 0000 0000 0000 0000 0000 0010。转换为十进制是2</p><p><code>数学意义：右移一位相当于除2，右移n位相当于除以2的n次方</code></p><p>参考资料来源：<a href="https://baike.baidu.com/item/c%E8%AF%AD%E8%A8%80/105958?fr=aladdin">百度百科-C语言</a></p><br/><p>希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。希尔排序是非稳定排序算法。</p><p>希尔排序是基于插入排序的以下两点性质而提出改进方法的：</p><ul><li>插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率</li><li>但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位</li></ul><br/><p><img src="https://www.runoob.com/wp-content/uploads/2018/09/Sorting_shellsort_anim.gif" alt="过程演示"></p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;bits&#x2F;stdc++.h&gt;using namespace std;void shell_sort(int arr[], int len) &#123;        int gap, i, j;    int temp;    for (gap &#x3D; len &gt;&gt; 1; gap &gt; 0; gap &#x3D; gap &gt;&gt; 1)&#123;                for (i &#x3D; gap; i &lt; len; i++) &#123;                        temp &#x3D; arr[i];                        for (j &#x3D; i - gap; j &gt;&#x3D; 0 &amp;&amp; arr[j] &gt; temp; j -&#x3D; gap)&#123;                                arr[j + gap] &#x3D; arr[j];                            &#125;                        arr[j + gap] &#x3D; temp;                    &#125;            &#125;    &#125;int main()&#123;    int a[5] &#x3D; &#123;56, 32, 6, 79, 9&#125;;    shell_sort(a, 5);    for(int i &#x3D; 0; i &lt; 5; i ++)&#123;        cout &lt;&lt; a[i] &lt;&lt; endl;            &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>本质上是将插入排序一次分成一半进行排序，然后将每次位移的大小增加</p><p>（导致插入排序效率低的原因正是一次循环只能位移一位）</p><br/><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><br/><p>把数据分为两段，从两段中逐个选最小的元素移入新数据段的末尾。</p><p>可从上到下或从下到上进行</p><br/><p><img src="https://www.runoob.com/wp-content/uploads/2018/09/Merge_sort_animation2.gif" alt="过程演示"></p><br/><p>迭代法：</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int min(int x, int y) &#123;    return x &lt; y ? x : y;&#125;void merge_sort(int arr[], int len) &#123;    int* a &#x3D; arr;    int* b &#x3D; (int*) malloc(len * sizeof(int));    int seg, start;    for (seg &#x3D; 1; seg &lt; len; seg +&#x3D; seg) &#123;        for (start &#x3D; 0; start &lt; len; start +&#x3D; seg + seg) &#123;            int low &#x3D; start, mid &#x3D; min(start + seg, len), high &#x3D; min(start + seg + seg, len);            int k &#x3D; low;            int start1 &#x3D; low, end1 &#x3D; mid;            int start2 &#x3D; mid, end2 &#x3D; high;            while (start1 &lt; end1 &amp;&amp; start2 &lt; end2)                b[k++] &#x3D; a[start1] &lt; a[start2] ? a[start1++] : a[start2++];            while (start1 &lt; end1)                b[k++] &#x3D; a[start1++];            while (start2 &lt; end2)                b[k++] &#x3D; a[start2++];        &#125;        int* temp &#x3D; a;        a &#x3D; b;        b &#x3D; temp;    &#125;    if (a !&#x3D; arr) &#123;        int i;        for (i &#x3D; 0; i &lt; len; i++)            b[i] &#x3D; a[i];        b &#x3D; a;    &#125;    free(b);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>递归法：</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void merge_sort_recursive(int arr[], int reg[], int start, int end) &#123;    if (start &gt;&#x3D; end)        return;    int len &#x3D; end - start, mid &#x3D; (len &gt;&gt; 1) + start;    int start1 &#x3D; start, end1 &#x3D; mid;    int start2 &#x3D; mid + 1, end2 &#x3D; end;    merge_sort_recursive(arr, reg, start1, end1);    merge_sort_recursive(arr, reg, start2, end2);    int k &#x3D; start;    while (start1 &lt;&#x3D; end1 &amp;&amp; start2 &lt;&#x3D; end2)        reg[k++] &#x3D; arr[start1] &lt; arr[start2] ? arr[start1++] : arr[start2++];    while (start1 &lt;&#x3D; end1)        reg[k++] &#x3D; arr[start1++];    while (start2 &lt;&#x3D; end2)        reg[k++] &#x3D; arr[start2++];    for (k &#x3D; start; k &lt;&#x3D; end; k++)        arr[k] &#x3D; reg[k];&#125;void merge_sort(int arr[], const int len) &#123;    int reg[len];    merge_sort_recursive(arr, reg, 0, len - 1);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><br/><p>在区间中随机挑选一个元素作基准，将小于基准的元素放在基准之前，大于基准的元素放在基准之后，再分别对小数区与大数区进行排序</p><p><img src="https://www.runoob.com/wp-content/uploads/2018/09/Sorting_quicksort_anim.gif" alt="过程演示"></p><br/><p>迭代法：</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">typedef struct _Range &#123;    int start, end;&#125; Range;Range new_Range(int s, int e) &#123;    Range r;    r.start &#x3D; s;    r.end &#x3D; e;    return r;&#125;void swap(int *x, int *y) &#123;    int t &#x3D; *x;    *x &#x3D; *y;    *y &#x3D; t;&#125;void quick_sort(int arr[], const int len) &#123;    if (len &lt;&#x3D; 0)        return; &#x2F;&#x2F; 避免len等於負值時引發段錯誤（Segment Fault）    &#x2F;&#x2F; r[]模擬列表,p為數量,r[p++]為push,r[--p]為pop且取得元素    Range r[len];    int p &#x3D; 0;    r[p++] &#x3D; new_Range(0, len - 1);    while (p) &#123;        Range range &#x3D; r[--p];        if (range.start &gt;&#x3D; range.end)            continue;        int mid &#x3D; arr[(range.start + range.end) &#x2F; 2]; &#x2F;&#x2F; 選取中間點為基準點        int left &#x3D; range.start, right &#x3D; range.end;        do        &#123;            while (arr[left] &lt; mid) ++left;   &#x2F;&#x2F; 檢測基準點左側是否符合要求            while (arr[right] &gt; mid) --right; &#x2F;&#x2F;檢測基準點右側是否符合要求             if (left &lt;&#x3D; right)            &#123;                swap(&amp;arr[left],&amp;arr[right]);                left++;right--;               &#x2F;&#x2F; 移動指針以繼續            &#125;        &#125; while (left &lt;&#x3D; right);         if (range.start &lt; right) r[p++] &#x3D; new_Range(range.start, right);        if (range.end &gt; left) r[p++] &#x3D; new_Range(left, range.end);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>递归法：</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void swap(int *x, int *y) &#123;    int t &#x3D; *x;    *x &#x3D; *y;    *y &#x3D; t;&#125;void quick_sort_recursive(int arr[], int start, int end) &#123;    if (start &gt;&#x3D; end)        return;    int mid &#x3D; arr[end];    int left &#x3D; start, right &#x3D; end - 1;    while (left &lt; right) &#123;        while (arr[left] &lt; mid &amp;&amp; left &lt; right)            left++;        while (arr[right] &gt;&#x3D; mid &amp;&amp; left &lt; right)            right--;        swap(&amp;arr[left], &amp;arr[right]);    &#125;    if (arr[left] &gt;&#x3D; arr[end])        swap(&amp;arr[left], &amp;arr[end]);    else        left++;    if (left)        quick_sort_recursive(arr, start, left - 1);    quick_sort_recursive(arr, left + 1, end);&#125;void quick_sort(int arr[], int len) &#123;    quick_sort_recursive(arr, 0, len - 1);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c </tag>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c/c++文件操作详解</title>
      <link href="2021/02/28/c-c-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E8%AF%A6%E8%A7%A3/"/>
      <url>2021/02/28/c-c-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>c++的fstream流已经在其他博客详细说过，这里讲一些书本上不会有的细节</p><br/><h3 id="流式文件操作"><a href="#流式文件操作" class="headerlink" title="流式文件操作"></a>流式文件操作</h3><br/><p>这种方式的文件操作有一个重要的结构FILE，FILE在stdio.h中定义如下</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">typedef struct &#123; 　　int level;　　　　　　　　　　　&#x2F;* fill&#x2F;empty level of buffer *&#x2F; 　　unsigned flags; 　　　　　　 &#x2F;* File status flags *&#x2F; 　　char fd;　　　　　　　　　　　 &#x2F;* File descriptor *&#x2F; 　　unsigned char hold;　　　　  &#x2F;* Ungetc char if no buffer *&#x2F; 　　int bsize;　　　　　　　　　　 &#x2F;* Buffer size *&#x2F; 　　unsigned char _FAR *buffer;　&#x2F;* Data transfer buffer *&#x2F; 　　unsigned char _FAR *curp;　　&#x2F;* Current active pointer *&#x2F; 　　unsigned istemp;　　　　　　&#x2F;* Temporary file indicator *&#x2F; 　　short token;　　　　　　　　  &#x2F;* Used for validity checking *&#x2F; &#125; FILE;　　　　　　　　　　　　  &#x2F;* This is the FILE object *&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>FILE这个结构包含了文件操作的基本属性，对文件的操作都要通过这个结构的指针来进行，此种文件操作常用的函数见下表 函数 功能 </p><p>　　fopen() 打开流</p><p>　　fclose() 关闭流</p><p>　　fputc() 写一个字符到流中</p><p>　　fgetc() 从流中读一个字符</p><p>　　fseek() 在流中定位到指定的字符</p><p>　　fputs() 写字符串到流</p><p>　　fgets() 从流中读一行或指定个字符</p><p>　　fprintf() 按格式输出到流</p><p>　　fscanf() 从流中按格式读取</p><p>　　feof() 到达文件尾时返回真值</p><p>　　ferror() 发生错误时返回其值</p><p>　　rewind() 复位文件定位器到文件开始处</p><p>　　remove() 删除文件</p><p>　　fread() 从流中读指定个数的字符</p><p>　　fwrite() 向流中写指定个数的字符</p><p>　　tmpfile() 生成一个临时文件流</p><p>　　tmpnam() 生成一个唯一的文件名</p><p>下面就介绍一下这些函数</p><p>1.fopen()</p><p>　　fopen的原型是：FILE *fopen(const char *filename,const char *mode)，fopen实现三个功能</p><p>　　为使用而打开一个流</p><p>　　把一个文件和此流相连接</p><p>　　给此流返回一个FILR指针</p><p>　　参数filename指向要打开的文件名，mode表示打开状态的字符串，其取值如下表</p><p>　　字符串 含义</p><p>　　“r” 以只读方式打开文件</p><p>　　“w” 以只写方式打开文件</p><p>　　“a” 以追加方式打开文件</p><p>　　“r+” 以读/写方式打开文件，如无文件出错</p><p>　　“w+” 以读/写方式打开文件，如无文件生成新文件</p><p>　　一个文件可以以文本模式或二进制模式打开，这两种的区别是：在文本模式中回车被当成一个字符’\n’，而二进制模式认为它是两个字符</p><p>0x0D,0x0A；如果在文件中读到0x1B，文本模式会认为这是文件结束符，也就是二进制模型不会对文件进行处理，而文本方式会按一定的方式对数</p><p>据作相应的转换</p><p>　　系统默认的是以文本模式打开，可以修改全部变量_fmode的值来修改这个设置，例如_fmode=O_TEXT；就设置默认打开方式为文本模式；而</p><p>_fmode=O_BINARY；则设置默认打开方式是二进制模式</p><p>　　我们也可以在模式字符串中指定打开的模式，如”rb”表示以二进制模式打开只读文件，”w+t”或”wt+”表示以文本模式打开读/写文件。</p><p>　　此函数返回一个FILE指针，所以申明一个FILE指针后不用初始化，而是用fopen()来返回一个指针并与一个特定的文件相连，如果成败，返回NULL</p><p>　　例:</p><p>　　FILE *fp;</p><p>　　if(fp=fopen(“123.456”,”wb”))</p><p>　　puts(“打开文件成功”);</p><p>　　else</p><p>　　puts(“打开文件成败”);</p><p>2.fclose()</p><p>　　fclose()的功能就是关闭用fopen()打开的文件，其原型是：int fclose(FILE *fp);如果成功，返回0,失败返回EOF</p><p>　　在程序结束时一定要记得关闭打开的文件，不然可能会造成数据丢失的情况</p><p>　　例：fclose(fp);</p><p>3.fputc()</p><p>　　向流写一个字符，原型是int fputc(int c, FILE *stream); 成功返回这个字符,失败返回EOF。</p><p>　　例：fputc(‘X’,fp);</p><p>4.fgetc()</p><p>　　从流中读一个字符，原型是int fputc(FILE *stream); 成功返回这个字符,失败返回EOF。</p><p>　　例：char ch1=fgetc(fp);</p><p>5.fseek()</p><p>　　此函数一般用于二进制模式打开的文件中，功能是定位到流中指定的位置，原型是int fseek(FILE *stream, long offset, int whence);如果成功</p><p>返回0，参数offset是移动的字符数，whence是移动的基准，取值是</p><p>　　符号常量 值 基准位置</p><p>　　SEEK_SET 0 文件开头</p><p>　　SEEK_CUR 1 当前读写的位置</p><p>　　SEEK_END 2 文件尾部</p><p>　　例：fseek(fp,1234L,SEEK_CUR);//把读写位置从当前位置向后移动1234字节(L后缀表示长整数)</p><p>　　fseek(fp,0L,2);//把读写位置移动到文件尾</p><p>6.fputs()</p><p>　　写一个字符串到流中，原型int fputs(const char *s, FILE *stream);</p><p>　　例：fputs(“I Love You”,fp);</p><p>7.fgets()</p><p>　　从流中读一行或指定个字符，原型是char *fgets(char *s, int n, FILE *stream); 从流中读取n-1个字符，除非读完一行，参数s是来接收字符</p><p>串，如果成功则返回s的指针，否则返回NULL。</p><p>　　例：如果一个文件的当前位置的文本如下</p><p>　　Love ,I Have</p><p>　　But ……..</p><p>　　如果用</p><p>　　fgets(str1,4,file1);</p><p>　　则执行后str1=”Lov”，读取了4-1=3个字符，而如果用</p><p>　　fgets(str1,23,file1);</p><p>　　则执行str=”Love ,I Have”，读取了一行(不包括行尾的’/n’)。</p><p>8.fprintf()</p><p>　　按格式输入到流，其原型是int fprintf(FILE *stream, const char *format[, argument, …]);其用法和printf()相同，不过不是写到控制台，而是写到流罢了</p><p>　　例：fprintf(fp,”%2d%s”,4,”Hahaha”);</p><p>9.fscanf()</p><p>　　从流中按格式读取，其原型是int fscanf(FILE *stream, const char *format[, address, …]);其用法和scanf()相同，不过不是从控制台读取，而</p><p>是从流读取罢了。</p><p>　　例：fscanf(fp,”%d%d” ,&amp;x,&amp;y);</p><p>10.feof()</p><p>　　检测是否已到文件尾，是返回真，否则返回0，其原型是int feof(FILE *stream);</p><p>　　例：if(feof(fp))printf(“已到文件尾”);</p><p>11.ferror()</p><p>　　原型是int ferror(FILE *stream);返回流最近的错误代码，可用clearerr()来清除它，clearerr()的原型是void clearerr(FILE *stream);</p><p>　　例：printf(“%d”,ferror(fp));</p><p>12.rewind()</p><p>　　把当前的读写位置回到文件开始，原型是void rewind(FILE *stream);其实本函数相当于fseek(fp,0L,SEEK_SET);</p><p>　　例：rewind(fp);</p><p>13.remove()</p><p>　　删除文件，原型是int remove(const char *filename); 参数就是要删除的文件名，成功返回0</p><p>　　例：remove(“c://io.sys”);</p><p>14.fread()</p><p>　　从流中读指定个数的字符，原型是size_t fread(void *ptr, size_t size, size_t n, FILE <em>stream);参数ptr是保存读取的数据，void</em>的指针可用任</p><p>何类型的指针来替换，如char*、int *等等来替换；size是每块的字节数；n是读取的块数，如果成功，返回实际读取的块数(不是字节数)，本函数一</p><p>般用于二进制模式打开的文件中。</p><p>　　例：</p><p>　　char x[4230];<br>　　FILE <em>file1=fopen(“c://msdos.sys”,”r”);<br>　　fread(x,200,12 ,file1);//共读取200</em>12=2400个字节</p><p>15.fwrite()</p><p>　　与fread对应，向流中写指定的数据，原型是size_t fwrite(const void *ptr, size_t size, size_t n, FILE <em>stream);参数ptr是要写入的数据指针，</em></p><p><em>void</em>的指针可用任何类型的指针来替换，如char*、int *等等来替换；size是每块的字节数；n是要写的块数，如果成功，返回实际写入的块数(不</p><p>是字节数)，本函数一般用于二进制模式打开的文件中。</p><p>　　例：</p><p>　　char x[]=”I Love You”;</p><p>　　fwire(x, 6,12,fp);//写入6*12=72字节</p><p>　　将把”I Love”写到流fp中12次，共72字节</p><p>16.tmpfile()</p><p>　　其原型是FILE *tmpfile(void); 生成一个临时文件，以”w+b”的模式打开，并返回这个临时流的指针，如果失败返回NULL。在程序结束时，这</p><p>个文件会被自动删除</p><p>　　例：FILE *fp=tmpfile();</p><p>17.tmpnam();</p><p>　　其原型为char *tmpnam(char *s); 生成一个唯一的文件名，其实tmpfile()就调用了此函数，参数s用来保存得到的文件名，并返回这个指针，</p><p>如果失败，返回NULL。</p> <br/><h3 id="I-O文件操作"><a href="#I-O文件操作" class="headerlink" title="I/O文件操作"></a>I/O文件操作</h3><br/><p>　　这是C提供的另一种文件操作，它是通过直接存/取文件来完成对文件的处理，而上篇所说流式文件操作是通过缓冲区来进行；流式文件操作是</p><p>围绕一个FILE指针来进行，而此类文件操作是围绕一个文件的”句柄”来进行，什么是句柄呢？它是一个整数，是系统用来标识一个文件(在</p><p>WINDOWS中，句柄的概念扩展到所有设备资源的标识)的唯一的记号。此类文件操作常用的函数如下表，这些函数及其所用的一些符号在io.h和</p><p>fcntl.h中定义，在使用时要加入相应的头文件。</p><p>　　函数 说明</p><p>　　open() 打开一个文件并返回它的句柄</p><p>　　close() 关闭一个句柄</p><p>　　lseek() 定位到文件的指定位置</p><p>　　read() 块读文件</p><p>　　write() 块写文件</p><p>　　eof() 测试文件是否结束</p><p>　　filelength() 取得文件长度</p><p>　　rename() 重命名文件</p><p>　　chsize() 改变文件长度</p><p>下面就对这些函数一一说明：</p><p>1.open()</p><p>　　打开一个文件并返回它的句柄，如果失败，将返回一个小于0的值，原型是int open(const char *path, int access [, unsigned mode]); 参数</p><p>path是要打开的文件名，access是打开的模式，mode是可选项。表示文件的属性，主要用于UNIX系统中，在DOS/WINDOWS这个参数没有意</p><p>义。其中文件的打开模式如下表。</p><p>　　符号 含义 符号 含义 符号 含义</p><p>　　O_RDONLY 只读方式 O_WRONLY 只写方式 O_RDWR 读/写方式</p><p>　　O_NDELAY 用于UNIX系统 O_APPEND 追加方式 O_CREAT 如果文件不存在就创建</p><p>　　O_TRUNC 把文件长度截为0 O_EXCL 和O_CREAT连用，如果文件存在返回错误 O_BINARY 二进制方式</p><p>　　O_TEXT 文本方式</p><p>　　对于多个要求，可以用”|”运算符来连接，如O_APPEND|O_TEXT表示以文本模式和追加方式打开文件。</p><p>　　例：int handle=open(“c://msdos.sys”,O_BINARY|O_CREAT|O_WRITE)</p><p>2.close()</p><p>　　关闭一个句柄，原型是int close(int handle);如果成功返回0</p><p>　　例：close(handle)</p><p>3.lseek()</p><p>　　定位到指定的位置，原型是：long lseek(int handle, long offset, int fromwhere);参数offset是移动的量，fromwhere是移动的基准位置，取</p><p>值和前面讲的fseek()一样，SEEK_SET：文件首部；SEEK_CUR：文件当前位置；SEEK_END：文件尾。此函数返回执行后文件新的存取位置</p><p>　　例：</p><p>　　lseek(handle,-1234L,SEEK_CUR);//把存取位置从当前位置向前移动1234个字节</p><p>　　x=lseek(hnd1,0L,SEEK_END);//把存取位置移动到文件尾，x=文件尾的位置即文件长度</p><p>4.read()</p><p>　　从文件读取一块，原型是int read(int handle, void *buf, unsigned len);参数buf保存读出的数据，len是读取的字节。函数返回实际读出的字节。</p><p>　　例：char x[200];read(hnd1,x,200);</p><p>5.write()</p><p>　　写一块数据到文件中，原型是int write(int handle, void *buf, unsigned len);参数的含义同read()，返回实际写入的字节。</p><p>　　例：char x[]=”I Love You”;write(handle,x,strlen(x));</p><p>6.eof()</p><p>　　类似feof()，测试文件是否结束，是返回1，否则返回0;原型是：int eof(int handle);</p><p>　　例：while(!eof(handle1)){……};</p><p>7.filelength()</p><p>　　返回文件长度，原型是long filelength(int handle);相当于lseek(handle,0L,SEEK_END)</p><p>　　例：long x=filelength(handle);</p><p>8.rename()</p><p>　　重命名文件，原型是int rename(const char *oldname, const char *newname); 参数oldname是旧文件名，newname是新文件名。成功返回0</p><p>　　例：rename(“c://config.sys”,”c://config.w40”);</p><p>9.chsize();</p><p>　　改变文件长度，原型是int chsize(int handle, long size);参数size表示文件新的长度，成功返回0，否则返回-1，如果指定的长度小于文件长</p><p>度，则文件被截短；如果指定的长度大于文件长度，则在文件后面补’/0’</p><p>　　例：chsize(handle,0x12345)</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c </tag>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自己，到底想要什么样的生活</title>
      <link href="2021/02/26/%E8%87%AA%E5%B7%B1%EF%BC%8C%E5%88%B0%E5%BA%95%E6%83%B3%E8%A6%81%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%E7%94%9F%E6%B4%BB/"/>
      <url>2021/02/26/%E8%87%AA%E5%B7%B1%EF%BC%8C%E5%88%B0%E5%BA%95%E6%83%B3%E8%A6%81%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%E7%94%9F%E6%B4%BB/</url>
      
        <content type="html"><![CDATA[<p>引用的文章来自一篇<a href="https://survivesjtu.gitbook.io/survivesjtumanual/xu/xin-ban-xu-todo">上海交大的文章</a>，当然，它的受众水平比我高了几个阶级的档次</p><p>起码是那些一线城市顶级学校的精英学生们，毕竟书中都说他们是“落榜”才来的交大</p><p>这就引出了我国教育资源分配不平等的问题（这个事情，也许我会出篇博客单独讨论这件事情）</p><p>本文所有引用的话都会做上标记，本文仅摘录自己认为比较重要的语句，详细还请看看原本</p><br/><h3 id="既来之，则安之"><a href="#既来之，则安之" class="headerlink" title="既来之，则安之"></a>既来之，则安之</h3><br/><p>人外有人，山外有山。有些人是奋发努力，担负着全家人的期望进入了一所大学，这取决他所处的学习环境和天赋</p><p>南邮也是这样，我本人就是属于压分进来的一批（虽然高考前我一直想进的是南师大）</p><p>当然，不乏有些大佬（竞赛啊，清北报送失败啊……）发挥失常进入了这所硬件设施确实有待提升的大学（x</p><br/><p><code>由于历史原因我国有两所著名的TOP2高校，经过几十年的集中建设，清北与第二梯队的高校的学科总体发展上也有着较大的差距，录取生源亦如</code></p><p><code>此，在很多高中老师们都信奉着“唯清北论”，一部分同学在刚入学时可能会有着“考败来交”的心态，交大每年也的确都会有若干对专业亦或者</code></p><p><code>学校不满意退学重新高考的案例，如果你在经过仔细的分析自己的真实实力水平加上复读一年的机会成本后觉得可行，应该尽早与家人沟通返回高</code></p><p><code>中备战次年高考</code></p><p><code>如果选择在交大继续读书，你也会发现未来的道路依然宽广，你会有机会申请本科转学到海外，亦或者大四时申请海外名校的硕</code></p><p><code>士、博士项目，那么此时你最应该关注的便是未来四年里如何合理利用好交大平台给予你的各项资源不断提升自己</code></p><br/><p>既然你来到了这里，又没有重修高四的想法，就需要持之以恒</p><p>（这里不得不吐槽一下我认识的某个人，如果不喜欢，强行抗拒又有什么用，只有不断竞争才能获得出路）</p><br/><h3 id="知己知彼"><a href="#知己知彼" class="headerlink" title="知己知彼"></a>知己知彼</h3><br/><p>脱离了这样懊悔地思维，接下来就是确定自己的目标，这里生存手册也给了四个明确的方向</p><p>（这些东西都有归纳出不同的利弊，十分的全面，希望各位认真阅读）</p><br/><p>1.了解你的专业</p><p>2.清除你的技术栈</p><p>3.知晓你本科4年想做什么</p><p>4.想清楚毕业之后想做什么</p><br/><p><code>你未来可能会用到的能力包括但不限于：</code></p><ol><li><p><code>本专业的专业知识，这是你安身立命的根本，对本领域有中长期的判断</code></p></li><li><p><code>表达能力，如何去说服你的上司还有顾客理解并接受你的idea和产品</code></p></li><li><p><code>相关信息检索、过滤、总结、可视化等的能力</code></p></li><li><p><code>交际能力，向别人展现自己的价值，在自己需要帮助的时候也能找到最合适的朋友寻求帮助</code></p></li><li><p><code>抗压能力，主要是对逆境的适应力、容忍力、耐力，能较好应对生活工作中的挫折</code></p></li><li><p><code>独立思考，在信息过载的当下尽量避免被错误消息带节奏</code></p></li><li><p><code>时间管理，以后的日子里你会被生活的柴米油盐和很多工作学习以外的杂事消耗精力，再也不是大学以前父母帮你操办大部分事情了，你需要</code></p><p><code>高效管理利用剩余的时间</code></p></li></ol><br/><p><code>假设你现在人生游戏的开局是在一个心仪的大学（交大）读了一个喜欢的专业，那么你的开局已经是同龄人中的至少前1%了</code></p><br/><p><code>GPA高的同学或许还能靠保研直博暂缓进入社会的进度条（当然很多同学保研直博也是一开始就定下的目标，并未考虑过直接进入社会），学业不</code></p><p><code>佳的同学或许要再像准备高考一样备战考研了，而近些年考研难度也是在肉眼可见地提升</code></p><p><code>进入社会之后人生的分支要比学校里多得多，在此也不一一举例，在象牙塔里被保护得久了容易跟现实社会脱节，这些东西要留给你自己去摸索</code></p><br/><h3 id="三省其身"><a href="#三省其身" class="headerlink" title="三省其身"></a>三省其身</h3><br/><h4 id="破除错误思维"><a href="#破除错误思维" class="headerlink" title="破除错误思维"></a>破除错误思维</h4><br/><p>世界观决定方法论，或者用句粗俗的话来讲-屁股决定脑袋</p><p>在做事之前，我们先要更正自己的思想，开头错，之后只能举步维艰</p><p>手册中，明确提出拜托两种错误思维</p><br/><p>1.高考思维</p><br/><p><code>如果一个人把政策评分作为自己的至高追求，那么他就是这个政策的牺牲品</code></p><br/><p><code>大学四年留给你的是你的人生，在你毕业之时，那一串苍白的分数其实就已经作废了</code></p><br/><p>2.被动思维</p><br/><p><code>“怕老师点名”、“为了抄笔记作业”、“记录考试重点”这些话，充其量只是我们被迫上课的借口，却不能成为我们心悦诚服去上课的理由</code></p><p><code>真正能成为我们上课理由的，只有我们对科学文化知识的渴望。</code></p><br/><p><code>如果是否上课对你的考试成绩影响不大；如果我们感兴趣的知识不在学校的课程表上；</code></p><p><code>如果上课学习的效果足够差，效率足够低，以至于通过自习，能够在更短的时间掌握知识；那么你还需要去上课吗？</code></p><br/><h4 id="反思自己的学习方式"><a href="#反思自己的学习方式" class="headerlink" title="反思自己的学习方式"></a>反思自己的学习方式</h4><br/><p>这部分的内容，我个人不能完全赞同的，但是又不乏有道理的地方</p><p>扎实的基础，正是通往更高层次知识的一个重要保证</p><p>（不过，没有多少人会记住这些基础的知识，仅仅只是作为一个通过考试的方法）</p><p>这一切的前提，都是这个人在这个方向上想有所作为</p><br/><p><code>我手上一本1300页的数学手册，上面记录了人类文明从远古直到二十世纪后半叶的主要数学成果</code></p><p><code>而我校高等数学教材（上下册）所涵盖的内容，不超过其中的130页。一个真正有志于建造科学大厦的人，是不应抱着一块儿砖头精雕细琢的</code></p><br/><p><code>学习最需要的，不是悲壮的毅力，而是对无限未知的渴求</code></p><br/><h4 id="意识到自己的价值"><a href="#意识到自己的价值" class="headerlink" title="意识到自己的价值"></a>意识到自己的价值</h4><br/><p>在这里，手册的撰写者秉持了和我一样的观点-不要廉价出卖自己的劳动力</p><br/><p><code>从本质上说，绝大部分同学们之所以选择大学毕业后再参加工作，是看上了更加体面的薪资待遇——大学毕业之后，我们的劳动会变得更有价值</code></p><p><code>在此，请不要提及所谓“劳动平等”之类的错误观点</code></p><p><code>劳动所创造的价值从来都不是均等的，而且不同行业的劳动早已明码标价了</code></p><br/><p><code>在交大，大多数同学家中没有许多房子也没有许多车，但他们是幸运的，至少有家庭可以负担他们在校期间的开销，不需要同学们为了筹措生活</code></p><p><code>费，一边上学一边廉价地出卖自己宝贵的时间</code></p><p><code>所以，对于生计无虞的同学们，我们更应该做的不是为了蝇头小利在最底层的劳动中苦苦挣扎，而是应当积极地利用这份时间来提高我们的身价，</code></p><p><code>为今后出卖高价值劳动创造机会</code></p><br/><h4 id="正确使用自己的时间"><a href="#正确使用自己的时间" class="headerlink" title="正确使用自己的时间"></a>正确使用自己的时间</h4><br/><p>在大学，重要的是你自己的时间</p><p>在高中时，我们被父母老师把时间安排得明明白白的，很少有自己的业余时间</p><p>既然已经知道这样的学习方式不适合你自己，何不跳出来，多给自己点空闲时间？</p><p>大学，并不是唯绩点论</p><br/><p><code>（如果按照学校的规划，你会发现你可以自由支配的业余时间少得可怜）</code></p><br/><p><code>平庸的生活方式是麻醉药。他只会束缚你，让你没有作为，甚至没有出息地度过大学的四年</code></p><br/><p><code>无论你做的事情是否有意义——哪怕任何事情都不做，时间也会从我们的身边溜走。我们必须一日三省问自己，今天的时间是否过得有价值</code></p><br/><p><code>除非你要保研或者转专业，其余的情况下 GPA 绝对不是最重要的因素</code></p><br/><h4 id="总有值得去做的事情"><a href="#总有值得去做的事情" class="headerlink" title="总有值得去做的事情"></a>总有值得去做的事情</h4><br/><p>我也不想再三地“吐槽”中国式的形式主义了（也许会新开文章，希望不要给我扣上反动的帽子）</p><p>很多课程，事情，根本就是没有意义的事情，想学的也仅仅是出于兴趣或者功利性</p><p>但是，就是这样，学校总能找一些牛头不对马尾的理由，原因仅仅是不想在学生面前丢了脸</p><p>这种东西，这是我最鄙夷的</p><p>所以，当得知我所属专业不学大物时，我是很高兴的，自己提升的时间多了</p><br/><p><code>“这些知识多学一些也没有什么不好，没准哪天就能用得到呢！”这种话乍听起来仿佛很有道理，但实际上却是不折不扣的谎言</code></p><br/><p><code>连高中教学都已经文理分家，作为一名大学生，我们更应当对自己的将来有一个最基本的规划</code></p><p><code>令人遗憾的是，学校教务部门经常异想天开地把一些八竿子打不着的课程推到我们面前</code></p><p><code>以为让机动学院的学生同时掌握心理学和化学实验，就能打造出所谓的复合型人才</code></p><p><code>我们之所以拒绝学习那些对自己不是特别有用的知识，是因为这些知识对我们的价值太低</code></p>]]></content>
      
      
      <categories>
          
          <category> 人生 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 个人感悟 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>re:从零开始学习c++ p4</title>
      <link href="2021/02/26/re-%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AD%A6%E4%B9%A0c-p4/"/>
      <url>2021/02/26/re-%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AD%A6%E4%B9%A0c-p4/</url>
      
        <content type="html"><![CDATA[<h3 id="字符函数库-cctype"><a href="#字符函数库-cctype" class="headerlink" title="字符函数库-cctype"></a>字符函数库-cctype</h3><br/><table><thead><tr><th align="center">函数名称</th><th align="center">返回值</th></tr></thead><tbody><tr><td align="center">isalnum()</td><td align="center">判断字母或者数字</td></tr><tr><td align="center">isalpha()</td><td align="center">判断字母</td></tr><tr><td align="center">iscntrl()</td><td align="center">判断控制字符（类似于控制台中^Z这一类的）</td></tr><tr><td align="center">isdigit()</td><td align="center">判断数字</td></tr><tr><td align="center">islower()</td><td align="center">判断小写字母</td></tr><tr><td align="center">isprint()</td><td align="center">判断打印字符（包括空格）</td></tr><tr><td align="center">ispunct()</td><td align="center">返回标点符号</td></tr><tr><td align="center">ispace()</td><td align="center">判断标准空白字符（如空格、换行符、回车）</td></tr><tr><td align="center">isupper()</td><td align="center">判断大写字母</td></tr><tr><td align="center">isxdigit()</td><td align="center">判断十六进制数字</td></tr><tr><td align="center">tolower()</td><td align="center">返回小写字母</td></tr><tr><td align="center">toupper()</td><td align="center">返回大写字母</td></tr></tbody></table><br/><h3 id="setf-amp-precision"><a href="#setf-amp-precision" class="headerlink" title="setf()&amp;precision()"></a>setf()&amp;precision()</h3><br/><p>一般以<code>cout.setf</code>()&amp;<code>set.precision</code>的形式出现</p><p>绝大部分的作用都是控制输出格式</p><br/><h4 id="1-使用控制符控制输出格式"><a href="#1-使用控制符控制输出格式" class="headerlink" title="1.使用控制符控制输出格式"></a>1.使用控制符控制输出格式</h4><br/><p>控制符 作用 </p><p>dec 设置整数的基数为10 </p><p>hex 设置整数的基数为16 </p><p>oct 设置整数的基数为8 </p><p>setbase(n) 设置整数的基数为n(n只能是16,10,8之一) </p><p>setfill(c) 设置填充字符c,c可以是字符常量或字符变量 </p><p>setprecision(n) 设置实数的精度为n位.在以一般十进制小数形式输出时,n代表有效数字.在以fixed(固定小数位数)形式和scientific(指数)形式输出</p><p>时,n为小数位数.</p><p>setw(n) 设置字段宽度为n位.</p><p>setiosflags(ios::fixed) 设置浮点数以固定的小数位数显示.</p><p>setiosflags(ios::scientific) 设置浮点数以科学计数法(即指数形式)显示.</p><p>setiosflags(ios::left) 输出数据左对齐.</p><p>setiosflags(ios::right) 输出数据右对齐.</p><p>setiosflags(ios::shipws) 忽略前导的空格.</p><p>setiosflags(ios::uppercase) 在以科学计数法输出E和十六进制输出字母X时,以大写表示.</p><p>setiosflags(ios::showpos) 输出正数时,给出“+”号.</p><p>resetiosflags 终止已设置的输出格式状态,在括号中应指定内容.</p><br/><h4 id="2-用流对象的成员控制输出格式"><a href="#2-用流对象的成员控制输出格式" class="headerlink" title="2.用流对象的成员控制输出格式"></a>2.用流对象的成员控制输出格式</h4><br/><p>流成员函数 与之作用相同的控制符 作用 </p><p>precision(n) setprecision(n) 设置实数的精度为n位.</p><p>width(n) setw(n) 设置字段宽度为n位.</p><p>fill(c) setfill(c) 设置填充字符c.</p><p>setf( ) setiosflags( ) 设置输出格式状态,括号中应给出格式状态,内容与控制符setiosflags括号中内容相同.</p><p>ubsetf( ) resetiosflags( ) 终止已设置的输出格式状态.</p><p>cout.width(10); </p><p>cout.setf(ios::hex);</p><br/><h4 id="3-设置格式状态的格式标志"><a href="#3-设置格式状态的格式标志" class="headerlink" title="3.设置格式状态的格式标志"></a>3.设置格式状态的格式标志</h4><br/><p>格式标志 作用 </p><p>ios::left 输出数据在本域宽范围内左对齐 </p><p>ios::right 输出数据在本域宽范围内右对齐 </p><p>ios::internal 数值的符号位在域宽内左对齐,数值右对齐,中间由填充字符填充 </p><p>ios::dec 设置整数的基数为10 </p><p>ios::oct 设置整数的基数为8 </p><p>ios::hex 设置整数的基数为16 </p><p>ios::showbase 强制输出整数的基数(八进制以0打头,十六进制以0x打头) </p><p>ios::showpoint 强制输出浮点数的小点和尾数0 </p><p>ios::uppercase 在以科学计数法输出E和十六进制输出字母X时,以大写表示 </p><p>ios::showpos 输出正数时,给出“+”号.</p><p>ios::scientific 设置浮点数以科学计数法(即指数形式)显示 </p><p>ios::fixed 设置浮点数以固定的小数位数显示 </p><p>ios::unitbuf 每次输出后刷新所有流 </p><p>ios::stdio 每次输出后清除stdout,stderr </p><p>以小数形式,保留三位小数输出：cout</p><br/><p>摘录自某<a href="https://blog.csdn.net/zh1204190329/article/details/79702058">csdn</a></p><br/><h3 id="c-文件操作"><a href="#c-文件操作" class="headerlink" title="c++文件操作"></a>c++文件操作</h3><br/><p>在fstream类中，有一个成员函数open()，就是用来打开文件的，其原型是：</p><p>　　void open(const char* filename,int mode,int access);</p><p>　　参数：</p><p>　　filename：　　要打开的文件名</p><p>　　mode：　　　　要打开文件的方式</p><p>　　access：　　　打开文件的属性</p><p>　　打开文件的方式在类ios(是所有流式I/O类的基类)中定义，常用的值如下：</p><p>　　ios::app：　　　以追加的方式打开文件</p><p>　　ios::ate：　　　文件打开后定位到文件尾，ios:app就包含有此属性</p><p>　　ios::binary： 　以二进制方式打开文件，缺省的方式是文本方式。两种方式的区别见前文</p><p>　　ios::in：　　　 文件以输入方式打开</p><p>　　ios::out：　　　文件以输出方式打开</p><p>　　ios::nocreate： 不建立文件，所以文件不存在时打开失败　</p><p>　　ios::noreplace：不覆盖文件，所以打开文件时如果文件存在失败</p><p>　　ios::trunc：　　如果文件存在，把文件长度设为0</p><p>　　可以用”或”把以上属性连接起来，如ios::out|ios::binary</p><p>　　打开文件的属性取值是：</p><p>　　0：普通文件，打开访问</p><p>　　1：只读文件</p><p>　　2：隐含文件</p><p>　　4：系统文件</p><p>　　可以用”或”或者”+”把以上属性连接起来 ，如3或1|2就是以只读和隐含属性打开文件。</p><p>　　例如：以二进制输入方式打开文件c:/config.sys</p><p>　　fstream file1;</p><p>　　file1.open(“c://config.sys”,ios::binary|ios::in,0);</p><p>　　如果open函数只有文件名一个参数，则是以读/写普通文件打开，即：</p><p>　　file1.open(“c://config.sys”);&lt;=&gt;file1.open(“c://config.sys”,ios::in|ios::out,0);</p><p>　　另外，fstream还有和open()一样的构造函数，对于上例，在定义的时侯就可以打开文件了：</p><p>　　fstream file1(“c://config.sys”);</p><p>　　特别提出的是，fstream有两个子类：ifstream(input file stream)和ofstream(outpu file stream)，ifstream默认以输入方式打开文件，而</p><p>ofstream默认以输出方式打开文件</p><p>　　ifstream file2(“c://pdos.def”);//以输入方式打开文件</p><p>　　ofstream file3(“c://x.123”);//以输出方式打开文件</p><p>　　所以，在实际应用中，根据需要的不同，选择不同的类来定义：如果想以输入方式打开，就用ifstream来定义；如果想以输出方式打开，就用</p><p>ofstream来定义；如果想以输入/输出方式来打开，就用fstream来定义</p><br/><p>引用自<a href="https://www.cnblogs.com/MrYuan/p/5383408.html">某博客园</a></p><br/><h4 id="写入文件"><a href="#写入文件" class="headerlink" title="写入文件"></a>写入文件</h4><br/><p>想要操作文件，先要定义<code>ofstream</code>对象</p><p>可以使用<code>open()</code>函数，来创建（打开）对应文件,使用<code>close()</code>函数关闭文件</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;using namespace std;int main()&#123;        ofstream fp;    ofstream fp2;    string a;    cin &gt;&gt; a;    fp.open(&quot;D:\\test.txt&quot;);    &#x2F;**     * @brief 创建了一个名为a的文件     *      *&#x2F;        fp2.open(a);        fp.close();    fp2.close();    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><h4 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h4><br/><p>此时的文件类型需要定义为<code>ifstresm</code>对象</p><p>使用<code>is_open()</code>&amp;<code>EXIT_FAILURE</code></p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;using namespace std;int main()&#123;    ifstream fp;    fp.open(&quot;D:\\test.txt&quot;);    &#x2F;**     * @brief 判断文件是否成功打开     *      *&#x2F;    if(!fp.is_open())&#123;        exit (EXIT_FAILURE);    &#125;    cout &lt;&lt; &quot;FILE OPEN SUCCESSFULLY&quot; &lt;&lt; endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>下面演示如何将读取的数据存储到变量中</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">ifstream fp;int value;fp.open(&quot;D:\\test.txt&quot;);fp &gt;&gt; value;&#x2F;&#x2F;通过 &gt;&gt; 进行“导流”一样<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><table><thead><tr><th align="center">函数</th><th align="center">返回值</th></tr></thead><tbody><tr><td align="center">eof()</td><td align="center">如果到达文件尾部，返回true</td></tr><tr><td align="center">good()</td><td align="center">在文件没有发生任何错误时，返回true</td></tr><tr><td align="center">fail()</td><td align="center">发生意外错误（EOF也算），返回true</td></tr></tbody></table><br/><h4 id="读写我全都要"><a href="#读写我全都要" class="headerlink" title="读写我全都要"></a>读写我全都要</h4><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">ifstream fp1(&quot;D:\\1.txt&quot;, ios::in|ios::out);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br/><table><thead><tr><th align="center">格式</th><th align="center">用途</th></tr></thead><tbody><tr><td align="center">ios::in</td><td align="center">以输入方式打开文件</td></tr><tr><td align="center">ios::out</td><td align="center">以输出方式打开文件，如果文件不存在则新建，如果文件存在就将其原有内容全部清空</td></tr><tr><td align="center">ios::app</td><td align="center">输出的数据追加到文件末尾</td></tr><tr><td align="center">ios::ate</td><td align="center">打开一个文件，并将指针定位到文件末尾</td></tr><tr><td align="center">ios::trunc</td><td align="center">打开一个文件，如果文件不存在则新建，如果存在，则清空原有文件中的内容</td></tr><tr><td align="center">ios::binary</td><td align="center">以二进制方式打开文件，如果不指定则默认采用文本方式打开文件</td></tr><tr><td align="center">ios::in | ios::out</td><td align="center">以输出和输入方式打开文件</td></tr><tr><td align="center">ios::in | ios::binary</td><td align="center">以输入方式打开一个二进制文件</td></tr><tr><td align="center">ios::out| ios::binary</td><td align="center">以输出方式打开一个二进制文件</td></tr></tbody></table><br/><p>最后，点份炸鸡庆祝自己第一阶段的c++学习结束（x</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>re:从零开始学习c++ p3</title>
      <link href="2021/02/25/re-%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AD%A6%E4%B9%A0c-p3/"/>
      <url>2021/02/25/re-%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AD%A6%E4%B9%A0c-p3/</url>
      
        <content type="html"><![CDATA[<h3 id="数组的替代品"><a href="#数组的替代品" class="headerlink" title="数组的替代品"></a>数组的替代品</h3><br/><h4 id="1-vector模板类"><a href="#1-vector模板类" class="headerlink" title="1.vector模板类"></a>1.vector模板类</h4><br/><p>vector类使用new delete来管理内存，不过这个过程是<code>自动执行</code>的</p><p>（需要vector头文件，std命名空间）</p><p>下面是两个定义vector的例子</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">vector &lt;int&gt; vi;int n;cin &gt;&gt; n;vector &lt;double&gt; vd(n);&#x2F;&#x2F;n可以是整形常量或变量<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><h4 id="2-array模板类"><a href="#2-array模板类" class="headerlink" title="2.array模板类"></a>2.array模板类</h4><br/><p>vector功能比数组要强大不少，但是代价便是降低了效率</p><p>所以对于<code>长度固定</code>，但是数组不方便使用的情况下，折中的结果就得到了array类</p><p>（需要array头文件，长度不能是变量）</p><p>下面举个array的例子</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">array &lt;int, 5&gt; ai;array &lt;double, 4&gt; ad;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><br/><h4 id="总结两个模板和数组的区别"><a href="#总结两个模板和数组的区别" class="headerlink" title="总结两个模板和数组的区别"></a>总结两个模板和数组的区别</h4><br/><p>array对象和数组存储在相同的内存区域（栈）中</p><p>vector对象存储在另一个区域（自由存储区或堆）中</p><br/><p>这里提醒一点，如果你不规范使用两个模块定义的数组，c++是不会检查不规范行为的</p><p>（养成良好的编程习惯是多么重要）</p><br/><h3 id="语句块小细节"><a href="#语句块小细节" class="headerlink" title="语句块小细节"></a>语句块小细节</h3><br/><p>c++和Java一样，都提供了语句块的写法</p><p>然而，再语句块中定义的变量出了语句块就会被释放，简而言之，只能在语句块内使用</p><br/><p>循环的语句，是根据花括号来判断是否在循环内</p><p>如果只有一行语句，是否写括号无伤大雅，但是后面的语句一律会被排除在循环外</p><p>（所以，要养成良好的编程习惯）</p><br/><h3 id="随迟但到的foreach"><a href="#随迟但到的foreach" class="headerlink" title="随迟但到的foreach"></a>随迟但到的foreach</h3><br/><p>这是从Java里取来的，c++里称为基于范围的for循环</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int a[3] &#x3D; &#123;1, 2, 3&#125;;for(int i : a)&#123;cout &lt;&lt; i &lt;&lt; endl;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>每次都是依次读取每个元素的值，在遍历数组时十分方便</p><p>在之后的Java中，是有自带的Array包的，可以直接使用Array.toString()对象</p><p>当然，如果定义了一个多维的数组，foreach的写法略有区别，但很好理解</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int a[3][3] &#x3D; &#123;&#123;1, 2, 3&#125;, &#123;4, 5, 6&#125;, &#123;7, 8, 9&#125;&#125;;for(int b[] : a)&#123;for(int c : b)&#123;cout &lt;&lt; c;        &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><h3 id="文件尾条件"><a href="#文件尾条件" class="headerlink" title="文件尾条件"></a>文件尾条件</h3><br/><p>假设Windows系统中有<code>gofish.exe</code>，<code>fishtale</code>的文本文件</p><p>使用<code>gofish &lt; fishtale</code>语句就可以从文件中读取输入（而不是从键盘）</p><br/><p>如果环境能够检测出<code>EOF</code>，输出就会停止</p><p>由于在Windows环境，可以使用<code>CTRL+Z</code> <code>ENTER</code> 来模拟EOF</p><p>（有些时候这个操作会直接结束程序）</p><br/><h3 id="一句话排序-sort"><a href="#一句话排序-sort" class="headerlink" title="一句话排序-sort"></a>一句话排序-sort</h3><br/><p>了解这个函数来自于黄老板的一次讲课课件（x</p><p>具体的一部分内容也来自于<a href="https://www.cnblogs.com/stones-dream/p/10183210.html">博客园一篇文章</a></p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">sort(first_pointer,first_pointer+n,cmp)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br/><table><thead><tr><th align="center">参数</th><th align="center">意义</th></tr></thead><tbody><tr><td align="center">first_pointer</td><td align="center">是数组的首地址，一般写上数组名就可以，因为数组名是一个指针常量</td></tr><tr><td align="center">first_pointer+n</td><td align="center">相对较好理解，即首地址加上数组的长度n（代表尾地址的下一地址）</td></tr><tr><td align="center">cmp</td><td align="center">默认可以不填，如果不填sort会默认按数组升序排序。也可以自定义一个排序函数，改排序方式为降序</td></tr></tbody></table><br/><p>使用此函数需先包含：</p><p>#include <algorithm></p><p>并且导出命名空间：</p><p>using namespace std;</p><p>简单例子：对数组A的0~n-1元素进行升序排序，只要写sort(A,A+n)即可</p><br/><p>下面是完整的样例</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;using namespace std;const int SIZE &#x3D; 10000;&#x2F;** * @brief 定义排序规则，这里是降序 *  * @param a  * @param b  * @return true  * @return false  *&#x2F;bool cmp(int a, int b)&#123;    return a &gt; b;&#125;int main()&#123;    int a[5] &#x3D; &#123;5, 7, 9, 1, 3&#125;;    sort(a, a + 5, cmp);    for(int i &#x3D; 0; i &lt; 5; i ++)&#123;        cout &lt;&lt; a[i];    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>在一些情况下，需要对不同的数据进行排序，这些数是相互孤立的</p><p>所以，我们就需要用到——结构体封装</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;using namespace std;struct Student&#123;    int id;    string name;    double score;&#125;;&#x2F;** * @brief 基于id的升序排序 *  * @param a  * @param b  * @return true  * @return false  *&#x2F;bool cmp(Student a, Student b)&#123;    return a.id &lt; b.id;&#125;int main()&#123;    Student stu[5];    int n;    for(n &#x3D; 0; n &lt; 5; n ++)&#123;        cin &gt;&gt; stu[n].id &gt;&gt; stu[n].name &gt;&gt; stu[n].score;    &#125;    sort(stu, stu + 5, cmp);    for(n &#x3D; 0; n &lt; 5; n ++)&#123;        cout &lt;&lt; stu[n].name &lt;&lt; endl;    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>由于结构体是没有办法使用默认排序方法的</p><p>所以需要程序员自己定义</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>re:从零开始学习c++ p2</title>
      <link href="2021/02/24/re-%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AD%A6%E4%B9%A0c-p2/"/>
      <url>2021/02/24/re-%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AD%A6%E4%B9%A0c-p2/</url>
      
        <content type="html"><![CDATA[<h3 id="数组-amp-字符串"><a href="#数组-amp-字符串" class="headerlink" title="数组&amp;字符串"></a>数组&amp;字符串</h3><br/><h4 id="字符串常量拼接"><a href="#字符串常量拼接" class="headerlink" title="字符串常量拼接"></a>字符串常量拼接</h4><br/><p>如果字符串太长，可以使用两个引号</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">cout &lt;&lt; &quot;a&quot; &quot;b&quot;;cout &lt;&lt; &quot;a b&quot;;cout &lt;&lt;&quot;a&quot;&quot;b&quot;;&#x2F;&#x2F;以上三种的输出结果是一样的<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>任何两个由空白（空格、制表符和换行符）分隔的字符串常量都将自动拼接成一个</p><br/><h4 id="c-的字符串函数-amp-输入"><a href="#c-的字符串函数-amp-输入" class="headerlink" title="c++的字符串函数&amp;输入"></a>c++的字符串函数&amp;输入</h4><br/><p>头文件cstring(旧位string.h)</p><br/><p>如果期望一整行字符串，需要使用getline()函数</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">cin.getline(ArrayName, length);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br/><p>规定了键盘中输入的数据存入的数组，一并长度</p><p>（如果<code>length</code>写了20，实际上只会读取19个字符，最后会自动添加<code>&quot;\0&quot;</code>）</p><p>当读取字符到达上限或者遇到换行符，就会停止</p><br/><p>当然还有一个变种<code>get()</code>，不过使用这个函数会出现一个问题</p><p>究其原因，还是因为get()也会把换行符纳入其中</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">char a[20], b[20];cin.get(a, 20);cin,get(b, 20);&#x2F;&#x2F;Error<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><br/><p>此时第二个get的第一个字符其实是换行符，这样就会导致问题</p><p>然而，弄清除问题的本质之后，解决办法就出来了</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">cin.get(a, 20);cin.get();cin,get(b, 20);cin.get(a, 20).get();cin.get(b, 20).get();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>如果想多次调用，可以写成以下格式</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">cin.getline(a, 20).getline(b, 20);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br/><p>然而还会遇到空行问题，毕竟连续读取是从第一个的结束处开始</p><p><code>cin.clear();</code>可以解决这个问题</p><br/><p>如果连续输入数字和字符串，换行符会留在结束处，导致字符串的无法读取</p><p>可以采取以下方法解决</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">(cin &gt;&gt; year).get();cout.getline(address, 80);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><br/><h3 id="string类"><a href="#string类" class="headerlink" title="string类"></a>string类</h3><br/><p>区别于Java的String类，不需要大写首字母</p><br/><p>虽然我们不能将一个数组赋值给另一个数组，但是string对象可以相互赋值</p><p>简化了合并操作，可以通过 “+”实现</p><p>（当然，如果想使用旧的合并拷贝函数，也可以）</p><br/><p>从而衍生出了两种确认字符串长度的方法</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">char a[20];string b[20];int len1 &#x3D; strlen(a);int len2 &#x3D; b.size();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>如果想读取一整行而非一个单词，输入方法有些许区别</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">string a;getline(cin, a);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><br/><p>cin作为其中的参数，作用是能指出在哪里寻找输入（使用这种方式可以输入带空格的字符串）</p><p>str默认的长度是0，实际的长度根据键盘中输入的字符数自动决定</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">string s4( 8 , &#39;A&#39; );&#x2F;&#x2F;定义串s4初值为8个A组成的串AAAAAAAAs3.insert(7 , &quot;&amp;Teacher&quot;);&#x2F;&#x2F;向串s3的7下标处插入串&quot;&amp;Teacher&quot;s3.replace(2, 4, &quot;ar&quot;);&#x2F;&#x2F;利用replace函数将string串s3的2下标开始的长度为4的子串替换成&quot;ar&quot;s1 &#x3D; s3.substr(6, 7);&#x2F;&#x2F;利用substr函数取出串s3的6下标开始长度为7的子串并赋值给s1串int pos &#x3D; s3.find(s1);&#x2F;&#x2F;在串s3中查找s1串是否存在，若存在则返回s1串的第1个字符在s3中的下标s3.erase(5, 8);&#x2F;&#x2F;删除串s3的5下标开始长度为8的子串<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><h3 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h3><br/><p>如果你觉得，在输出里反复使用<code>\&quot;</code>过于麻烦，可以使用原始字符串，标注”()”的范围</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">cout &lt;&lt; R&quot;(Jim &quot;King&quot; Tutt)&quot;;cout &lt;&lt; &quot;Jim \&quot;King\&quot; Tutt&quot;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><br/><p>两者最后呈现的效果是一样的</p><p>并且，如果前面加了一部分的格式，后面也要一致</p><br/><p>如果想要自定义函数不使用参数，可以使用<code>void</code></p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;using namespace std;char * getName(void);int main()&#123;    char * name;    name &#x3D; getName();    cout &lt;&lt; name &lt;&lt; &quot; the address is &quot; &lt;&lt; (int *) name &lt;&lt; endl;    delete [] name;    return 0;&#125;char * getName()&#123;    char temp[80];    cout &lt;&lt; &quot;enter the name:&quot; &lt;&lt; endl;    cin &gt;&gt; temp;        char * pn &#x3D; new char(strlen(temp) + 1);    strcpy(pn, temp);    return pn;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><h3 id="结构体-amp-共用体"><a href="#结构体-amp-共用体" class="headerlink" title="结构体&amp;共用体"></a>结构体&amp;共用体</h3><br/><p>在c++中，结构体的定义之后，没有必要使用typedef，可以直接定义变量</p><p>当然，初始化之后，也可以跟c一样</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">struct inflatable&#123;char name[20];float volume;doubel price;&#125;inflatable a[2] &#x3D; &#123;&#123;&quot;cxy&quot;, 0.5, 21.99&#125;,&#123;&quot;huangx&quot;, 2000, 565.99&#125;&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>共用体是在结构体中额外定义的</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">struct inflatable&#123;char name[20];float volume;doubel price;union&#123;...&#125;;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>只能使用int long double 类型</p><p>当数据需要两种或更多格式时，可以节省空间</p><br/><h3 id="简单了解一下枚举"><a href="#简单了解一下枚举" class="headerlink" title="简单了解一下枚举"></a>简单了解一下枚举</h3><br/><p>具体的内容可以去Java区了解</p><p>这里，只说一些之前没有记录下来的细节</p><br/><p>1.默认的第一数是0，所有数根据前一个数自动+1（指定值时，必须是整数）</p><p>2.定义枚举变量时，赋值只能使用枚举定义时的变量</p><p>3.数据不要越界</p><p>（这样可以明白，怎么使得一周七天的表达更加简单）</p><p>（对于Java这种自带time接口的语言，获取时间更是一句话的事）</p><br/><h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><br/><p>写一个可能会被骂的语句</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int* p1, p2;&#x2F;&#x2F;表示定义一个指向int的指针&amp;一个int类型的变量<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><br/><h4 id="new-amp-delete"><a href="#new-amp-delete" class="headerlink" title="new&amp;delete"></a>new&amp;delete</h4><br/><p>在c++中，往往推荐使用<code>new</code>来分配内存</p><p>使用<code>delete</code>释放内存，不会删除指针本身，只是单纯释放内存</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int * p1 &#x3D; new int;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br/><p>注意：</p><p>1.不要尝试释放已经释放空间的指针，这会导致无法预料的结果</p><p>2.new，delete是配套使用的，无内存分配的指针不要使用delete（空指针没事）</p><br/><h4 id="使用new来创建动态数组"><a href="#使用new来创建动态数组" class="headerlink" title="使用new来创建动态数组"></a>使用new来创建动态数组</h4><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int * p &#x3D; new int [10];delete [] p;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><br/><p>[]指示delete不只释放指向元素，还有整个数组</p><br/><h4 id="指针的一系列运算"><a href="#指针的一系列运算" class="headerlink" title="指针的一系列运算"></a>指针的一系列运算</h4><br/><p>如果将指针初始化为一个数组，两者的使用在大部分情况下是没什么去别的</p><p>但是如果使用sizeof，数组表示的是整体的大小，指针仅是其类型的大小</p><p>（在多数情况下，c++将数组名视为数组的第一个元素的地址）</p><br/><p>如果使用new创建数组，可以使用动态内存</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int size;cin &gt;&gt; size;int * p1 &#x3D; new int [size];delete [] p1;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>一般来说，如果给cout提供一个指针，它将打印地址</p><p>如果指针的类型为char *，则cout将显示指向的字符串</p><br/><h4 id="使用new来创建动态结构"><a href="#使用new来创建动态结构" class="headerlink" title="使用new来创建动态结构"></a>使用new来创建动态结构</h4><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">inflatable * ps &#x3D; new inflatable;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>re:从零开始学习c++ p1</title>
      <link href="2021/02/23/re-%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AD%A6%E4%B9%A0c-p1/"/>
      <url>2021/02/23/re-%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AD%A6%E4%B9%A0c-p1/</url>
      
        <content type="html"><![CDATA[<p>oop（面对对象编程）</p><p>这里的原则，就是封装性、继承性、多态性</p><br/><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><br/><h3 id="一切的开始-头文件"><a href="#一切的开始-头文件" class="headerlink" title="一切的开始-头文件"></a>一切的开始-头文件</h3><br/><p>这里不介绍其他头文件了，直接上万能头文件</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">include&lt;bits&#x2F;stdc++.h&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br/><p>万能头文件并非十全十美，调用过多的头文件会导致代码的加载速度慢很多，而且很多竞赛往往不会让你使用这个头文件</p><p>特别是到了公司之后，一切的代码的格式被规定严格之后，这种头文件更不会被采纳了，所以还是建议记住对应的头文件</p><p>处理小数据和平时的acm题目是没什么问题的，但是当遇到大量数据时，就会有明显差距</p><br/><p>如果使用vscode的小伙伴，插件里是没有万能头文件的，所以要手动添加</p><p>具体操作看<a href="https://www.jianshu.com/p/e10498d2d211">这里</a>（里面的是mac系统，还请变通一下，不要像博主一样死脑经）</p><p>总之就是不想用devc++（x</p><br/><h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h3><br/><p>面向对象编程的语言的新概念，已经在php中遇到过，这里不再赘述</p><p>如果想要方便编程，请使用以下语句（也可以在函数内部分开使用）</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">using namespace std;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br/><p>因为本片中的函数都是属于</p><p><code>头文件:iostream</code></p><p><code>命名空间:std</code></p><br/><h3 id="cout进行输出"><a href="#cout进行输出" class="headerlink" title="cout进行输出"></a>cout进行输出</h3><br/><p>虽然c++是可以使用c的一系列语法，但是不推荐</p><p>所以我们使用cout进行输出</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">cout &lt;&lt; &quot;Hello World&quot;;&#x2F;&#x2F;用双引号括起来的是字符串<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><br/><p>就输出变量这方面来看，c++和Java很像</p><p>一个是”&lt;&lt;”，一个是”+”</p><p>（c的printf对于各种类型的识别太过于麻烦，cout的智能性在此刻高下立判）</p><br/><h3 id="endl控制符-amp-换行符"><a href="#endl控制符-amp-换行符" class="headerlink" title="endl控制符&amp;换行符"></a>endl控制符&amp;换行符</h3><br/><p>其作用就是另起一行，相当于”\n”的效果</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">cout &lt;&lt; &quot;Hello World&quot; &lt;&lt; endlcout &lt;&lt; &quot;Hello World\n&quot;&#x2F;&#x2F;两者是一样的<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><br/><p>但是endl会更方便和顺手</p><br/><h3 id="输入一个值-cin"><a href="#输入一个值-cin" class="headerlink" title="输入一个值-cin"></a>输入一个值-cin</h3><br/><p>在这里，可以看在c++的有趣形象的括号方式</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int a;cin &gt;&gt; a; &#x2F;&#x2F; c++式inputout &lt;&lt; a; &#x2F;&#x2F; c++式output<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><br/><p>在c++中，这样的方式称作字符的流动</p><p>使用<code>&gt;&gt;</code> <code>&lt;&lt;</code> 进行”抽取”，”输出”</p><br/><h3 id="函数（补充）"><a href="#函数（补充）" class="headerlink" title="函数（补充）"></a>函数（补充）</h3><br/><p>声明函数方面</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">double sqrt(double);&#x2F;&#x2F;第一个double表示sqrt的类型，第二个double表示输入的数的类型double x;x &#x3D; sqrt(6.25)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>（头文件为<code>cmath</code> 区别于旧<code>math.h</code>）</p><br/><h3 id="同时使用全局变量-amp-局部变量"><a href="#同时使用全局变量-amp-局部变量" class="headerlink" title="同时使用全局变量&amp;局部变量"></a>同时使用全局变量&amp;局部变量</h3><br/><p>c++中提供了::关键字使得编译器在定义相同名称的函数中，区分全局变量和局部变量</p><p>这就节省了各种变量的使用</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;bits&#x2F;stdc++.h&gt;using namespace std;int num &#x3D;  10;int main()&#123;    int num &#x3D; 5;    cout &lt;&lt; ::num &lt;&lt; &quot; &quot; &lt;&lt; num &lt;&lt; endl;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><h2 id="处理数据"><a href="#处理数据" class="headerlink" title="处理数据"></a>处理数据</h2><br/><h3 id="简单变量"><a href="#简单变量" class="headerlink" title="简单变量"></a>简单变量</h3><br/><p>补充一点，虽然对变量没有长度限制，但是编译器只会检查前63个字符</p><p>如果前63个字符相等，第64个字符不同，编译器也会认为这两个变量相等</p><br/><p>由于无法设计类型长度满足所有的计算机，c++保留了最少长度</p><table><thead><tr><th align="center">类型</th><th align="center">长度</th></tr></thead><tbody><tr><td align="center">short</td><td align="center">至少16位</td></tr><tr><td align="center">int</td><td align="center">至少与short一样长</td></tr><tr><td align="center">long</td><td align="center">至少32位，且至少与int一样长</td></tr><tr><td align="center">long long</td><td align="center">至少64位，且至少和long一样长</td></tr></tbody></table><br/><p>补充一句，在定义常量方面，const限定符比define要好</p><p>可以适用于更加复杂的类型</p><br/><h3 id="climits头文件"><a href="#climits头文件" class="headerlink" title="climits头文件"></a>climits头文件</h3><br/><p>设定了一些固定的符号常量，分别表示不同意思</p><br/><ol><li>CHAR_BIT ：char的位数</li><li>CHAR_MAX ：char的最大值</li><li>CHAR_MIN ：char的最小值</li><li>SCHAR_MAX ：signed char的最大值</li><li>SCHAR_MIN ：signed char的最小值</li><li>UCHAR_MAX ：unsigned char的最大值</li><li>SHRT_MAX ：short 的最大值</li><li>SHRT_MIN ：short 的最小值</li><li>USHRT_MAX ：unsigned short 的最大值</li><li>INT_MAX ：int 的最大值</li><li>INT_MIN ：int 的最小值</li><li>UINT_MAX ：unsigned int 的最大值</li><li>LONG_MAX ：long 的最大值</li><li>LONG_MIN ：long 的最小值</li><li>ULONG_MAX ：unsigned long 的最大值</li><li>LLONG_MAX ：long long 的最大值</li><li>LLONG_MIN ：long long 的最小值</li><li>ULLONG_MAX ：unsigned long long 的最大值</li></ol><br/><h3 id="c-11的初始化方式"><a href="#c-11的初始化方式" class="headerlink" title="c++11的初始化方式"></a>c++11的初始化方式</h3><br/><p>可以使用”{}”，甚至可以直接省略”=”</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int a &#x3D; &#123;24&#125;;int emus &#123;7&#125;;int b &#123;&#125;;int c &#x3D; &#123;&#125;;&#x2F;&#x2F;如果没有值则默认为0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><h3 id="char类型-amp-bool类型"><a href="#char类型-amp-bool类型" class="headerlink" title="char类型&amp;bool类型"></a>char类型&amp;bool类型</h3><br/><p>使用cout.put()函数来输出单个字符</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">cout &lt;&lt; &#39;$&#39;;&#x2F;&#x2F;单纯的cout是输出的字符所代表的asc码的值cout.put(&#39;$&#39;);&#x2F;&#x2F;该函数输出$<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><br/><p>char默认情况下是既有符号也没有符号</p><p>如果有特定需求，需要使用<code>unsigned char</code> <code>sigined char</code></p><br/><p>书中还有一些关于其他文字的新增类型</p><p>这里就不再赘述</p><br/><p>bool类型可以转化成整形（true 为 1， false 为 0）</p><p>所有的数字值和指针都可以被隐式转化为bool值</p><br/><h3 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h3><br/><table><thead><tr><th align="center">类型</th><th align="center">长度</th></tr></thead><tbody><tr><td align="center">float</td><td align="center">至少32位</td></tr><tr><td align="center">double</td><td align="center">至少48位，且不少于float</td></tr><tr><td align="center">long double</td><td align="center">至少和double一样多</td></tr></tbody></table><br/><p>（通常cout会删除结尾的零，</p><p>cout所属类还有函数可以控制，小数输出的格式，后面会提及）</p><br/><p>如果希望浮点常数是float类型，需要添加后缀（”f”或”F”）</p><p>希望是long double类型，需要（”l”或”L”，因为l和1比较像，推荐大写）</p><br/><h3 id="一个智能但别扭的声明-auto"><a href="#一个智能但别扭的声明-auto" class="headerlink" title="一个智能但别扭的声明-auto"></a>一个智能但别扭的声明-auto</h3><br/><p>auto很少使用，估摸着懒人也不想用，显得自己很没水平</p><p>（虽然会根据初始化的值设定类型，但是会有很大问题&amp;bug）</p><br/><h2 id="说些可能被忽略掉的点"><a href="#说些可能被忽略掉的点" class="headerlink" title="说些可能被忽略掉的点"></a>说些可能被忽略掉的点</h2><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">short a &#x3D; 20;short b &#x3D; 35;short c &#x3D; a + b;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><br/><p>看似很简单的运算，其实暗含了类型转变</p><p>运算过程中其实是将a&amp;b转化为int再变成short类型的结果c</p><p>（int类型是计算机最为自然的类型，此类型下运算速度可能最快）</p><br/><p>这里有个黄老板提出的小技巧（x</p><p>使用cin&amp;cout会导致运行速度变慢（这个在acm&amp;io这种限制运行时间的比赛中需要注意）</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>近几天对排序算法的研究</title>
      <link href="2021/02/20/%E8%BF%91%E5%87%A0%E5%A4%A9%E5%AF%B9%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E7%A0%94%E7%A9%B6/"/>
      <url>2021/02/20/%E8%BF%91%E5%87%A0%E5%A4%A9%E5%AF%B9%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E7%A0%94%E7%A9%B6/</url>
      
        <content type="html"><![CDATA[<p>本文对算法内容介绍大部分引自<a href="https://www.runoob.com/cprogramming/c-sort-algorithm.html">菜鸟教程</a></p><p>（冒泡排序和选择排序过于基础，这里不再说明）</p><br/><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><br/><p>插入排序（英语：Insertion Sort）是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用到 {\displaystyle O(1)} {\displaystyle O(1)}的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间</p><br/><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;stdio.h&gt;&#x2F;&#x2F;对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入int main()&#123;    int a[100], n;    int i, j, temp;    do&#123;        scanf(&quot;%d&quot;, &amp;n);    &#125;while(n &lt; 1 || n &gt; 100);    for(i &#x3D; 0; i &lt; n; i ++)&#123;        scanf(&quot;%d&quot;, &amp;a[i]);    &#125;    for(i &#x3D; 1; i &lt; n; i ++)&#123;        temp &#x3D; a[i];、        &#x2F;&#x2F;较大的值逐步向后移，最后将值插入固定的位置        for(j &#x3D; i; j &gt; 0 &amp;&amp; a[j - 1] &gt; temp; j --)&#123;            a[j] &#x3D; a[j - 1];        &#125;        a[j] &#x3D; temp;    &#125;    for(i &#x3D; 0; i &lt; n; i ++)&#123;        printf(&quot;%d  &quot;, a[i]);    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p><img src="https://www.runoob.com/wp-content/uploads/2018/09/Insertion_sort_animation.gif" alt="图片演示"></p><br/><h3 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h3><br/><p>最近程序设计，脸黑抽到一个桶排序</p><p>查阅百度百科时发现大多是c++/Java语法（甚至js和php也来掺一脚）</p><p>所以自己想着归纳归纳c语言的简单用法</p><br/><p>使用这个方法时，最终要的就是得知整个数组中的最大值</p><p>（当然，如果熟知链表知识，完全不需要在意这种小问题）</p><br/><p>桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。为了使桶排序更加高效，我们需要做到这两点：</p><ol><li>在额外空间充足的情况下，尽量增大桶的数量</li><li>使用的映射函数能够将输入的 N 个数据均匀的分配到 K 个桶中</li></ol><p>同时，对于桶中元素的排序，选择何种比较排序算法对于性能的影响至关重要</p><br/><h4 id="1-什么时候最快"><a href="#1-什么时候最快" class="headerlink" title="1. 什么时候最快"></a>1. 什么时候最快</h4><br/><p>当输入的数据可以均匀的分配到每一个桶中</p><br/><h4 id="2-什么时候最慢"><a href="#2-什么时候最慢" class="headerlink" title="2. 什么时候最慢"></a>2. 什么时候最慢</h4><br/><p>当输入的数据被分配到了同一个桶中</p><br/><h4 id="3-示意图"><a href="#3-示意图" class="headerlink" title="3. 示意图"></a>3. 示意图</h4><br/><p>元素分布在桶中：</p><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/Bucket_sort_1.svg_.png" alt="将原数组的元素放入桶中"></p><p>然后，元素在每个桶中排序：</p><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/Bucket_sort_2.svg_.png" alt="桶内逐个排序"></p><br/><pre class="line-numbers language-c" data-language="c"><code class="language-c">#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;time.h&gt;#define N 100#define SIZE 65535&#x2F;&#x2F;我这里给每个数都设置了一个桶int main()&#123;    int i, j;    int a[N], Bucket[SIZE];    for(i &#x3D; 0; i &lt; SIZE; i ++ )&#123;        Bucket[i] &#x3D; 0;    &#125;    srand((int)time(NULL));    for(i &#x3D; 0; i &lt; N; i ++)&#123;        a[i] &#x3D; rand();    &#125;    &#x2F;&#x2F;桶排序的开始，将数组中的数据值作为编号    for(i &#x3D; 0; i &lt; N; i ++)&#123;        Bucket[a[i]] ++;    &#125;    for(i &#x3D; 0; i &lt; SIZE; i ++)&#123;        for(j &#x3D; 0; j &lt; Bucket[i]; j ++)&#123;            printf(&quot;%d\n&quot;, i);        &#125;    &#125;    return 0;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>上面是最简单的，在所需要排列的数较小的时候</p><p>一般情况是每隔几段分出一个桶</p><br/><h4 id="补充一点"><a href="#补充一点" class="headerlink" title="补充一点"></a>补充一点</h4><br/><p>之前的例子只是对数字进行分类</p><p>接下来谈一谈类型为字符串的情况</p><br/><p>这种就没法通过最大值进行平均的间隔分割，所以我们需要列出所有字符代码表的asc值</p><p>设定总数NUM 256</p><p>之后的操作便像之前那样了</p><br/><h3 id="基于黄老板的cpp文件的研究"><a href="#基于黄老板的cpp文件的研究" class="headerlink" title="基于黄老板的cpp文件的研究"></a>基于黄老板的cpp文件的研究</h3><br/><p>当然，这并不是纯粹的c++，包含了c头文件的库函数</p><p>还有一些cpp的模板</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">FILE *freopen(const char *filename, const char *mode, FILE *stream)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br/><p>stdout（Standardoutput）标准输出</p><p>stdin（Standardinput）标准输入</p><br/><p>在这之中，使用我还没见过的一些模板</p><br/><h4 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h4><br/><p>C++ Stack（堆栈） 是一个容器类的改编，为程序员提供了堆栈的全部功能，——也就是说实现了一个先进后出（FILO）的数据结构</p><br/><p><strong>c++ stl栈stack的头文件为</strong>: </p><br/><p>#include <stack> </p><br/><p><strong>c++ stl栈stack的成员函数介绍</strong></p><br/><p>操作 比较和分配堆栈</p><p>empty() 堆栈为空则返回真</p><p>pop() 移除栈顶元素</p><p>push() 在栈顶增加元素</p><p>size() 返回栈中元素数目</p><p>top() 返回栈顶元素</p><br/><h4 id="priority-queue"><a href="#priority-queue" class="headerlink" title="priority_queue"></a>priority_queue</h4><br/><p>首先要包含头文件<code>#include&lt;queue&gt;</code>, 他和<code>queue</code>不同的就在于我们可以自定义其中数据的优先级, 让优先级高的排在队列前面,优先出队。</p><p>优先队列具有队列的所有特性，包括队列的基本操作，只是在这基础上添加了内部的一个排序，它本质是一个堆实现的</p><br/><p>emplace 原地构造一个元素并插入队列</p><p>swap 交换内容</p><br/><p>定义：<code>priority_queue&lt;Type, Container, Functional&gt;</code></p><p>Type 就是数据类型，Container 就是容器类型（Container必须是用数组实现的容器，比如vector,deque等等，但不能用 list</p><p>STL里面默认用的是vector），Functional 就是比较的方式</p><p>当需要用自定义的数据类型时才需要传入这三个参数，使用基本数据类型时，只需要传入数据类型，默认是大顶堆</p><br/><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;升序队列，小顶堆priority_queue &lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; q;&#x2F;&#x2F;降序队列，大顶堆priority_queue &lt;int,vector&lt;int&gt;,less&lt;int&gt; &gt;q;&#x2F;&#x2F;greater和less是std实现的两个仿函数（就是使一个类的使用看上去像一个函数。其实现就是类中实现一个operator()，这个类就有了类似函数的行为，就是一个仿函数类了）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>上文介绍来自于<a href="https://www.cnblogs.com/huashanqingzhu/p/11040390.html">某博客</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c </tag>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Matery主题的优化</title>
      <link href="2021/02/15/Matery%E4%B8%BB%E9%A2%98%E7%9A%84%E4%BC%98%E5%8C%96/"/>
      <url>2021/02/15/Matery%E4%B8%BB%E9%A2%98%E7%9A%84%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>引用的网站来自<a href="https://blog.csdn.net/kuashijidexibao/article/details/112971657">https://blog.csdn.net/kuashijidexibao/article/details/112971657</a></p><br/><h2 id="更改默认值"><a href="#更改默认值" class="headerlink" title="更改默认值"></a>更改默认值</h2><br/><p>首先为了新建文章方便，我们可以修改一下文章模板，可以将<code>/scaffolds/post.md</code>修改为如下代码：</p><br/><pre class="line-numbers language-markdown" data-language="markdown"><code class="language-markdown">---title: &#123;&#123; title &#125;&#125;date: &#123;&#123; date &#125;&#125;author: img: coverImg: top: falsecover: falsetoc: truemathjax: falsepassword:summary:keywords:tags:categories:---<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>我这里加”-“好像会报<code>end of the stream or a document separator is expected</code>的错误</p><p>如果也有类似的错误，请把他们去掉</p><br/><h2 id="Front-matter-选项详解"><a href="#Front-matter-选项详解" class="headerlink" title="Front-matter 选项详解"></a>Front-matter 选项详解</h2><br/><p><code>Front-matter</code> 选项中的所有内容均为<strong>非必填</strong>的。但原作者建议至少填写 <code>title</code> 和 <code>date</code> 的值</p><br/><table><thead><tr><th>配置选项</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td>title</td><td><code>Markdown</code> 的文件标题</td><td>文章标题，强烈建议填写此选项</td></tr><tr><td>date</td><td>文件创建时的日期时间</td><td>发布时间，强烈建议填写此选项，且最好保证全局唯一</td></tr><tr><td>author</td><td>根 <code>_config.yml</code> 中的 <code>author</code></td><td>文章作者</td></tr><tr><td>img</td><td><code>featureImages</code> 中的某个值</td><td>文章特征图，推荐使用图床(腾讯云、七牛云、又拍云等)来做图片的路径.如: <code>http://xxx.com/xxx.jpg</code></td></tr><tr><td>top</td><td><code>true</code></td><td>推荐文章（文章是否置顶），如果 <code>top</code> 值为 <code>true</code>，则会作为首页推荐文章</td></tr><tr><td>cover</td><td><code>false</code></td><td><code>v1.0.2</code>版本新增，表示该文章是否需要加入到首页轮播封面中</td></tr><tr><td>coverImg</td><td>无</td><td><code>v1.0.2</code>版本新增，表示该文章在首页轮播封面需要显示的图片路径，如果没有，则默认使用文章的特色图片</td></tr><tr><td>password</td><td>无</td><td>文章阅读密码，如果要对文章设置阅读验证密码的话，就可以设置 <code>password</code> 的值，该值必须是用 <code>SHA256</code> 加密后的密码，防止被他人识破。前提是在主题的 <code>config.yml</code> 中激活了 <code>verifyPassword</code> 选项</td></tr><tr><td>toc</td><td><code>true</code></td><td>是否开启 TOC，可以针对某篇文章单独关闭 TOC 的功能。前提是在主题的 <code>config.yml</code> 中激活了 <code>toc</code> 选项</td></tr><tr><td>mathjax</td><td><code>false</code></td><td>是否开启数学公式支持 ，本文章是否开启 <code>mathjax</code>，且需要在主题的 <code>_config.yml</code> 文件中也需要开启才行</td></tr><tr><td>summary</td><td>无</td><td>文章摘要，自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要</td></tr><tr><td>categories</td><td>无</td><td>文章分类，本主题的分类表示宏观上大的分类，只建议一篇文章一个分类</td></tr><tr><td>tags</td><td>无</td><td>文章标签，一篇文章可以多个标签</td></tr><tr><td>keywords</td><td>文章标题</td><td>文章关键字，SEO 时需要</td></tr><tr><td>reprintPolicy</td><td>cc_by</td><td>文章转载规则， 可以是 cc_by, cc_by_nd, cc_by_sa, cc_by_nc, cc_by_nc_nd, cc_by_nc_sa, cc0, noreprint 或 pay 中的一个</td></tr></tbody></table><br/><p>关于文章封面的问题，不知为何在本地加载会稍微慢一些，可能是分辨率过高的原因</p><p>（毕竟GitHub连接不是很稳定）</p><br/><h2 id="Matery-添加加载动画"><a href="#Matery-添加加载动画" class="headerlink" title="Matery 添加加载动画"></a>Matery 添加加载动画</h2><br/><h3 id="1、在主题-layout-partial-目录新建一个loading-pages-ejs-内容如下："><a href="#1、在主题-layout-partial-目录新建一个loading-pages-ejs-内容如下：" class="headerlink" title="1、在主题 /layout/_partial/目录新建一个loading-pages.ejs 内容如下："></a>1、在主题 /layout/_partial/<code>目录新建一个</code>loading-pages.ejs 内容如下：</h3><br/><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text/css<span class="token punctuation">"</span></span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>css<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token style"><span class="token language-css">    <span class="token selector">#loading-container</span><span class="token punctuation">&#123;</span>        <span class="token property">position</span><span class="token punctuation">:</span> fixed<span class="token punctuation">;</span>        <span class="token property">top</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>        <span class="token property">left</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>        <span class="token property">min-height</span><span class="token punctuation">:</span> 100vh<span class="token punctuation">;</span>        <span class="token property">width</span><span class="token punctuation">:</span> 100vw<span class="token punctuation">;</span>        <span class="token property">z-index</span><span class="token punctuation">:</span> 9999<span class="token punctuation">;</span>        <span class="token property">display</span><span class="token punctuation">:</span> flex<span class="token punctuation">;</span>        <span class="token property">flex-direction</span><span class="token punctuation">:</span> column<span class="token punctuation">;</span>        <span class="token property">justify-content</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span>        <span class="token property">align-items</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span>        <span class="token property">background</span><span class="token punctuation">:</span> #FFF<span class="token punctuation">;</span>        <span class="token property">text-align</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span>        <span class="token comment">/* loader页面消失采用渐隐的方式*/</span>        <span class="token property">-webkit-transition</span><span class="token punctuation">:</span> opacity 1s ease<span class="token punctuation">;</span>        <span class="token property">-moz-transition</span><span class="token punctuation">:</span> opacity 1s ease<span class="token punctuation">;</span>        <span class="token property">-o-transition</span><span class="token punctuation">:</span> opacity 1s ease<span class="token punctuation">;</span>        <span class="token property">transition</span><span class="token punctuation">:</span> opacity 1s ease<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token selector">.loading-image</span><span class="token punctuation">&#123;</span>        <span class="token property">width</span><span class="token punctuation">:</span> 120px<span class="token punctuation">;</span>        <span class="token property">height</span><span class="token punctuation">:</span> 50px<span class="token punctuation">;</span>        <span class="token property">transform</span><span class="token punctuation">:</span> <span class="token function">translate</span><span class="token punctuation">(</span>-50%<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token selector">.loading-image div:nth-child(2)</span> <span class="token punctuation">&#123;</span>        <span class="token property">-webkit-animation</span><span class="token punctuation">:</span> pacman-balls 1s linear 0s infinite<span class="token punctuation">;</span>        <span class="token property">animation</span><span class="token punctuation">:</span> pacman-balls 1s linear 0s infinite    <span class="token punctuation">&#125;</span>    <span class="token selector">.loading-image div:nth-child(3)</span> <span class="token punctuation">&#123;</span>        <span class="token property">-webkit-animation</span><span class="token punctuation">:</span> pacman-balls 1s linear .33s infinite<span class="token punctuation">;</span>        <span class="token property">animation</span><span class="token punctuation">:</span> pacman-balls 1s linear .33s infinite    <span class="token punctuation">&#125;</span>    <span class="token selector">.loading-image div:nth-child(4)</span> <span class="token punctuation">&#123;</span>        <span class="token property">-webkit-animation</span><span class="token punctuation">:</span> pacman-balls 1s linear .66s infinite<span class="token punctuation">;</span>        <span class="token property">animation</span><span class="token punctuation">:</span> pacman-balls 1s linear .66s infinite    <span class="token punctuation">&#125;</span>    <span class="token selector">.loading-image div:nth-child(5)</span> <span class="token punctuation">&#123;</span>        <span class="token property">-webkit-animation</span><span class="token punctuation">:</span> pacman-balls 1s linear .99s infinite<span class="token punctuation">;</span>        <span class="token property">animation</span><span class="token punctuation">:</span> pacman-balls 1s linear .99s infinite    <span class="token punctuation">&#125;</span>   <span class="token selector">.loading-image div:first-of-type</span> <span class="token punctuation">&#123;</span>        <span class="token property">width</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>        <span class="token property">height</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>        <span class="token property">border</span><span class="token punctuation">:</span> 25px solid #49b1f5<span class="token punctuation">;</span>        <span class="token property">border-right-color</span><span class="token punctuation">:</span> transparent<span class="token punctuation">;</span>        <span class="token property">border-radius</span><span class="token punctuation">:</span> 25px<span class="token punctuation">;</span>        <span class="token property">-webkit-animation</span><span class="token punctuation">:</span> rotate_pacman_half_up .5s 0s infinite<span class="token punctuation">;</span>        <span class="token property">animation</span><span class="token punctuation">:</span> rotate_pacman_half_up .5s 0s infinite<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token selector">.loading-image div:nth-child(2)</span> <span class="token punctuation">&#123;</span>        <span class="token property">width</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>        <span class="token property">height</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>        <span class="token property">border</span><span class="token punctuation">:</span> 25px solid #49b1f5<span class="token punctuation">;</span>        <span class="token property">border-right-color</span><span class="token punctuation">:</span> transparent<span class="token punctuation">;</span>        <span class="token property">border-radius</span><span class="token punctuation">:</span> 25px<span class="token punctuation">;</span>        <span class="token property">-webkit-animation</span><span class="token punctuation">:</span> rotate_pacman_half_down .5s 0s infinite<span class="token punctuation">;</span>        <span class="token property">animation</span><span class="token punctuation">:</span> rotate_pacman_half_down .5s 0s infinite<span class="token punctuation">;</span>        <span class="token property">margin-top</span><span class="token punctuation">:</span> -50px<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token atrule"><span class="token rule">@-webkit-keyframes</span> rotate_pacman_half_up</span> <span class="token punctuation">&#123;</span><span class="token selector">0%</span> <span class="token punctuation">&#123;</span><span class="token property">transform</span><span class="token punctuation">:</span> <span class="token function">rotate</span><span class="token punctuation">(</span>270deg<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token selector">50%</span> <span class="token punctuation">&#123;</span><span class="token property">transform</span><span class="token punctuation">:</span> <span class="token function">rotate</span><span class="token punctuation">(</span>1turn<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token selector">to</span> <span class="token punctuation">&#123;</span><span class="token property">transform</span><span class="token punctuation">:</span> <span class="token function">rotate</span><span class="token punctuation">(</span>270deg<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>    <span class="token atrule"><span class="token rule">@keyframes</span> rotate_pacman_half_up</span> <span class="token punctuation">&#123;</span><span class="token selector">0%</span> <span class="token punctuation">&#123;</span><span class="token property">transform</span><span class="token punctuation">:</span> <span class="token function">rotate</span><span class="token punctuation">(</span>270deg<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token selector">50%</span> <span class="token punctuation">&#123;</span><span class="token property">transform</span><span class="token punctuation">:</span> <span class="token function">rotate</span><span class="token punctuation">(</span>1turn<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token selector">to</span> <span class="token punctuation">&#123;</span><span class="token property">transform</span><span class="token punctuation">:</span> <span class="token function">rotate</span><span class="token punctuation">(</span>270deg<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>    <span class="token atrule"><span class="token rule">@-webkit-keyframes</span> rotate_pacman_half_down</span> <span class="token punctuation">&#123;</span><span class="token selector">0%</span> <span class="token punctuation">&#123;</span><span class="token property">transform</span><span class="token punctuation">:</span> <span class="token function">rotate</span><span class="token punctuation">(</span>90deg<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token selector">50%</span> <span class="token punctuation">&#123;</span><span class="token property">transform</span><span class="token punctuation">:</span> <span class="token function">rotate</span><span class="token punctuation">(</span>0deg<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token selector">to</span> <span class="token punctuation">&#123;</span><span class="token property">transform</span><span class="token punctuation">:</span> <span class="token function">rotate</span><span class="token punctuation">(</span>90deg<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>    <span class="token atrule"><span class="token rule">@keyframes</span> rotate_pacman_half_down</span> <span class="token punctuation">&#123;</span><span class="token selector">0%</span> <span class="token punctuation">&#123;</span><span class="token property">transform</span><span class="token punctuation">:</span> <span class="token function">rotate</span><span class="token punctuation">(</span>90deg<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token selector">50%</span> <span class="token punctuation">&#123;</span><span class="token property">transform</span><span class="token punctuation">:</span> <span class="token function">rotate</span><span class="token punctuation">(</span>0deg<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token selector">to</span> <span class="token punctuation">&#123;</span><span class="token property">transform</span><span class="token punctuation">:</span> <span class="token function">rotate</span><span class="token punctuation">(</span>90deg<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>    <span class="token atrule"><span class="token rule">@-webkit-keyframes</span> pacman-balls</span> <span class="token punctuation">&#123;</span><span class="token selector">75%</span> <span class="token punctuation">&#123;</span><span class="token property">opacity</span><span class="token punctuation">:</span> .7<span class="token punctuation">&#125;</span><span class="token selector">to</span> <span class="token punctuation">&#123;</span><span class="token property">transform</span><span class="token punctuation">:</span> <span class="token function">translate</span><span class="token punctuation">(</span>-100px<span class="token punctuation">,</span> -6.25px<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>    <span class="token atrule"><span class="token rule">@keyframes</span> pacman-balls</span> <span class="token punctuation">&#123;</span><span class="token selector">75%</span> <span class="token punctuation">&#123;</span><span class="token property">opacity</span><span class="token punctuation">:</span> .7<span class="token punctuation">&#125;</span><span class="token selector">to</span> <span class="token punctuation">&#123;</span><span class="token property">transform</span><span class="token punctuation">:</span> <span class="token function">translate</span><span class="token punctuation">(</span>-100px<span class="token punctuation">,</span> -6.25px<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>    <span class="token selector">.loading-image div:nth-child(3),    .loading-image div:nth-child(4),    .loading-image div:nth-child(5),    .loading-image div:nth-child(6)</span><span class="token punctuation">&#123;</span>        <span class="token property">background-color</span><span class="token punctuation">:</span> #49b1f5<span class="token punctuation">;</span>        <span class="token property">width</span><span class="token punctuation">:</span> 15px<span class="token punctuation">;</span>        <span class="token property">height</span><span class="token punctuation">:</span> 15px<span class="token punctuation">;</span>        <span class="token property">border-radius</span><span class="token punctuation">:</span> 100%<span class="token punctuation">;</span>        <span class="token property">margin</span><span class="token punctuation">:</span> 2px<span class="token punctuation">;</span>        <span class="token property">width</span><span class="token punctuation">:</span> 10px<span class="token punctuation">;</span>        <span class="token property">height</span><span class="token punctuation">:</span> 10px<span class="token punctuation">;</span>        <span class="token property">position</span><span class="token punctuation">:</span> absolute<span class="token punctuation">;</span>        <span class="token property">transform</span><span class="token punctuation">:</span> <span class="token function">translateY</span><span class="token punctuation">(</span>-6.25px<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token property">top</span><span class="token punctuation">:</span> 25px<span class="token punctuation">;</span>        <span class="token property">left</span><span class="token punctuation">:</span> 100px<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token selector">.loading-text</span><span class="token punctuation">&#123;</span>        <span class="token property">margin-bottom</span><span class="token punctuation">:</span> 20vh<span class="token punctuation">;</span>        <span class="token property">text-align</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span>        <span class="token property">color</span><span class="token punctuation">:</span> #2c3e50<span class="token punctuation">;</span>        <span class="token property">font-size</span><span class="token punctuation">:</span> 2rem<span class="token punctuation">;</span>        <span class="token property">box-sizing</span><span class="token punctuation">:</span> border-box<span class="token punctuation">;</span>        <span class="token property">padding</span><span class="token punctuation">:</span> 0 10px<span class="token punctuation">;</span>        <span class="token property">text-shadow</span><span class="token punctuation">:</span> 0 2px 10px <span class="token function">rgba</span><span class="token punctuation">(</span>0<span class="token punctuation">,</span>0<span class="token punctuation">,</span>0<span class="token punctuation">,</span>0.2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token atrule"><span class="token rule">@media</span> <span class="token keyword">only</span> screen <span class="token keyword">and</span> <span class="token punctuation">(</span><span class="token property">max-width</span><span class="token punctuation">:</span> 500px<span class="token punctuation">)</span></span> <span class="token punctuation">&#123;</span>         <span class="token selector">.loading-text</span><span class="token punctuation">&#123;</span>            <span class="token property">font-size</span><span class="token punctuation">:</span> 1.5rem<span class="token punctuation">;</span>         <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token selector">.fadeout</span> <span class="token punctuation">&#123;</span>        <span class="token property">opacity</span><span class="token punctuation">:</span> 0<span class="token punctuation">;</span>        <span class="token property">filter</span><span class="token punctuation">:</span> <span class="token function">alpha</span><span class="token punctuation">(</span>opacity=0<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token comment">/* logo出现动画 */</span>    <span class="token atrule"><span class="token rule">@-webkit-keyframes</span> fadeInDown</span><span class="token punctuation">&#123;</span><span class="token selector">0%</span><span class="token punctuation">&#123;</span><span class="token property">opacity</span><span class="token punctuation">:</span>0<span class="token punctuation">;</span><span class="token property">-webkit-transform</span><span class="token punctuation">:</span><span class="token function">translate3d</span><span class="token punctuation">(</span>0<span class="token punctuation">,</span>-100%<span class="token punctuation">,</span>0<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token property">transform</span><span class="token punctuation">:</span><span class="token function">translate3d</span><span class="token punctuation">(</span>0<span class="token punctuation">,</span>-100%<span class="token punctuation">,</span>0<span class="token punctuation">)</span><span class="token punctuation">&#125;</span><span class="token selector">100%</span><span class="token punctuation">&#123;</span><span class="token property">opacity</span><span class="token punctuation">:</span>1<span class="token punctuation">;</span><span class="token property">-webkit-transform</span><span class="token punctuation">:</span>none<span class="token punctuation">;</span><span class="token property">transform</span><span class="token punctuation">:</span>none<span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>    <span class="token atrule"><span class="token rule">@keyframes</span> fadeInDown</span><span class="token punctuation">&#123;</span><span class="token selector">0%</span><span class="token punctuation">&#123;</span><span class="token property">opacity</span><span class="token punctuation">:</span>0<span class="token punctuation">;</span><span class="token property">-webkit-transform</span><span class="token punctuation">:</span><span class="token function">translate3d</span><span class="token punctuation">(</span>0<span class="token punctuation">,</span>-100%<span class="token punctuation">,</span>0<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span> </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script"><span class="token language-javascript"><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">const</span> <span class="token function-variable function">loaded</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>       <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>            <span class="token keyword">const</span> loader <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"loading-container"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            loader<span class="token punctuation">.</span>className<span class="token operator">=</span><span class="token string">"fadeout"</span> <span class="token punctuation">;</span><span class="token comment">//使用渐隐的方法淡出loading page</span>            <span class="token comment">// document.getElementById("body-wrap").style.display="flex";</span>            <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>                loader<span class="token punctuation">.</span>style<span class="token punctuation">.</span>display<span class="token operator">=</span><span class="token string">"none"</span><span class="token punctuation">;</span>            <span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token number">2500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token punctuation">&#125;</span><span class="token punctuation">,</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//强制显示loading page 1s  </span>    <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>    <span class="token function">loaded</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><h3 id="2、在主题的-layout-目录找到-layout-ejs-文件"><a href="#2、在主题的-layout-目录找到-layout-ejs-文件" class="headerlink" title="2、在主题的 layout 目录找到 layout.ejs 文件"></a>2、在主题的 <code>layout</code> 目录找到 <code>layout.ejs</code> 文件</h3><br/><p>在 <code>&lt;body&gt;</code> 附近添加内容后如下：</p><br/><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">DOCTYPE</span> <span class="token name">HTML</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>&lt;%= config.language %><span class="token punctuation">"</span></span><span class="token punctuation">></span></span>&lt;%- partial('_partial/head') %> &lt;% if (theme.loadingPages.enable) &#123; %>    &lt;%- partial('_partial/loading-pages') %> &lt;% &#125; %><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>    &lt;% if (theme.loadingPages.enable) &#123; %>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>loading-container<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>             <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>loading-text<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>嘘~  正在从服务器偷取页面 . . . <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>              <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>loading-image<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>                 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>                 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>                 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>                 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>                  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>             <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>    &lt;% &#125; %>    &lt;%- partial('_partial/header') %><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><h3 id="3、在主题配置文件-config-yml添加开关配置"><a href="#3、在主题配置文件-config-yml添加开关配置" class="headerlink" title="3、在主题配置文件_config.yml添加开关配置"></a>3、在主题配置文件<code>_config.yml</code>添加开关配置</h3><br/><pre class="line-numbers language-yml" data-language="yml"><code class="language-yml">loadingPages:  enable: true  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><br/><p><code>enable</code> 设置为 <code>true</code> 表示开启加载动画， <code>false</code> 表示关闭加载动画。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一个hexo文章</title>
      <link href="2021/02/11/%E7%AC%AC%E4%B8%80%E4%B8%AAhexo%E6%96%87%E7%AB%A0/"/>
      <url>2021/02/11/%E7%AC%AC%E4%B8%80%E4%B8%AAhexo%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h3 id="hexo的基本操作"><a href="#hexo的基本操作" class="headerlink" title="hexo的基本操作"></a>hexo的基本操作</h3><br/><p>hexo clean</p><p>可以清除数据，如果增添相册功能需要这个步骤不断对博客进行更新</p><p>hexo generate(hexo g)</p><p>可以将本地文件转到git中</p><p>hexo deploy(hexo d)</p><p>在第二步的基础上，将文件内容部署到博客上</p><p>hexo server(hexo s)，这是在本地进行测试，如果这一步出问题了，你就需要好好看看git的报错信息了</p><p>检测hexo服务器是否运行正常 </p><p>如果通过但是博客依然有问题，可能是GitHub连接不稳定导致的，建议还是买一个ip（学生优惠不会很贵的）</p><p>hexo new “title”</p><p>这之后会在post文件夹中添加一个md文件，可以在其中进行编辑然后上传到博客</p><br/><h3 id="安装git插件"><a href="#安装git插件" class="headerlink" title="安装git插件"></a>安装git插件</h3><br/><p>npm install hexo-deployer-git –save</p><p>这样之后就可以deploy相关的内容了</p><br/><h3 id="Github仓库本地转移"><a href="#Github仓库本地转移" class="headerlink" title="Github仓库本地转移"></a>Github仓库本地转移</h3><br/><ol><li><p>登录github官网点击创建New repository<br/><br><img src="https://img-blog.csdnimg.cn/20200525091012283.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VsaXphYmVnaW5nZXI=,size_16,color_FFFFFF,t_70#pic_center" alt="创建新仓库"></p></li><li><p>根据如下分别填写仓库名（必填）以及描述（选填），一般默认选择“Public”，然后点击create创建<br/><br><img src="https://img-blog.csdnimg.cn/20200525091328124.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VsaXphYmVnaW5nZXI=,size_16,color_FFFFFF,t_70#pic_center" alt="仓库的属性"></p></li><li><p>完成创建，此时我们要记住我们创建得仓库得地址，我这里是<a href="https://github.com/YJH148/our_repository.git">https://github.com/YJH148/our_repository.git</a><br/><br><img src="https://img-blog.csdnimg.cn/20200525091341793.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VsaXphYmVnaW5nZXI=,size_16,color_FFFFFF,t_70#pic_center" alt="仓库初始界面"></p><p>前提条件是已经在自己得客户端安装了git软件，直接搜索git官网下载最新版本即可<br/><br>(1) 打开cmd，执行 git clone <a href="https://github.com/***/our_repository.git%EF%BC%8C%E5%B0%86%E8%87%AA%E5%B7%B1%E7%9A%84%E4%BB%93%E5%BA%93%E6%8B%B7%E8%B4%9D%E5%88%B0%E8%87%AA%E5%B7%B1%E5%BE%97%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD">https://github.com/***/our_repository.git，将自己的仓库拷贝到自己得计算机中</a><br/><br><img src="https://img-blog.csdnimg.cn/20200525091358771.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VsaXphYmVnaW5nZXI=,size_16,color_FFFFFF,t_70#pic_center" alt="这里其实可以用git">***</p><p>(2) 查看自己得目录，即C:\Users(自己得用户名)下面会有刚刚下载得仓库文件夹<br/><br><img src="https://img-blog.csdnimg.cn/20200525091418319.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VsaXphYmVnaW5nZXI=,size_16,color_FFFFFF,t_70#pic_center" alt="具体位置"></p><p>(3) 在cmd上执行命令cd our_repository进入到该文件夹中，然后输入dir /b 可以查看当前目录下得文件<br/><br><img src="https://img-blog.csdnimg.cn/20200525091431637.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VsaXphYmVnaW5nZXI=,size_16,color_FFFFFF,t_70#pic_center" alt="命令行显示"></p><p>(4) 将要上传得内容拷贝到该文件夹中，比如我将study文件夹拷贝到该文件夹中<br/><br><img src="https://img-blog.csdnimg.cn/20200525091444250.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VsaXphYmVnaW5nZXI=,size_16,color_FFFFFF,t_70#pic_center" alt="拷贝想要的文件"></p><p>(5) 执行git add .命令。”.”表示将当前目录下所有改动的文件夹及文件添加到我们得版本管理器中（提示可忽略）<br/><br><img src="https://img-blog.csdnimg.cn/20200525091547326.png#pic_center" alt="git add ."></p><p>(6) 执行git commit -m “First commit”命令，提交到本地的版本控制库里，First commit是对本次提交的说明信息（假设第一次提交）<br/><br><img src="https://img-blog.csdnimg.cn/20200525091557903.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VsaXphYmVnaW5nZXI=,size_16,color_FFFFFF,t_70#pic_center" alt="git commit -m"></p><p>(7) 执行” git push origin master“命令将本地仓库提交到远程的GitHub中（需要登录github账户，这里得密码默认是不显示得，输入就行）<br/><br><img src="https://img-blog.csdnimg.cn/20200525091608946.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VsaXphYmVnaW5nZXI=,size_16,color_FFFFFF,t_70#pic_center" alt="git push"></p><p>(8) 完成上述操作后，打开自己得github，即可看见刚刚上传得study文件<br/></p></li></ol><p><img src="https://img-blog.csdnimg.cn/20200525091623578.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VsaXphYmVnaW5nZXI=,size_16,color_FFFFFF,t_70" alt="成了（x"><br><img src="https://img-blog.csdnimg.cn/20200525091623574.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VsaXphYmVnaW5nZXI=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><br/><h3 id="关闭openssl"><a href="#关闭openssl" class="headerlink" title="关闭openssl"></a>关闭openssl</h3><br/><p>当你通过HTTPS访问Git远程仓库，如果服务器的SSL证书未经过第三方机构签署，那么Git就会报错。这是十分合理的设计，毕竟未知的没有签署过的证书意味着很大安全风险。但是，如果你正好在架设Git服务器，而正式的SSL证书没有签发下来，你为了赶时间生成了自签署的临时证书，怎样才是最便捷的测试手段</p><br/><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">git config http.sslVerify &quot;false&quot; <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br/><h3 id="谈谈自己的一些失败之处"><a href="#谈谈自己的一些失败之处" class="headerlink" title="谈谈自己的一些失败之处"></a>谈谈自己的一些失败之处</h3><br/><p>首先传递的文件过大导致一直卡在deploy处的问题：</p><p>实在是令我十分无语，因为自己组织语言的能力太弱了，导致两天一直以为是git追踪文件缓存的问题</p><p>然后过年玩了几天，转念一想，不对啊，git跟hexo有什么关系</p><p>之后才了解deploy有专门的文件夹，删除之后重新部署就什么事都没有了（x</p><p>。。。。。我真不知道该怎么说自己好</p><br/><h3 id="之后的打算-不断完善ing"><a href="#之后的打算-不断完善ing" class="headerlink" title="之后的打算(不断完善ing)"></a>之后的打算(不断完善ing)</h3><br/><p>既然woc有咕咕的意思，那么就再搞搞博客，明天开始继续学Java吧（x</p><p>再这么悠闲下去也不是什么事（看看黄老板​​）</p><p>然后是早睡，最近身体不是很想熬夜了（建议看看工作细胞black​​）</p><p>最后还要把图片的问题搞定，自己也决定要去视频组继续学习，态度可不能怠慢下来（文明是真的上头啊）</p><p>5.1以后更新</p><p>在开学两个月之后，对自己的学习的环境硬件配置进行了不断的更新（红轴+AOC显示屏）（这真的只是想提高生产效率）</p><p>在这之后，原本我以为课上得少了学习就不会多忙了</p><p>但是事情是和预想的想违背的，高数离散的难度不断加大（其实也没多难，就是我上课不听罢了（x），整理笔记和其他社团上的事情，以及上机和我本身学习热情的下降，自学难度的提高，学长的。。。。咕咕咕？都又一定的影响，我也是人，也想做一些自己感兴趣的东西，还要多学点后端，准备接手新邮杯的烂摊子（x</p><p>总而言之，还是继续学吧，在这里无病呻吟什么也改变不了</p><p>（插一句，typora更新完之后真心不错，完善了一些细节让我很喜欢）</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>laravel 视图</title>
      <link href="2021/02/08/laravel-%E8%A7%86%E5%9B%BE/"/>
      <url>2021/02/08/laravel-%E8%A7%86%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<h3 id="创建视图"><a href="#创建视图" class="headerlink" title="创建视图"></a>创建视图</h3><br/><p>视图包含应用程序的 HTML 服务，并且将控制器 / 应用程序逻辑与演示逻辑分开。视图文件存放于 <code>resources/views</code> 目录下</p><p>视图存储到 <code>resources/views/greeting.blade.php</code> 后（一定要加<code>blade</code>），我们可以使用全局辅助函数 <code>view</code> 将其返回</p><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">Route::get(&#39;&#x2F;&#39;, function () &#123;    return view(&#39;greeting&#39;, [&#39;name&#39; &#x3D;&gt; &#39;James&#39;]);&#125;);&#x2F;&#x2F;传递了一个name变量<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><br/><p>如果视图存储在 <code>resources/views/admin/profile.blade.php</code>，则可以这样引用它</p><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">return view(&#39;admin.profile&#39;, $data);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br/><p>视图目录名中不应该包含 <code>.</code> 字符</p><br/><h4 id="判断视图是否存在"><a href="#判断视图是否存在" class="headerlink" title="判断视图是否存在"></a>判断视图是否存在</h4><br/><p>如果需要判断视图文件是否存在，可以使用 <code>View</code> facade。如果存在，<code>exists</code> 方法会返回 <code>true</code></p><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">use Illuminate\Support\Facades\View;if (View::exists(&#39;emails.customer&#39;)) &#123;    &#x2F;&#x2F;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><h4 id="创建一个可用视图"><a href="#创建一个可用视图" class="headerlink" title="创建一个可用视图"></a>创建一个可用视图</h4><br/><p>使用 <code>first</code> 方法，你可以创建给定数组视图中第一个存在的视图</p><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">return view()-&gt;first([&#39;custom.admin&#39;, &#39;admin&#39;], $data);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br/><p>当然，也可以通过 <code>View </code>  facade调用这个方法</p><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">use Illuminate\Support\Facades\View;return View::first([&#39;custom.admin&#39;, &#39;admin&#39;], $data);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><br/><h3 id="向视图传递数据"><a href="#向视图传递数据" class="headerlink" title="向视图传递数据"></a>向视图传递数据</h3><br/><p>正如在前面的示例中所看到的，可以将一组数据传递给视图</p><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">return view(&#39;greetings&#39;, [&#39;name&#39; &#x3D;&gt; &#39;Victoria&#39;]);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br/><p>以这种方式传递信息时，数据应该是具有键 / 值对的数组</p><p>作为将完整的数据数组传递给 <code>view</code> 辅助函数的替代方法，可以使用 <code>with</code> 方法将各个数据片段添加到视图中</p><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">return view(&#39;greeting&#39;)-&gt;with(&#39;name&#39;, &#39;Victoria&#39;);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br/><p>有时候，可能需要共享一段数据给应用程序的所有视图</p><p>可以在服务提供器的 <code>boot</code> 方法中调用视图门面（Facade）的 <code>share</code> 方法</p><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">&lt;?phpnamespace App\Providers;use Illuminate\Support\Facades\View;class AppServiceProvider extends ServiceProvider&#123;    &#x2F;**     * Register any application services.     *     * @return void     *&#x2F;    public function register()    &#123;        &#x2F;&#x2F;    &#125;    &#x2F;**     * Bootstrap any application services.     *     * @return void     *&#x2F;    public function boot()    &#123;        View::share(&#39;key&#39;, &#39;value&#39;);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><h3 id="视图合成器"><a href="#视图合成器" class="headerlink" title="视图合成器"></a>视图合成器</h3><br/><p>默认情况下，<code>Laravel</code> 没有存放视图合成器的目录，可以根据需要来重新建立目录</p><p>在一个 <a href="https://learnku.com/docs/laravel/8.x/providers">service provider</a> 中注册视图合成器，使用 <code>View</code> 门面（Facade）来实现访问底层的 <code>Illuminate\Contracts\View\Factory</code> 契约</p><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">&lt;?phpnamespace App\Providers;use Illuminate\Support\Facades\View;use Illuminate\Support\ServiceProvider;class ViewServiceProvider extends ServiceProvider&#123;    &#x2F;**     * Register any application services.     *     * @return void     *&#x2F;    public function register()    &#123;        &#x2F;&#x2F;    &#125;    &#x2F;**     * Bootstrap any application services.     *     * @return void     *&#x2F;    public function boot()    &#123;        &#x2F;&#x2F; Using class based composers...        View::composer(            &#39;profile&#39;, &#39;App\Http\View\Composers\ProfileComposer&#39;        );        &#x2F;&#x2F; Using Closure based composers...        View::composer(&#39;dashboard&#39;, function ($view) &#123;            &#x2F;&#x2F;        &#125;);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>现在注册了视图合成器，每次渲染 <code>profile</code> 视图时都会执行 <code>ProfileComposer@compose</code> 方法</p><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">&lt;?phpnamespace App\Http\View\Composers;use App\Repositories\UserRepository;use Illuminate\View\View;class ProfileComposer&#123;    &#x2F;**     * The user repository implementation.     *     * @var UserRepository     *&#x2F;    protected $users;    &#x2F;**     * Create a new profile composer.     *     * @param  UserRepository  $users     * @return void     *&#x2F;    public function __construct(UserRepository $users)    &#123;        &#x2F;&#x2F; Dependencies automatically resolved by service container...        $this-&gt;users &#x3D; $users;    &#125;    &#x2F;**     * Bind data to the view.     *     * @param  View  $view     * @return void     *&#x2F;    public function compose(View $view)    &#123;        $view-&gt;with(&#39;count&#39;, $this-&gt;users-&gt;count());    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>视图合成器的 <code>compose</code> 方法会在视图渲染之前被调用，并传入一个 <code>Illuminate\View\View</code> 实例</p><p>可以使用 <code>with</code> 方法将数据绑定到视图</p><br/><h4 id="将视图合成器添加到多个视图"><a href="#将视图合成器添加到多个视图" class="headerlink" title="将视图合成器添加到多个视图"></a>将视图合成器添加到多个视图</h4><br/><p>将一组视图作为第一个参数传入 <code>composer</code> 方法，可以一次添加多个视图到视图合成器中</p><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">View::composer(    [&#39;profile&#39;, &#39;dashboard&#39;],    &#39;App\Http\View\Composers\MyViewComposer&#39;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><br/><p><code>composer</code> 方法同时也接受通配符 <code>*</code> ，表示将所有视图添加到视图合成器中</p><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">View::composer(&#39;*&#39;, function ($view) &#123;    &#x2F;&#x2F;&#125;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><br/><h4 id="视图构造器"><a href="#视图构造器" class="headerlink" title="视图构造器"></a>视图构造器</h4><br/><p>视图构造器（creators）和视图合成器非常相似</p><p>唯一不同之处在于视图构造器在视图实例化之后执行，而视图合成器在视图即将渲染时执行</p><p>使用 <code>creator</code> 方法注册视图构造器</p><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">View::creator(&#39;profile&#39;, &#39;App\Http\View\Creators\ProfileCreator&#39;);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br/><h3 id="视图优化"><a href="#视图优化" class="headerlink" title="视图优化"></a>视图优化</h3><br/><p>Laravel 提供了 <code>view：cache</code> Artisan 命令来预编译应用中使用的所有视图文件</p><p>可以使用 <code>view：clear</code> 命令清除视图缓存</p><br/><h3 id="自己最后的感悟"><a href="#自己最后的感悟" class="headerlink" title="自己最后的感悟"></a>自己最后的感悟</h3><br/><p>这种光看不练的模式直接导致我浪费了一个星期的时间（x</p><p>在这之后我已经思考过了，这种东西搬到博客上来，一是方便记录，二是温习我曾经的学习记录</p><p>（其实已经忘得差不多了）</p><p>毕竟以后自己是要走后端路，这种东西还是要常看的，前端自己只能是个小白等级</p><br/><p>而且，马上大一下的课程就要开始了</p><p>自己的文化课比其他专业要少，所以打算直接三开（</p><p>绩点自己能保证3.5就可以，主要是把精力放在项目和实战上，c++/Java，这些基础夯实</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php </tag>
            
            <tag> laravel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>laravel 控制器</title>
      <link href="2021/02/08/laravel-%E6%8E%A7%E5%88%B6%E5%99%A8/"/>
      <url>2021/02/08/laravel-%E6%8E%A7%E5%88%B6%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>路由除了闭包的形式，也可以引用控制器控制器能将相关的请求处理逻辑组成一个单独的类</p><p>控制器被存放在 <code>app/Http/Controllers</code> 目录，当然也可以自定义</p><br/><h3 id="基础控制器"><a href="#基础控制器" class="headerlink" title="基础控制器"></a>基础控制器</h3><br/><h4 id="定义控制器"><a href="#定义控制器" class="headerlink" title="定义控制器"></a>定义控制器</h4><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">&lt;?phpnamespace App\Http\Controllers;use App\Http\Controllers\Controller;use App\Models\User;class UserController extends Controller&#123;    &#x2F;**     * 显示指定用户的简介     *     * @param  int  $id     * @return \Illuminate\View\View     *&#x2F;    public function show($id)    &#123;        return view(&#39;user.profile&#39;, [&#39;user&#39; &#x3D;&gt; User::findOrFail($id)]);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p><code>middleware</code>方法也可以为控制器添加中间件</p><br/><p>也可以定义指向控制器的路由</p><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">use App\Http\Controllers\UserController;Route::get(&#39;user&#x2F;&#123;id&#125;&#39;, [UserController::class, &#39;show&#39;]);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><br/><p>控制器并不是 必需 继承基础类。如果控制器没有继承基础类，将无法使用一些便捷的功能</p><br/><h4 id="单行为控制器"><a href="#单行为控制器" class="headerlink" title="单行为控制器"></a>单行为控制器</h4><br/><p>想要定义一个只处理单个行为的控制器，你可以在控制器中放置一个 <code>__invoke</code> 方法</p><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">&lt;?phpnamespace App\Http\Controllers;use App\Http\Controllers\Controller;use App\Models\User;class ShowProfile extends Controller&#123;    &#x2F;**     * 显示指定用户的简介     *     * @param  int  $id     * @return \Illuminate\View\View     *&#x2F;    public function __invoke($id)    &#123;        return view(&#39;user.profile&#39;, [&#39;user&#39; &#x3D;&gt; User::findOrFail($id)]);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>注册单个行为控制器的路由时不需要指名方法</p><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">use App\Http\Controllers\ShowProfile;Route::get(&#39;user&#x2F;&#123;id&#125;&#39;, ShowProfile::class);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><br/><p>可以通过 Artisan 命令工具里的 <code>make:controller</code> 命令中的 <code>--invokable</code> 选项来生成一个可调用的控制器</p><br/><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">php artisan make:controller ShowProfile --invokable<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br/><h3 id="控制器中间件"><a href="#控制器中间件" class="headerlink" title="控制器中间件"></a>控制器中间件</h3><br/><p>中间件可以在路由文件中分配给控制器的路由</p><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">Route::get(&#39;profile&#39;, [UserController::class, &#39;show&#39;])-&gt;middleware(&#39;auth&#39;);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br/><p>使用控制器构造函数中的 <code>middleware</code> 方法，可以轻松地将中间件分配给控制器</p><p>甚至可以将中间件限制为只在控制器中的某些方法生效</p><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">class UserController extends Controller&#123;    &#x2F;**     * 实例化一个新的控制器实例     *     * @return void     *&#x2F;    public function __construct()    &#123;        $this-&gt;middleware(&#39;auth&#39;);        $this-&gt;middleware(&#39;log&#39;)-&gt;only(&#39;index&#39;);        $this-&gt;middleware(&#39;subscribed&#39;)-&gt;except(&#39;store&#39;);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>控制器还允许使用一个闭包来注册中间件</p><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">$this-&gt;middleware(function ($request, $next) &#123;    &#x2F;&#x2F; ...    return $next($request);&#125;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><h3 id="资源型控制器"><a href="#资源型控制器" class="headerlink" title="资源型控制器"></a>资源型控制器</h3><br/><p>Laravel 的资源路由通过单行代码即可将典型的「CURD (增删改查)」路由分配给控制器</p><p>使用 Artisan 命令 <code>make:controller</code> 可以快速创建这样一个控制器</p><br/><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">php artisan make:controller PhotoController --resource<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br/><p>通过将数组传参到 <code>resources</code> 方法中的方式来一次性的创建多个资源控制器</p><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">Route::resources([    &#39;photos&#39; &#x3D;&gt; PhotoController::class,    &#39;posts&#39; &#x3D;&gt; PostController::class,]);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><br/><h4 id="资源控制器操作处理"><a href="#资源控制器操作处理" class="headerlink" title="资源控制器操作处理"></a>资源控制器操作处理</h4><br/><table><thead><tr><th>Verb</th><th>URL</th><th>Action</th><th>Route Name</th></tr></thead><tbody><tr><td>GET</td><td>/photos</td><td>index</td><td>photos.index</td></tr><tr><td>GET</td><td>/photos/create</td><td>create</td><td>photos.create</td></tr><tr><td>POST</td><td>/photos</td><td>store</td><td>photos.store</td></tr><tr><td>GET</td><td>/photos/{photo}</td><td>show</td><td>photos.show</td></tr><tr><td>GET</td><td>/photos/{photo}/edit</td><td>edit</td><td>photos.edit</td></tr><tr><td>PUT/PATCH</td><td>/photos/{photo}</td><td>update</td><td>photos.update</td></tr><tr><td>DELETE</td><td>/photos/{photo}</td><td>destroy</td><td>photos.destroy</td></tr></tbody></table><br/><h4 id="指定资源模型"><a href="#指定资源模型" class="headerlink" title="指定资源模型"></a>指定资源模型</h4><br/><p>如果使用了路由模型绑定，并且想在资源控制器的方法中使用类型提示，可以在生成控制器的时候使用 <code>--model</code></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">php artisan make:controller PhotoController --resource --model&#x3D;Photo<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br/><p>部分资源路由</p><br/><h4 id="API资源路由"><a href="#API资源路由" class="headerlink" title="API资源路由"></a>API资源路由</h4><br/><p>也可以传递一个数组给 <code>apiResources</code> 方法来同时注册多个 API 资源控制器</p><p>方便起见，可以使用<code>apiResource</code></p><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">Route::apiResource(&#39;photos&#39;, PhotoController::class);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br/><p>也可以传递一个数组给 <code>apiResources</code> 方法来同时注册多个 API 资源控制器</p><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">Route::apiResources([    &#39;photos&#39; &#x3D;&gt; PhotoController::class,    &#39;posts&#39; &#x3D;&gt; PostController::class,]);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><br/><p>要快速生成不包含 <code>create</code> 或 <code>edit</code> 方法的用于开发接口的资源控制器，请在执行 make:controller 命令时使用 <code>--api</code> 参数</p><br/><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">php artisan make:controller API&#x2F;PhotoController --api<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br/><p>虽然我觉得woc中也用不到这些东西（x</p><br/><h4 id="嵌套资源"><a href="#嵌套资源" class="headerlink" title="嵌套资源"></a>嵌套资源</h4><br/><p>有时可能需要定义一个嵌套的资源型路由</p><p>例如，照片资源可能被添加了多个评论。那么可以在路由中使用 “.” 符号来声明资源型控制器</p><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">Route::resource(&#39;photos.comments&#39;, PhotoCommentController::class);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br/><p>该路由会注册一个嵌套资源，可以使用如下 <code>URI</code> 访问</p><p>/photos/{photo}/comments/{comment}</p><br/><h4 id="限定嵌套资源的范围"><a href="#限定嵌套资源的范围" class="headerlink" title="限定嵌套资源的范围"></a>限定嵌套资源的范围</h4><br/><p>Laravel的<code>隐式模型绑定 </code>特性可以自动限定嵌套绑定的范围，因此已解析的子模型会自动属于父模型</p><p>定义嵌套路由时，使用 scoped 方法可以开启自动范围限定，也可以指定 Laravel 应该按照哪个字段检索子模型资源</p><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">Route::resource(&#39;photos.comments&#39;, PhotoCommentController::class)-&gt;scoped([    &#39;comment&#39; &#x3D;&gt; &#39;slug&#39;,]);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><br/><p>这个路由会注册一个限定范围的嵌套资源路由，可以根据以下URL进行访问</p><p>/photos/{photo}/comments/{comment:slug}</p><br/><h4 id="浅层嵌套"><a href="#浅层嵌套" class="headerlink" title="浅层嵌套"></a>浅层嵌套</h4><br/><p>通常，并不完全需要在 <code>URI</code> 中同时拥有父 ID 和子 ID ，因为子 ID 已经是唯一的标识符</p><p>当使用唯一标识符（如自动递增的主键）来标识 <code>URI</code> 中的模型时，可以选择使用「浅嵌套」的方式定义路由</p><pre class="line-numbers language-php" data-language="php"><code class="language-php">Route::resource(&#39;photos.comments&#39;, CommentController::class)-&gt;shallow();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br/><h4 id="命名资源路由"><a href="#命名资源路由" class="headerlink" title="命名资源路由"></a>命名资源路由</h4><br/><p>默认情况下，所有的资源控制器行为都有一个路由名称</p><p>可以传入 <code>names</code> 数组来覆盖这些名称</p><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">Route::resource(&#39;photos&#39;, PhotoController::class)-&gt;names([    &#39;create&#39; &#x3D;&gt; &#39;photos.build&#39;]);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><br/><h4 id="命名资源路由参数"><a href="#命名资源路由参数" class="headerlink" title="命名资源路由参数"></a>命名资源路由参数</h4><br/><p>默认情况下，<code>Route::resource</code> 会根据资源名称的「单数」形式创建资源路由的路由参数</p><p>可以在选项数组中传入 <code>parameters</code> 参数来轻松地覆盖每个资源</p><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">Route::resource(&#39;users&#39;, AdminUserController::class)-&gt;parameters([    &#39;users&#39; &#x3D;&gt; &#39;admin_user&#39;]);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><br/><p>上例将会为资源的 <code>show</code> 路由生成如下的 URI</p><p>/users/{admin_user}</p><br/><h4 id="限定范围的资源路由"><a href="#限定范围的资源路由" class="headerlink" title="限定范围的资源路由"></a>限定范围的资源路由</h4><br/><p>有时绑定了多个模型，希望限定第二个 Eloquent 模型必须为第一个 Eloquent 模型的子模型</p><p>例如，通过 slug 检索某个特殊用户的一篇文章</p><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">use App\Http\Controllers\PostsController;Route::resource(&#39;users.posts&#39;, PostsController::class)-&gt;scoped();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><br/><p>你可以通过给 <code>scoped</code> 方法传递一个数组来覆盖默认的模型路由键</p><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">use App\Http\Controllers\PostsController;Route::resource(&#39;users.posts&#39;, PostsController::class)-&gt;scoped([    &#39;post&#39; &#x3D;&gt; &#39;slug&#39;,]);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><h4 id="本地化URL"><a href="#本地化URL" class="headerlink" title="本地化URL"></a>本地化URL</h4><br/><p>默认情况下，Route::resource 将会用英文动词创建资源 URI</p><p>如果需要自定义 create 和 edit 行为的动作名，可以在 AppServiceProvider 的 boot 中使用 Route::resourceVerbs 方法实现</p><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">use Illuminate\Support\Facades\Route;&#x2F;** * 引导任何应用服务。 * * @return void *&#x2F;public function boot()&#123;    Route::resourceVerbs([        &#39;create&#39; &#x3D;&gt; &#39;crear&#39;,        &#39;edit&#39; &#x3D;&gt; &#39;editar&#39;,    ]);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><h4 id="补充资源控制器"><a href="#补充资源控制器" class="headerlink" title="补充资源控制器"></a>补充资源控制器</h4><br/><p>如果想在资源管理中添加额外的路由，需要在定义之前使用</p><br/><h3 id="依赖注入-amp-控制器"><a href="#依赖注入-amp-控制器" class="headerlink" title="依赖注入&amp;控制器"></a>依赖注入&amp;控制器</h3><br/><h4 id="构造注入"><a href="#构造注入" class="headerlink" title="构造注入"></a>构造注入</h4><br/><p>以在控制器的构造函数中使用类型提示需要的依赖项</p><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">&lt;?phpnamespace App\Http\Controllers;use App\Repositories\UserRepository;class UserController extends Controller&#123;    &#x2F;**     * 用户 repository 实例。     *&#x2F;    protected $users;    &#x2F;**     * 创建一个新的控制器实例。     *     * @param  UserRepository  $users     * @return void     *&#x2F;    public function __construct(UserRepository $users)    &#123;        $this-&gt;users &#x3D; $users;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><h4 id="方法注入"><a href="#方法注入" class="headerlink" title="方法注入"></a>方法注入</h4><br/><p>控制器方法中类型提示依赖，最常见的用法便是注入 <code>Illuminate\Http\Request</code></p><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">&lt;?phpnamespace App\Http\Controllers;use Illuminate\Http\Request;class UserController extends Controller&#123;    &#x2F;**     * 保存一个新用户。     *     * @param  Request  $request     * @return Response     *&#x2F;    public function store(Request $request)    &#123;        $name &#x3D; $request-&gt;name;        &#x2F;&#x2F;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>如果控制器方法要从路由参数中获取输入内容，在依赖项之后列出路由参数</p><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">Route::put(&#39;user&#x2F;&#123;id&#125;&#39;, [UserController::class, &#39;update&#39;]);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br/><p>依然可以类型提示 <code>Illuminate\Http\Request</code> 并通过定义控制器方法访问 <code>id</code> 参数</p><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">&lt;?phpnamespace App\Http\Controllers;use Illuminate\Http\Request;class UserController extends Controller&#123;    &#x2F;**     * 修改指定的用户。     *     * @param  Request  $request     * @param  string  $id     * @return Response     *&#x2F;    public function update(Request $request, $id)    &#123;        &#x2F;&#x2F;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><h3 id="路由缓存"><a href="#路由缓存" class="headerlink" title="路由缓存"></a>路由缓存</h3><br/><p>执行 <code>route:cache</code> Artisan 命令，进行路由缓存</p><br/><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">php artisan route:cache<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br/><p>可使用 <code>route:clear</code> 来清除路由缓存</p><br/><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">php artisan route:clear<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php </tag>
            
            <tag> laravel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>laravel 中间件&amp;csrf保护</title>
      <link href="2021/02/08/laravel-%E4%B8%AD%E9%97%B4%E4%BB%B6-csrf%E4%BF%9D%E6%8A%A4/"/>
      <url>2021/02/08/laravel-%E4%B8%AD%E9%97%B4%E4%BB%B6-csrf%E4%BF%9D%E6%8A%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h2><br/><p>中间件提供了一种方便的机制来过滤进入应用程序的 HTTP 请求</p><p>例如，Laravel 包含一个验证用户身份的中间件。</p><p>如果用户未能通过认证，中间件会把用户重定向到登录面。 反之，用户如果通过验证， 中间件将把请求进一步转发到应用程序中。</p><p>当然，除了验证身份外，还可以编写其他的中间件来执行各种任务</p><p>例如：CORS 中间件可以负责为所有的应用返回的 responses 添加合适的响应头。日志中间件可以记录所有传入应用的请求</p><p>Laravel 自带了一些中间件，包括身份验证、CSRF 保护等。所有的这些中间件都位于 app/Http/Middleware 目录</p><br/><h4 id="定义中间件"><a href="#定义中间件" class="headerlink" title="定义中间件"></a>定义中间件</h4><br/><p>可以使用make:middleware来创建中间件</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">php artisan make:middleware CheckAge<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br/><p>该命令会在 <code>app/Http/Middleware</code> 目录下放置新的 <code>CheckAge</code> 类</p><p>在这个中间件中，我们仅允许 <code>age</code> 参数大于 200 的请求对路由进行访问，否则将重定向到 <code>home</code> 页面</p><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">&lt;?phpnamespace App\Http\Middleware;use Closure;class CheckAge&#123;    &#x2F;**     * 处理传入的请求     *     * @param  \Illuminate\Http\Request  $request     * @param  \Closure  $next     * @return mixed     *&#x2F;    public function handle($request, Closure $next)    &#123;        if ($request-&gt;age &lt;&#x3D; 200) &#123;            return redirect(&#39;home&#39;);        &#125;        return $next($request);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>这个请求将会通过，进一步传递到应用层中</p><p>要让请求继续传到到应用层中 (即允许 「通过」中间件验证), 只需要将 <code>$request</code> 作为参数来调用函数 <code>$next</code> 即可</p><br/><p>中间件作为判断http请求的必经之路，每一层都会检查需求</p><br/><h4 id="前置-amp-后置中间件"><a href="#前置-amp-后置中间件" class="headerlink" title="前置&amp;后置中间件"></a>前置&amp;后置中间件</h4><br/><p>中间件根据设置可以在请求前或请求后执行</p><p>前置例子</p><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">&lt;?phpnamespace App\Http\Middleware;use Closure;class BeforeMiddleware&#123;    public function handle($request, Closure $next)    &#123;        &#x2F;&#x2F; Perform action        return $next($request);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>后置例子</p><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">&lt;?phpnamespace App\Http\Middleware;use Closure;class AfterMiddleware&#123;    public function handle($request, Closure $next)    &#123;        $response &#x3D; $next($request);        &#x2F;&#x2F; Perform action        return $response;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><h4 id="注册中间件"><a href="#注册中间件" class="headerlink" title="注册中间件"></a>注册中间件</h4><br/><h5 id="全局中间件"><a href="#全局中间件" class="headerlink" title="全局中间件"></a>全局中间件</h5><br/><p>如果希望中间件在应用处理每个 <code>HTTP</code> 请求期间运行， 只需要在 <code>app/Http/Kernel.php</code> 中的 <code>$middleware</code> 属性中列出这个中间件</p><br/><h5 id="为路由分配中间件"><a href="#为路由分配中间件" class="headerlink" title="为路由分配中间件"></a>为路由分配中间件</h5><br/><p>假设你想为指定的路由分配中间件 ， 首先应该在 app/Http/Kernel.php 文件内为该中间件分配一个键。</p><p>默认情况下，该类中的 $routeMiddleware 属性下包含了 Laravel 内置的中间件</p><p>若要加入自定义的中间件，只需把它附加到列表后并为其分配一个自定义键</p><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">&#x2F;&#x2F; Within App\Http\Kernel Class...protected $routeMiddleware &#x3D; [    &#39;auth&#39; &#x3D;&gt; \App\Http\Middleware\Authenticate::class,    &#39;auth.basic&#39; &#x3D;&gt; \Illuminate\Auth\Middleware\AuthenticateWithBasicAuth::class,    &#39;bindings&#39; &#x3D;&gt; \Illuminate\Routing\Middleware\SubstituteBindings::class,    &#39;cache.headers&#39; &#x3D;&gt; \Illuminate\Http\Middleware\SetCacheHeaders::class,    &#39;can&#39; &#x3D;&gt; \Illuminate\Auth\Middleware\Authorize::class,    &#39;guest&#39; &#x3D;&gt; \App\Http\Middleware\RedirectIfAuthenticated::class,    &#39;signed&#39; &#x3D;&gt; \Illuminate\Routing\Middleware\ValidateSignature::class,    &#39;throttle&#39; &#x3D;&gt; \Illuminate\Routing\Middleware\ThrottleRequests::class,    &#39;verified&#39; &#x3D;&gt; \Illuminate\Auth\Middleware\EnsureEmailIsVerified::class,];&#x2F;&#x2F;设定键之后就可以根据键名调用不同的中间件<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>设置好之后就可以分配</p><p>可以多分配多个，实行多次判断</p><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">Route::get(&#39;admin&#x2F;profile&#39;, function () &#123;    &#x2F;&#x2F;&#125;)-&gt;middleware(&#39;auth&#39;);Route::get(&#39;&#x2F;&#39;, function () &#123;    &#x2F;&#x2F;&#125;)-&gt;middleware(&#39;first&#39;, &#39;second&#39;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>分配中间件时，还可以传递完全限定的类名</p><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">use App\Http\Middleware\CheckAge;Route::get(&#39;admin&#x2F;profile&#39;, function () &#123;    &#x2F;&#x2F;&#125;)-&gt;middleware(CheckAge::class);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>在中间件分配给路由组时，如果想取消某一路由的中间件可以使用 <code>withoutMiddleware</code> 方法</p><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">use App\Http\Middleware\CheckAge;Route::middleware([CheckAge::class])-&gt;group(function () &#123;    Route::get(&#39;&#x2F;&#39;, function () &#123;        &#x2F;&#x2F;    &#125;);    Route::get(&#39;admin&#x2F;profile&#39;, function () &#123;        &#x2F;&#x2F;    &#125;)-&gt;withoutMiddleware([CheckAge::class]);&#125;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p><code>withoutMiddleware</code> 方法只能删除路由中间件，不适用于全局中间件</p><br/><h4 id="中间件组"><a href="#中间件组" class="headerlink" title="中间件组"></a>中间件组</h4><br/><p>有时，可能希望将多个中间件归为一个键，以使其更易于分配给路由</p><p>可以使用 HTTP 内核的 $middlewareGroups 属性来实现</p><p>Laravel 开箱即用，带有 web 和 api 中间件组，其中包含可能要应用于 Web UI 和 API 路由的通用中间件</p><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">&#x2F;** * 路由中间件组 * * @var array *&#x2F;protected $middlewareGroups &#x3D; [    &#39;web&#39; &#x3D;&gt; [        \App\Http\Middleware\EncryptCookies::class,        \Illuminate\Cookie\Middleware\AddQueuedCookiesToResponse::class,        \Illuminate\Session\Middleware\StartSession::class,        \Illuminate\View\Middleware\ShareErrorsFromSession::class,        \App\Http\Middleware\VerifyCsrfToken::class,        \Illuminate\Routing\Middleware\SubstituteBindings::class,    ],    &#39;api&#39; &#x3D;&gt; [        &#39;throttle:api&#39;,        \Illuminate\Routing\Middleware\SubstituteBindings::class,    ],];<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>中间件组可以使用与单个中间件相同的语法将自身分配给路由和控制器动作</p><p>这样使得语法更加方便</p><br/><p>$\textcolor{red}{RouteServiceProvider 默认将 web中间件组自动应用到 routes/web.php}$</p><br/><p>极少情况下需要对中间件的执行顺序排序</p><p>可以使用 <code>app/Http/Kernel.php</code> 文件中的 <code>$middlewarePriority</code> 属性指定中间件的优先级</p><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">&#x2F;** * 中间件的优先级排序列表 * * 将会强制非全局中间件始终保持给定的顺序 * * @var array *&#x2F;protected $middlewarePriority &#x3D; [    \Illuminate\Session\Middleware\StartSession::class,    \Illuminate\View\Middleware\ShareErrorsFromSession::class,    \Illuminate\Contracts\Auth\Middleware\AuthenticatesRequests::class,    \Illuminate\Routing\Middleware\ThrottleRequests::class,    \Illuminate\Session\Middleware\AuthenticateSession::class,    \Illuminate\Routing\Middleware\SubstituteBindings::class,    \Illuminate\Auth\Middleware\Authorize::class,];<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><h4 id="中间件参数"><a href="#中间件参数" class="headerlink" title="中间件参数"></a>中间件参数</h4><br/><p>中间件还可以接收额外的参数</p><p>附加的中间参数会在 <code>$next</code> 参数之后传递给中间件</p><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">&lt;?phpnamespace App\Http\Middleware;use Closure;class CheckRole&#123;    &#x2F;**     * 处理传入的请求     *     * @param  \Illuminate\Http\Request  $request     * @param  \Closure  $next     * @param  string  $role     * @return mixed     *&#x2F;    public function handle($request, Closure $next, $role)    &#123;        if (! $request-&gt;user()-&gt;hasRole($role)) &#123;            &#x2F;&#x2F; 重定向...        &#125;        return $next($request);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>定义路由时通过一个 <code>:</code> 来隔开中间件名称和参数来指定中间件参数。多个参数就使用逗号分隔</p><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">Route::put(&#39;post&#x2F;&#123;id&#125;&#39;, function ($id) &#123;    &#x2F;&#x2F;&#125;)-&gt;middleware(&#39;role:editor&#39;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><br/><h4 id="Terminable中间件"><a href="#Terminable中间件" class="headerlink" title="Terminable中间件"></a>Terminable中间件</h4><br/><p>有时可能需要在 <code>HTTP</code> 响应之后做一些工作。</p><p>如果在中间件上定义了一个 <code>terminate</code> 方法，并且使用的是 FastCGI，那么 <code>terminate</code> 方法会在响应发送到浏览器之后自动调用</p><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">&lt;?phpnamespace Illuminate\Session\Middleware;use Closure;class StartSession&#123;    public function handle($request, Closure $next)    &#123;        return $next($request);    &#125;    public function terminate($request, $response)    &#123;        &#x2F;&#x2F; 存储 session 数据    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p><code>terminate</code> 方法应该同时接收请求和响应。</p><p>定义了这个中间件之后，别忘了将它添加到路由列表或者 <code>app/Http/Kernel.php</code> 文件的全局中间件中</p><br/><p>如果在调用 handle 和 terminate 方法的同时使用相同的中间件实例，请使用容器的 singleton 方法注册中间件</p><p>通常这应该在 AppServiceProvider.php 文件中的 register 方法中完成</p><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">use App\Http\Middleware\TerminableMiddleware;&#x2F;** * 注册任意应用服务 * * @return void *&#x2F;public function register()&#123;    $this-&gt;app-&gt;singleton(TerminableMiddleware::class);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>这东西woc中应该也用不到（x</p><br/><h2 id="CSRF保护"><a href="#CSRF保护" class="headerlink" title="CSRF保护"></a>CSRF保护</h2><br/><p>Laravel 可以轻松使地保护应用程序免受 <a href="https://en.wikipedia.org/wiki/Cross-site_request_forgery">跨站请求伪造</a>（CSRF）攻击 </p><p>跨站点请求伪造是一种恶意攻击，它凭借已通过身份验证的用户身份来运行未经过授权的命令</p><br/><p>在应用程序中定义 HTML 表单时，都应该在表单中包含一个隐藏的 CSRF 标记字段</p><p>以便 CSRF 保护中间件可以验证该请求，你可以使用 <code>@csrf</code> Blade 指令来生成令牌字段</p><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">&lt;form method&#x3D;&quot;POST&quot; action&#x3D;&quot;&#x2F;profile&quot;&gt;    @csrf    ...&lt;&#x2F;form&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><br/><p>包含在 <code>web</code> 中间件组里 <code>VerifyCsrfToken</code> <a href="https://learnku.com/docs/laravel/8.x/middleware">中间件</a>会自动验证请求里的令牌是否与存储在会话中令牌匹配</p><br/><p>这些东西woc里应该不需要考虑安全性(x</p><p>先做这么多介绍吧</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php </tag>
            
            <tag> laravel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>laravel 路由</title>
      <link href="2021/02/07/laravel-%E8%B7%AF%E7%94%B1/"/>
      <url>2021/02/07/laravel-%E8%B7%AF%E7%94%B1/</url>
      
        <content type="html"><![CDATA[<h3 id="路由基本知识"><a href="#路由基本知识" class="headerlink" title="路由基本知识"></a>路由基本知识</h3><br/><p>构建基本路由只需要一个 URI 与一个 <code>闭包</code></p><br/><h4 id="重定向路由"><a href="#重定向路由" class="headerlink" title="重定向路由"></a>重定向路由</h4><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">Route::redirect(&#39;&#x2F;go&#39;, &#39;&#x2F;show&#39;, 301);&#x2F;&#x2F;301是永久性跳转，302是暂时性跳转。详细请看http协议（笑）&#x2F;&#x2F;采用的跳转方法，一旦进入go就会跳转到show&#x2F;&#x2F;Route::permanentRedirect()可以使用此方法来直接302跳转&#x2F;&#x2F;注意，由于跳转有缓存，测试是要清空cookie<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">Route::get(&#39;&#x2F;index&#39;,function()&#123;    return redirect(&#39;&#x2F;one&#39;);&#125;);&#x2F;&#x2F;也可以写成facade模式，即静态调用return redirect::to(&#39;&#x2F;one&#39;);&#x2F;&#x2F;看似简单，其实需要引入，只不过vscode自动添加了引入<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>back()方法，回到上一个界面</p><p>action()方法，跳转到控制器方法</p><p>away()方法，跳转到外部链接</p><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">return redirect()-&gt;wayName();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br/><h4 id="视图路由"><a href="#视图路由" class="headerlink" title="视图路由"></a>视图路由</h4><br/><p>调用视图的好方法</p><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">&#x2F;&#x2F;第一种Route::view(&#39;&#x2F;go&#39;, &#39;forsure&#39;,[&#39;id&#39;&#x3D;&gt;10]);&#x2F;&#x2F;添加第三个参数的方法Route::view(&#39;&#x2F;welcome&#39;, &#39;welcome&#39;, [&#39;name&#39; &#x3D;&gt; &#39;Taylor&#39;]);&#x2F;&#x2F;参数的添加使用&#x3D;&gt;,属性使用-&gt;&#x2F;&#x2F;第二种Route::get(&#39;&#x2F;gogo&#39;,function ()&#123;&#x2F;&#x2F;这种创建路由的方法称作闭包    return view(&#39;forsure&#39;);&#125;);&#x2F;&#x2F;第三种可以直接使用控制器，比较常用Route::get(&#39;&#x2F;name&#39;,[GonnaToDo::class,&#39;user&#39;]);class GonnaToDo extends Controller&#123;    public function user()&#123;        return view(&#39;forsure&#39;);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>注意：在视图路由中使用路由参数时，以下参数由 Laravel 保留，不能使用：<code>view</code>，<code>data</code>，<code>status</code> 和 <code>headers</code></p><br/><h3 id="响应请求"><a href="#响应请求" class="headerlink" title="响应请求"></a>响应请求</h3><br/><p>路由器允许你注册能响应任何 HTTP 请求的路由</p><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">Route::get($uri, $callback);Route::post($uri, $callback);Route::put($uri, $callback);Route::patch($uri, $callback);Route::delete($uri, $callback);Route::options($uri, $callback);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>有的时候你可能需要注册一个可响应多个 HTTP 请求的路由</p><p>这时你可以使用 match 方法，也可以使用 any 方法注册一个实现响应所有 HTTP 请求的路由</p><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">Route::match([&#39;get&#39;, &#39;post&#39;], &#39;&#x2F;&#39;, function () &#123;    &#x2F;&#x2F;&#125;);Route::any(&#39;&#x2F;&#39;, function () &#123;    &#x2F;&#x2F;&#125;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">&#x2F;&#x2F;创建view的时候一定带blade&#x2F;&#x2F;forsure.blade.php&lt;!DOCTYPE html&gt;&lt;html lang&#x3D;&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;    &lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, initial-scale&#x3D;1.0&quot;&gt;    &lt;meta http-equiv&#x3D;&quot;X-UA-Compatible&quot; content&#x3D;&quot;ie&#x3D;edge&quot;&gt;    &lt;title&gt;Document&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;    是laravel，awsl &#123;&#123;$id&#125;&#125;&#x2F;&#x2F;使用&#123;&#123;$id&#125;&#125;调用视图路由中添加的参数&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><h3 id="路由参数"><a href="#路由参数" class="headerlink" title="路由参数"></a>路由参数</h3><br/><h4 id="必选参数"><a href="#必选参数" class="headerlink" title="必选参数"></a>必选参数</h4><br/><p>有时候你需要在路由中捕获一些 URL 片段。例如，从 URL 中捕获用户的 ID，那就这样来定义路由参数</p><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">Route::get(&#39;user&#x2F;&#123;id&#125;&#39;, function ($id) &#123;    return &#39;User &#39;.$id;&#125;);&#x2F;&#x2F;当然也可以定义多个参数类似&#39;posts&#x2F;&#123;post&#125;&#x2F;comments&#x2F;&#123;comment&#125;&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><br/><p>路由的参数通常都会被放在 {} 内，并且参数名只能为字母，而不能包含 - 符号</p><p>如果有需要，可以用下划线 (_) 代替 - </p><p>路由参数会按路由定义的顺序依次注入到路由回调或者控制器中，而不受回调或者控制器的参数名称的影响</p><br/><h4 id="可选参数"><a href="#可选参数" class="headerlink" title="可选参数"></a>可选参数</h4><br/><p>有时，你可能需要指定一个路由参数，但你希望这个参数是可选的</p><p>你可以在参数后面加上’？’标记来实现，但前提是要确保路由的相应变量有默认值</p><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">Route::get(&#39;user&#x2F;&#123;name?&#125;&#39;, function ($name &#x3D; null) &#123;    return $name;&#125;);&#x2F;&#x2F;?是正则中的用法，重复零次或一次Route::get(&#39;user&#x2F;&#123;name?&#125;&#39;, function ($name &#x3D; &#39;John&#39;) &#123;    return $name;&#125;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><h4 id="正则表达式限制"><a href="#正则表达式限制" class="headerlink" title="正则表达式限制"></a>正则表达式限制</h4><br/><p>可以使用路由实例上的 where 方法约束路由参数的格式</p><p>where 方法接受参数名称和定义参数应如何约束的正则表达式</p><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">Route::get(&#39;user&#x2F;&#123;name&#125;&#39;, function ($name) &#123;    &#x2F;&#x2F;&#125;)-&gt;where(&#39;name&#39;, &#39;[A-Za-z]+&#39;);Route::get(&#39;user&#x2F;&#123;id&#125;&#39;, function ($id) &#123;    &#x2F;&#x2F;&#125;)-&gt;where(&#39;id&#39;, &#39;[0-9]+&#39;);Route::get(&#39;user&#x2F;&#123;id&#125;&#x2F;&#123;name&#125;&#39;, function ($id, $name) &#123;    &#x2F;&#x2F;&#125;)-&gt;where([&#39;id&#39; &#x3D;&gt; &#39;[0-9]+&#39;, &#39;name&#39; &#x3D;&gt; &#39;[a-z]+&#39;]);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>为了方便，框架中设置了一些快捷的方法，来应对常用的正则匹配</p><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">Route::get(&#39;user&#x2F;&#123;id&#125;&#x2F;&#123;name&#125;&#39;, function ($id, $name) &#123;    &#x2F;&#x2F;&#125;)-&gt;whereNumber(&#39;id&#39;)-&gt;whereAlpha(&#39;name&#39;);Route::get(&#39;user&#x2F;&#123;name&#125;&#39;, function ($name) &#123;    &#x2F;&#x2F;&#125;)-&gt;whereAlphaNumeric(&#39;name&#39;);&#x2F;&#x2F;包括数字和字母Route::get(&#39;user&#x2F;&#123;id&#125;&#39;, function ($id) &#123;    &#x2F;&#x2F;&#125;)-&gt;whereUuid(&#39;id&#39;);&#x2F;&#x2F;uuid是&quot;通用唯一识别码&quot;(x<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>可以设置全局正则设置</p><p>D:\phpstudy_pro\WWW\blog\app\Providers\RouteServiceProvider.php中</p><p>更改带有boot的函数</p><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">Route::pattern(&#39;id&#39;, &#39;[0-9]+&#39;);&#x2F;&#x2F;这表示更改路由的正则匹配<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br/><p>这样，所有带有id的内容都必须是数字</p><br/><p><code>也可在局部解除限制</code></p><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">Route::get(&#x2F;&#39;task&#x2F;&#123;id&#125;&#39;, &#39;user&#39;);-&gt;where (&#39;id&#39;,&#39;.+&#39;);&#x2F;&#x2F;正则中万能的.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><br/><h3 id="路由命名"><a href="#路由命名" class="headerlink" title="路由命名"></a>路由命名</h3><br/><p>路由命名可以方便地为指定路由生成 URL 或者重定向</p><p>通过在路由定义上链式调用 <code>name</code> 方法可以指定路由名称</p><pre class="line-numbers language-php" data-language="php"><code class="language-php">Route::get(&#39;user&#x2F;profile&#39;, function () &#123;    &#x2F;&#x2F;&#125;)-&gt;name(&#39;profile&#39;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><br/><p><code>路由命名必须是唯一的</code></p><br/><h3 id="生成指定路由url"><a href="#生成指定路由url" class="headerlink" title="生成指定路由url"></a>生成指定路由url</h3><br/><p>一旦为路由指定了名称，就可以使用全局辅助函数 <code>route</code> 来生成链接或者重定向到该路由</p><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">&#x2F;&#x2F; 生成链接...$url &#x3D; route(&#39;profile&#39;);&#x2F;&#x2F; 生成重定向...return redirect()-&gt;route(&#39;profile&#39;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>如果有定义参数的命名路由，可以把参数作为 <code>route</code> 函数的第二个参数传入，指定的参数将会自动插入到 URL 中对应的位置</p><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">Route::get(&#39;user&#x2F;&#123;id&#125;&#x2F;profile&#39;, function ($id) &#123;    &#x2F;&#x2F;&#125;)-&gt;name(&#39;profile&#39;);$url &#x3D; route(&#39;profile&#39;, [&#39;id&#39; &#x3D;&gt; 1]);&#x2F;&#x2F;本人总是在这个步骤显示路由未定义，十分令人无语(x<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>如果在数组中传递额外的参数，这些键或值将自动添加到生成的 URL 的查询字符串中</p><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">Route::get(&#39;user&#x2F;&#123;id&#125;&#x2F;profile&#39;, function ($id) &#123;    &#x2F;&#x2F;&#125;)-&gt;name(&#39;profile&#39;);$url &#x3D; route(&#39;profile&#39;, [&#39;id&#39; &#x3D;&gt; 1, &#39;photos&#39; &#x3D;&gt; &#39;yes&#39;]);&#x2F;&#x2F; &#x2F;user&#x2F;1&#x2F;profile?photos&#x3D;yes<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>控制器打印路由地址</p><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">Route::get(&#39;&#x2F;getready&#39;,[GonnaToDo::class,&#39;application&#39;])    -&gt;name(&#39;abc&#39;);class GonnaToDo extends Controller&#123;    public function application()&#123;        $name &#x3D; route(&#39;abc&#39;);        return $name;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>通过助手函数route()实现</p><p>我们可以发现route包含三种参数:</p><p>1.路由名字</p><p>2.所带变量</p><p>3.是否显示前面的localhost</p><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">$name &#x3D; route(&#39;abc&#39;,[&#39;id&#39;&#x3D;&gt;10],false);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br/><p>redirect用于重定向，默认返回状态是302，当然，你可以改成301[^2]；</p><p>我们使用 <strong>{}</strong> 来包含一个url里的变量，注意的是，变量传入function只与顺序有关，而和名称无关</p><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">Route::get()-&gt;where([&#123;&#125; &#x3D;&gt; &#39;Regular Expression&#39;]);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br/><p>使用where语句来进行正则表达式匹配。</p><br/><pre class="line-numbers language-PHP" data-language="PHP"><code class="language-PHP">Route::get()-&gt;name();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br/><p>使用name方法能够很方便的定义一个url的名称，在全局都可以使用route()方法进行重用。如果这个route中有变量，使用 <strong>[‘’ =&gt; ‘’]</strong> 来传递。</p><br/><h3 id="路由组"><a href="#路由组" class="headerlink" title="路由组"></a>路由组</h3><br/><p>如果大量路由拥有共同的属性，可以放在一个组中</p><p>使用空的路由</p><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">Route::get([],function()&#123;    Route::get(&#39;show&#39;, [testController::class,&#39;show&#39;]);    Route::get(&#39;showw&#39;, [testController::class,&#39;showw&#39;]);&#125;);&#x2F;&#x2F;空的路由没有任何意义，还是可以直接调用，只不过这样看更美观<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>当然，你可以添加前缀</p><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">Route::prefix(&#39;api&#39;)-&gt;group(function()&#123;    Route::get(&#39;show&#39;,[testController::class,&#39;show&#39;]);    Route::get(&#39;showw&#39;,[testController::class,&#39;showw&#39;]);&#125;);&#x2F;&#x2F;这样访问时，就必须使用api&#x2F;show<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><h4 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h4><br/><p>要给路由组中所有的路由分配中间件，可以在 group 之前调用 <code>middleware</code> 方法</p><p>中间件会依照它们在数组中列出的顺序来运行</p><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">Route::middleware([&#39;first&#39;, &#39;second&#39;])-&gt;group(function () &#123;    Route::get(&#39;&#x2F;&#39;, function () &#123;        &#x2F;&#x2F; 使用 first 和 second 中间件    &#125;);    Route::get(&#39;user&#x2F;profile&#39;, function () &#123;        &#x2F;&#x2F; 使用 first 和 second 中间件    &#125;);&#125;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><h4 id="子域名"><a href="#子域名" class="headerlink" title="子域名"></a>子域名</h4><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">Route::domain(&#39;127.1.1.1&#39;)-&gt;group(function()&#123;    Route::get(&#39;awsl&#x2F;&#123;id&#125;&#39;,[ElementController::class, &#39;loser&#39;])    -&gt;name(&#39;cxy&#39;)    -&gt;where(&#39;id&#39;,&#39;[0-9]+&#39;);&#125;);&#x2F;&#x2F;这样访问页面时，就不能使用www.cwcxy.com这个域名了<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>$\textcolor{red}{不要想着搞多么复杂的玩意，有可能会报查询不到的错误（x}$</p><br/><h4 id="路由前缀和名称前缀"><a href="#路由前缀和名称前缀" class="headerlink" title="路由前缀和名称前缀"></a>路由前缀和名称前缀</h4><br/><p><code>prefix</code> 方法将会为路由组中的每一个 URI 添加前缀</p><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">Route::prefix(&#39;admin&#39;)-&gt;group(function () &#123;    Route::get(&#39;users&#39;, function () &#123;        &#x2F;&#x2F; Matches The &quot;&#x2F;admin&#x2F;users&quot; URL    &#125;);&#125;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p><code>name</code> 方法可以<strong>为路由组中每一个路由名称添加一个指定的字符串作为前缀</strong></p><p>例如，可以给已经分组的路径添加 admin 的前缀</p><p>给定的字符串与指定的路由名称前缀完全相同，因此我们将<strong>确保在前缀中提供尾部的 . 字符</strong></p><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">Route::name(&#39;admin.&#39;)-&gt;group(function () &#123;    Route::get(&#39;users&#39;, function () &#123;        &#x2F;&#x2F; Route assigned name &quot;admin.users&quot;...    &#125;)-&gt;name(&#39;users&#39;);&#125;);&#x2F;&#x2F;此路由的名称就为admin.users<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><h3 id="路由与模型（model）绑定"><a href="#路由与模型（model）绑定" class="headerlink" title="路由与模型（model）绑定"></a>路由与模型（model）绑定</h3><br/><p>当向路由或控制器方法注入模型 ID 时，可能总是会检索该 ID 与模型是否一致。</p><p>Laravel 路由模型绑定提供了一个方便的方案，它可以自动注入模型实例到路由中。</p><p>例如，可以注入与给定 ID 匹配的整个 User 模型实例，而不是注入用户的 ID</p><br/><h4 id="隐式绑定"><a href="#隐式绑定" class="headerlink" title="隐式绑定"></a>隐式绑定</h4><br/><p>Laravel 会自动处理在路由或控制器方法中，与类型提示的变量名相匹配的路由段名称的 Eloquent 模型</p><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">Route::get(&#39;api&#x2F;users&#x2F;&#123;user&#125;&#39;, function (App\Models\User $user) &#123;    return $user-&gt;email;&#125;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><br/><p>其中便是使用了，model中的user-model</p><p>在这个例子中，由于 $user 变量被类型提示为 Eloquent 模型 App\Models\User，变量名称又与 URI 中的 {user} 匹配</p><p><strong>因此，Laravel 会自动注入与请求 URI 中传入的 ID 匹配的用户模型实例</strong></p><p>如果在数据库中未找到对应的模型实例，将会自动生成 404 异常</p><br/><p>在使用控制器方法时也可以使用隐式绑定</p><p><code>&#123;user&#125;</code> URI 段与控制器中的 <code>$user</code> 变量匹配，该变量包含一个 <code>App\Models\User</code> 类型提示</p><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">use App\Http\Controllers\UserController;use App\Models\User;Route::get(&#39;users&#x2F;&#123;user&#125;&#39;, [UserController::class, &#39;show&#39;]);public function show(User $user)&#123;    return view(&#39;user.profile&#39;, [&#39;user&#39; &#x3D;&gt; $user]);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><h4 id="自定义"><a href="#自定义" class="headerlink" title="自定义"></a>自定义</h4><br/><p>有时，可能希望使用 <code>id</code> 以外的列来解析 Eloquent 模型</p><p>为此，可以在路由参数定义中指定列</p><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">Route::get(&#39;api&#x2F;posts&#x2F;&#123;post:slug&#125;&#39;, function (App\Models\Post $post) &#123;    return $post;&#125;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><br/><p>有时，当一个路由定义中隐式绑定多个 Eloquent 模型时，可能需要限定第二个 Eloquent 模型的作用域，使它是第一个 Eloquent 模型的子模型</p><p>例如，考虑这样一种情况，通过 slug 字段为特定用户检索博客文章</p><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">use App\Models\Post;use App\Models\User;&#x2F;&#x2F;可以先写引用，这样使用变量时，就不需要写那么多的内容Route::get(&#39;api&#x2F;users&#x2F;&#123;user&#125;&#x2F;posts&#x2F;&#123;post:slug&#125;&#39;, function (User $user, Post $post) &#123;    return $post;&#125;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>也可以自定义键名，这样默认搜索的user的内容便不是id，而是设定的内容</p><p>可以重写 Eloquent 模型上的 <code>getRouteKeyName</code> 方法</p><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">&#x2F;** * 获取该模型的路由的自定义键名 * * @return string *&#x2F;public function getRouteKeyName()&#123;    return &#39;slug&#39;;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>（模型中的内容在woc里应该用不到，这里先一笔带过）</p><br/><h4 id="显式绑定"><a href="#显式绑定" class="headerlink" title="显式绑定"></a>显式绑定</h4><p>使用路由器的 <code>model</code> 方法为给定的参数指明参数对应的类</p><p>在 <code>RouteServiceProvider</code> 类的 <code>boot</code> 方法的开头定义显式模型绑定</p><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">&#x2F;** * 定义你的路由模型绑定, pattern 过滤器等 * * @return void *&#x2F;public function boot()&#123;    Route::model(&#39;user&#39;, \App\Models\User::class);    &#x2F;&#x2F; ...&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>接下来，定义一个包含 <code>&#123;user&#125;</code> 参数的路由</p><p>由于我们已将所有 {user} 参数绑定至 App\Models\User 模型，所以 User 实例将被注入该路由</p><p>举个例子，profile/1 的请求会注入数据库中 ID 为 1 的 User 实例</p><br/><h3 id="路由回退"><a href="#路由回退" class="headerlink" title="路由回退"></a>路由回退</h3><br/><p>当跳转一个不存在的路由时，会提示404错误</p><p>使用跳转可以是不存在页面指向特定页面</p><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">Route::fallback(function()&#123;    return redirect(&#39;&#x2F;&#39;);&#x2F;&#x2F;跳转到主页&#125;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><br/><p>（回退路由，应放在所有路由最后，不妨碍其他路由执行）</p><br/><h3 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h3><br/><h4 id="定义限流器"><a href="#定义限流器" class="headerlink" title="定义限流器"></a>定义限流器</h4><br/><p>Laravel 包含功能强大且可自定义的限流服务，可以利用这些服务来限制给定的路由或一组路由的流量</p><p>首先，您应该定义满足应用需求的限流器配置。通常，这可以写在应用程序的 RouteServiceProvider 中。</p><p>限流器可以使用 RateLimiter 门面的 for 方法定义 </p><p><strong>for 方法接受一个速率限制器名称和一个闭包会返回限制配置，该配置可以应用于分配了该限流器的路由</strong></p><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">use Illuminate\Cache\RateLimiting\Limit;use Illuminate\Support\Facades\RateLimiter;RateLimiter::for(&#39;global&#39;, function (Request $request) &#123;    return Limit::perMinute(1000);&#125;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>如果传入的请求速率超过了设置的请求频率，Laravel 会自动的响应 HTTP 429 的状态码</p><br/><p>如果想自定义响应内容，使用 <code>response</code> 方法</p><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">RateLimiter::for(&#39;global&#39;, function (Request $request) &#123;    return Limit::perMinute(1000)-&gt;response(function () &#123;        return response(&#39;Custom response...&#39;, 429);    &#125;);&#125;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><h4 id="范围频率限制"><a href="#范围频率限制" class="headerlink" title="范围频率限制"></a>范围频率限制</h4><br/><p>Laravel 提供了使用 $request 实例调取参数，如 user () 来进行身份验证从而自定义请求频率的大小或是否限制</p><p>（这波啊这波是百度网盘行为）</p><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">RateLimiter::for(&#39;uploads&#39;, function (Request $request) &#123;    return $request-&gt;user()-&gt;vipCustomer()                ? Limit::none()                : Limit::perMinute(100);&#125;);&#x2F;&#x2F;根据范围限制频率，比如在申请某个IP时RateLimiter::for(&#39;uploads&#39;, function (Request $request) &#123;    return $request-&gt;user()-&gt;vipCustomer()                ? Limit::none()                : Limit::perMinute(100)-&gt;by($request-&gt;ip());&#125;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><h4 id="多个频率限制"><a href="#多个频率限制" class="headerlink" title="多个频率限制"></a>多个频率限制</h4><br/><p>可以使用数组的形式制定多个限制，路由会根据数组的先后顺序依次去执行</p><pre class="line-numbers language-php" data-language="php"><code class="language-php">RateLimiter::for(&#39;login&#39;, function (Request $request) &#123;    return [        Limit::perMinute(500),        Limit::perMinute(3)-&gt;by($request-&gt;input(&#39;email&#39;)),    ];&#125;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><h4 id="直接给路由配置限速"><a href="#直接给路由配置限速" class="headerlink" title="直接给路由配置限速"></a>直接给路由配置限速</h4><br/><p>将配置好的频率限制器直接配置到路由上，使用 <code>throttle</code> 关键字加上频率限制器的名字放到中间件 <a href="https://learnku.com/docs/laravel/8.x/middleware">middleware</a> 数组中即可</p><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">Route::middleware([&#39;throttle:uploads&#39;])-&gt;group(function () &#123;    Route::post(&#39;&#x2F;audio&#39;, function () &#123;        &#x2F;&#x2F;    &#125;);    Route::post(&#39;&#x2F;video&#39;, function () &#123;        &#x2F;&#x2F;    &#125;);&#125;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><h3 id="表单方法伪造"><a href="#表单方法伪造" class="headerlink" title="表单方法伪造"></a>表单方法伪造</h3><br/><p>HTML 表单不支持 PUT， PATCH 或 DELETE 请求</p><p>所以当 HTML 表单调用请求方式为 PUT， PATCH 或 DELET 的路由时，需要在表单中添加一个 method 的隐藏域</p><p>method 的值将会作为 HTTP 请求的方法</p><br/><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>form</span> <span class="token attr-name">action</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>/foo/bar<span class="token punctuation">"</span></span> <span class="token attr-name">method</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>POST<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>hidden<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>_method<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>PUT<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>hidden<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>_token<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>&#123;&#123; csrf_token() &#125;&#125;<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>form</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><br/><p>也可以使用 <code>@method</code> Blade 指定生成 <code>_method</code> 隐藏域</p><br/><pre class="line-numbers language-html" data-language="html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>form</span> <span class="token attr-name">action</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>/foo/bar<span class="token punctuation">"</span></span> <span class="token attr-name">method</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>POST<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    @method('PUT')    @csrf<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>form</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><br/><h3 id="获取路由信息"><a href="#获取路由信息" class="headerlink" title="获取路由信息"></a>获取路由信息</h3><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">Route::get(&#39;index&#39;,function()&#123;    dump(Route::current());&#x2F;&#x2F;current()返回的路由的大批信息，return并不支持，所以使用dump可以使得数据以数组的形式输出    return Route::currentRouteName();    &#x2F;&#x2F;Route::currentRouteAction()获取当前路由的指向，但是laravel8删除了@的用法，所以无法显示&#125;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">$route &#x3D; Route::current();$name &#x3D; Route::currentRouteName();$action &#x3D; Route::currentRouteAction();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php </tag>
            
            <tag> laravel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>双开学习JAVA p3</title>
      <link href="2021/01/25/%E5%8F%8C%E5%BC%80%E5%AD%A6%E4%B9%A0JAVA-p3/"/>
      <url>2021/01/25/%E5%8F%8C%E5%BC%80%E5%AD%A6%E4%B9%A0JAVA-p3/</url>
      
        <content type="html"><![CDATA[<h3 id="javaAPI"><a href="#javaAPI" class="headerlink" title="javaAPI"></a>javaAPI</h3><br/><p>Java提供了丰富lang包</p><p>参考网站</p><p>官网：<a href="https://www.matools.com/api/java8">https://www.matools.com/api/java8</a></p><p>菜鸟教程string简洁版：<a href="https://www.runoob.com/java/java-string.html">https://www.runoob.com/java/java-string.html</a></p><br/><p>设计者对类实行封装性，不能让类中的方法直接访问其他类中的实例域</p><p>很多程序员采用UML（统一建模语言）绘制类图</p><br/><h3 id="对象与对象变量"><a href="#对象与对象变量" class="headerlink" title="对象与对象变量"></a>对象与对象变量</h3><br/><p>想使用对象，就先构造对象，并指定其初始状态</p><p>Java中，使用构造器（constructor）来构造新实例</p><p>构造器的名字应该与类名相同所以Date类的构造器名为Date</p><p>想要构造一个Date对象，需要加上new</p><br/><p>在构造函数中，可以直接使用this进行快速构建</p><p>就像c++中的初始化列表一样</p><br/><pre class="line-numbers language-java" data-language="java"><code class="language-java">new Date()&#x2F;&#x2F;构造了一个对象，初始化为当前时间System.out.println(new Date());&#x2F;&#x2F;可将这个对象传递给一个方法String s &#x3D; new Date().toString();&#x2F;&#x2F;可以使用toString方法将日期返回字符串的表述Date birthday &#x3D; new Date();&#x2F;&#x2F;将对象保存在一个变量之中&#x2F;&#x2F;Attention!Date deadline;&#x2F;&#x2F;只是一个对象变量，不是一个对象，不能应用Date方法&#x2F;&#x2F;必须先初始化，以下有两种方法deadline &#x3D; new Date();&#x2F;&#x2F;引用已存在的对象deadline &#x3D; birthday;&#x2F;&#x2F;引用同一个对象&#x2F;&#x2F;其实还有一种，直接设置为null值deadline &#x3D; null;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><h4 id="LocalDate类"><a href="#LocalDate类" class="headerlink" title="LocalDate类"></a>LocalDate类</h4><br/><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.time.LocalDate;public class localdate &#123;    public static void main(String[] args) &#123;        LocalDate a &#x3D; LocalDate.now();&#x2F;&#x2F;构造对象，通常将对象保存在对象变量中        int year &#x3D; a.getYear();        int month &#x3D; a.getMonthValue();        int day &#x3D;a.getDayOfMonth();        System.out.println(year+&quot;:&quot;+month+&quot;:&quot;+day);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>Date类中其实还有</p><p>getDay、getMonth、getYear等方法，但不推荐使用</p><br/><h4 id="更改器方法与访问器方法"><a href="#更改器方法与访问器方法" class="headerlink" title="更改器方法与访问器方法"></a>更改器方法与访问器方法</h4><br/><pre class="line-numbers language-java" data-language="java"><code class="language-java">LocalDate aThousandDayLater &#x3D; newYearEve.plusDays(1000);&#x2F;&#x2F;会创建一个新的LocalDate对象<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br/><p>Java早期有一个GregorianCalendar.add方法，调用之后对象变量的状态会改变，称之为更改器方法</p><p>相对于此，只访问而不修改对象的方法就是访问器方法</p><p>LocalDate.getYear、GregorianCalender.get</p><br/><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.time.LocalDate;import java.time.*;&#x2F;&#x2F;遍历月份的日历完成public class LocalCalender &#123;    public static void main(String[] args) &#123;        LocalDate date &#x3D; LocalDate.now();        int month &#x3D; date.getMonthValue();        int today &#x3D; date.getDayOfMonth();        date &#x3D; date.minusDays(today - 1);&#x2F;&#x2F;设置一个月的开始，today-1设置了这个月的开始时间（因为是以数字计算的）        DayOfWeek weekday &#x3D; date.getDayOfWeek();&#x2F;&#x2F;创建一个DayOfWeek对象,1 &#x3D; Monday,..., Sunday &#x3D; 7，可以表示这天是星期几        int value &#x3D; weekday.getValue();&#x2F;&#x2F;将具体的值传给value        System.out.println(&quot;Mon Tue Wed Thu Fri Sat Sun&quot;);        for (int i &#x3D; 1; i &lt; value; i++)&#123;            System.out.print(&quot;    &quot;);        &#125;        while (date.getMonthValue() &#x3D;&#x3D; month)&#123;            System.out.printf(&quot;%3d&quot;, date.getDayOfMonth());            if (date.getDayOfMonth() &#x3D;&#x3D; today)&#123;                System.out.print(&quot;*&quot;);&#x2F;&#x2F;如果是今天会加*            &#125;else&#123;                System.out.print(&quot; &quot;);            &#125;            date &#x3D; date.plusDays(1);            if (date.getDayOfWeek().getValue() &#x3D;&#x3D; 1)&#123;                System.out.println();            &#125;        &#125;        if (date.getDayOfWeek().getValue() !&#x3D;1) &#123;            System.out.println();        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><table><thead><tr><th>now ()/of (int year, int month, int day)</th><th>得到当前时间的对象/得到给定日期的对象</th></tr></thead><tbody><tr><td>getDayOfWeek</td><td>得到当前日期是星期几，作为DayOfWeek的实例返回。根据国际惯例，星期一为1</td></tr><tr><td>plusDays(int n)/minusDay(int n)</td><td>生成当前日期之后或之前n天的日期</td></tr></tbody></table><br/><p>即，getDayOfWeek()得到的是一周的枚举域</p><br/><h3 id="用户自定义类"><a href="#用户自定义类" class="headerlink" title="用户自定义类"></a>用户自定义类</h3><br/><h4 id="在一个类里的自定义"><a href="#在一个类里的自定义" class="headerlink" title="在一个类里的自定义"></a>在一个类里的自定义</h4><br/><pre class="line-numbers language-java" data-language="java"><code class="language-java">package Normal;import java.time.LocalDate;public class EmployeeTest &#123;    public static void main(String[] args) &#123;        Employee[] staff &#x3D; new Employee[3];&#x2F;&#x2F;定义三名Employee对象的数组        staff[0]&#x3D;new Employee(&quot;Jhon&quot;,7500,1999,5,1);&#x2F;&#x2F;构造器通常通过new进行构造        staff[1]&#x3D;new Employee(&quot;Jho&quot;,8505,1999,6,2);&#x2F;&#x2F;C++不需要进行new操作，但是Java构造器总是伴随着        staff[2]&#x3D;new Employee(&quot;Jh&quot;,9550,1999,7,3);        for (Employee e:staff)&#123;&#x2F;&#x2F;用foreach循环，对每个staff进行操作            e.raiseSalary(7);        &#125;        for (Employee e:staff)&#123;            System.out.println(e.getName()+&quot; &quot;+e.getSalary()+&quot; &quot;+e.getHireDay());        &#125;    &#125;&#125;class Employee&#123;    &#x2F;&#x2F;private修饰的变量不能直接使用，只能确保自身类的使、    private String name;    private double salary;    private LocalDate hireDay;    public Employee(String n, double s, int year, int month, int day)&#123;&#x2F;&#x2F;相当于构造器        name &#x3D; n;&#x2F;&#x2F;不能在构造器中定义与实例域重名的局部变量        salary &#x3D; s;        hireDay &#x3D; LocalDate.of(year,month,day);    &#125;&#x2F;&#x2F;通过get一家将传入的参数输出    public String getName() &#123;        return name;    &#125;    public double getSalary() &#123;        return salary;    &#125;    public LocalDate getHireDay() &#123;        return hireDay;    &#125;    public void raiseSalary(double byPercent)&#123;        double raise &#x3D; salary * byPercent &#x2F; 100;        salary +&#x3D; raise;    &#125;&#x2F;&#x2F;定义一个工资上调的方法&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><h4 id="隐式参数与显式参数"><a href="#隐式参数与显式参数" class="headerlink" title="隐式参数与显式参数"></a>隐式参数与显式参数</h4><br/><pre class="line-numbers language-java" data-language="java"><code class="language-java">public void raiseSalary(double byPercent)&#123;double raise &#x3D; this.salary * byPercent &#x2F; 100;this.salary +&#x3D; raise;&#125;&#x2F;&#x2F;this被称之为隐式参数，是出现在方法前的Employee类对象<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;当然，可以新的调用number007.raiseSalary(5);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><br/><h4 id="封装的优点"><a href="#封装的优点" class="headerlink" title="封装的优点"></a>封装的优点</h4><br/><p>如果将private改成public，数值将有很大可能发生变动错误</p><p>但是private并不是，可以改变内部实现，除了该类方法之外，不会影响其他代码</p><p>Date对象是可变的，所以会改变变量的状态</p><p>如果想要返回一个可变对象的引用，应该首先对其进行clone，后面会讲</p><br/><h4 id="final实例域"><a href="#final实例域" class="headerlink" title="final实例域"></a>final实例域</h4><br/><p>被final声明后，这个对象构建后，不会被修改</p><br/><pre class="line-numbers language-java" data-language="java"><code class="language-java">private final StringBuilder evaluations;evaluations &#x3D; new Stringbuilder();&#x2F;&#x2F;初始化&#x2F;&#x2F;final关键字只是表示储存在evaluations变量中的对象引用不会再指示其他StringBuilder对象public void giveGoldStar()&#123;    evaluation.append(LocalDate.now + &quot;:Gold star!\n&quot;);    &#x2F;&#x2F;对象依然可以更改&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><h3 id="静态域与静态方法"><a href="#静态域与静态方法" class="headerlink" title="静态域与静态方法"></a>静态域与静态方法</h3><br/><p>在绝大多数面向对象程序设计语言中，静态域被称为类域</p><p>术语“static”只是沿用了c++的叫法，没有实际意义</p><p>静态域属于类，而不属于任何独立的对象</p><br/><h4 id="静态常量"><a href="#静态常量" class="headerlink" title="静态常量"></a>静态常量</h4><br/><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;Java带的Math库中，定义了一个静态常量public class Math&#123;...    public static final double PI &#x3D; 3.14159265358979323846;    ...&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>程序中就可以采用Math.PI来调用</p><p>如果static被去除，就需要实例化Math。通过Math对象进行访问</p><p>（虽然说最好不要设置为public，但是public static final却没有问题</p><p>因为final不允许其他打印流赋给它）</p><br/><pre class="line-numbers language-java" data-language="java"><code class="language-java">System.out &#x3D; new PrintStream(...);&#x2F;&#x2F;Error out is final<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br/><h4 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h4><br/><p>静态方法就是不能向对象实施操作的方法</p><p>例如Math里的pow方法</p><p>Math.pow(x,a);</p><p>$\textcolor{red}{静态方法也可看做没有this参数的方法}$</p><br/><pre class="line-numbers language-java" data-language="java"><code class="language-java">package Normal;public class StaticTest &#123;    public static void main(String[] args) &#123;        int n &#x3D; Employer.getNextId();&#x2F;&#x2F;这样其实有没有static就无所谓了        System.out.println(n);    &#125;&#125;class Employer &#123;    static int nextId &#x3D; 5;    public static int getNextId()&#123;&#x2F;&#x2F;虽然静态方法没法被单独对象访问，但是可以通过自身所属的类        return nextId;    &#125;&#125;&#x2F;&#x2F;建议用类名调用静态方法，不然容易出错<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><h4 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h4><br/><p>在已经了解LocalDate的类使用静态的工厂方法来构造对象（不使用构造器）</p><p>下面介绍NumberFormat类</p><br/><pre class="line-numbers language-java" data-language="java"><code class="language-java">package Normal;import java.text.NumberFormat;public class NumberPercent &#123;    public static void main(String[] args) &#123;        NumberFormat currencyFormatter &#x3D; NumberFormat.getCurrencyInstance();        NumberFormat percentFormatter &#x3D; NumberFormat.getPercentInstance();        double x &#x3D; 0.1;        System.out.println(currencyFormatter.format(x));        System.out.println(percentFormatter.format(x));    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>为什么不使用构造器，原因有2：</p><p>1.无法命名构造器。构造器的名字必须和类相同，但是这个需要输出两个不同的名字</p><p>2.使用构造器时，没法改变对象类型</p><br/><h3 id="方法参数"><a href="#方法参数" class="headerlink" title="方法参数"></a>方法参数</h3><br/><p>一个方法不可能修改一个基本数据类型的参数（形参不能改变实参的值）</p><p>但是对象引用就可以实现数值改变的方法</p><br/><pre class="line-numbers language-java" data-language="java"><code class="language-java">public static void tripleValue(double x)&#123;x &#x3D; 3 * x;&#x2F;&#x2F;x初始化为percent的一个拷贝，并不是percent&#125;double percent &#x3D; 10;tripleValue(percent);&#x2F;&#x2F;这不会改变percent的数值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">public void raiseSalary(double byPercent)&#123;double raise &#x3D; this.salary * byPercent &#x2F; 100;this.salary +&#x3D; raise;&#125;public static void tripleValue(Employee x)&#123;x.raiseSalary(200);&#x2F;&#x2F;虽然x不再使用，但是harry还是继续使用的&#125;harry &#x3D; new Employee(...);tripleValue(harry);&#x2F;&#x2F;这是可以的，x和harry都引用Employee对象<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>总结Java参数的使用情况</p><p>1.一个方法不能改变一个基本数据类型的参数</p><p>2.一个方法可以改变一个对象参数的状态</p><p>3.一个方法不能让对象参数引用一个新的对象</p><br/><h3 id="对象构造"><a href="#对象构造" class="headerlink" title="对象构造"></a>对象构造</h3><br/><h4 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h4><br/><p>Java中有些类可能有多个构造器，Java允许他们的存在</p><p>这种特征叫做重载</p><p>构造器、方法都可以进行重载，但是里面的参数名不能相同</p><br/><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;String有4个成为indexOf的公有方法indexOf(int)indexOf(int , int);indexOf(String);indexOf(String , int);&#x2F;&#x2F;不能有名字相同，参数类型相同返回值类型也不同的方法<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><h4 id="无参构造器、初始化、显示域初始化、参数名"><a href="#无参构造器、初始化、显示域初始化、参数名" class="headerlink" title="无参构造器、初始化、显示域初始化、参数名"></a>无参构造器、初始化、显示域初始化、参数名</h4><br/><p>变量没有被赋值会自动赋值为（0、false、null）</p><p>$\textcolor{red}{但是这不是个好习惯，要记得乖乖初始化哦}$</p><br/><p>如果在编写一个类时没有构造器，系统会提供一个无参构造器，所有的值全部默认</p><p>如果提供了有参构造器但是没有无参构造器，不提供参数是错误的</p><br/><pre class="line-numbers language-java" data-language="java"><code class="language-java">public ClassName&#123;&#x2F;&#x2F;最简单的无参构造器&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><br/><p>初始化的值不一定要是常量，可以调用方法对域进行初始化</p><br/><pre class="line-numbers language-java" data-language="java"><code class="language-java">class Employee&#123;    private static int nextId;&#x2F;&#x2F;定义一个静态常量，使得这个值只属于类    private int id &#x3D; assignId();    ...    private static int assignId()&#123;        int r &#x3D; nextId;        nextId++;        return r;&#x2F;&#x2F;实现每个员工的Id都能逐渐加1    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>（c++中，要调用特殊的语法来调用构造器）</p><br/><p>通常构造器的参数名为单个字母，也有程序员在每个参数前加“a”</p><p>或者使用this隐式参数</p><br/><h4 id="调用另一个构造器、块的初始化"><a href="#调用另一个构造器、块的初始化" class="headerlink" title="调用另一个构造器、块的初始化"></a>调用另一个构造器、块的初始化</h4><br/><p>this除了引用方法的隐式参数，还可以调用同一个类的另一个构造器</p><br/><pre class="line-numbers language-java" data-language="java"><code class="language-java">public Employee(String, double)&#123;    this(&quot;Emlpoyee #&quot; + nextId, s);    nextId++;&#125;&#x2F;&#x2F;当调用Employee(6000)的时候，就可以调用Employee(String, double)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>如果讲一段语句放在一个块中，只要构造类的对象，都会被执行</p><br/><pre class="line-numbers language-java" data-language="java"><code class="language-java">package Normal;public class NewClassTest &#123;    public static void main(String[] args) &#123;        Animal[] a &#x3D; new Animal[2];        a[0] &#x3D; new Animal(&quot;fwh&quot;, 18);        a[1] &#x3D; new Animal(&quot;cxy&quot;, 18);        for (Animal b : a) &#123;            System.out.println(b.getName() + &quot; &quot; + b.getAge()+&quot; &quot;+b.getId());        &#125;    &#125;&#125;class Animal&#123;    private static int nextId &#x3D; 1;    private String name;    private int age,id;    &#123;        id &#x3D; nextId;        nextId++;    &#125;&#x2F;&#x2F;该语句块只要构造类的对象就会执行一次    public Animal(String name, int age)&#123;        this.age &#x3D; age;&#x2F;&#x2F;this.age表示类中定义的age        this.name &#x3D; name;    &#125;    public String getName() &#123;        return name;    &#125;    public int getAge() &#123;        return age;    &#125;    public int getId() &#123;        return id;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>调用构造器的处理步骤</p><p>1.所有的数据域被初始化为默认值</p><p>2.按照在类声明中出现的次序，依次执行所有域初始化语句和初始化块</p><p>3.如果第一个构造器调用了第二个构造器，则执行第二个构造器的主体</p><p>4.执行这个构造器的主体</p><br/><p>甚至可以静态一个块</p><br/><pre class="line-numbers language-java" data-language="java"><code class="language-java">static&#123;    Random generator &#x3D; new Random();    nextId &#x3D; generator.nextInt(1000);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><br/><h3 id="包"><a href="#包" class="headerlink" title="包"></a>包</h3><br/><p>包的导入有两种方法</p><p>一种是写完整所含包名</p><br/><pre class="line-numbers language-java" data-language="java"><code class="language-java">java.time.LocalDate today &#x3D; java.time.LocalDate.now();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br/><p>由于这样过于繁琐，我们一般都使用import</p><br/><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.util.*;&#x2F;&#x2F;这条语句可以导入Java在这个包中的所有类LocalDate today &#x3D; LocalDate.now();&#x2F;&#x2F;无需在前面加前缀<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><br/><p>（c++中，和包类似的机制是namespace（命名空间）</p><p>在Java中package与import语句类似于c++的namespace和useing指令）</p><br/><h4 id="静态引入"><a href="#静态引入" class="headerlink" title="静态引入"></a>静态引入</h4><br/><p>程序可以通过静态引入来简化代码</p><br/><pre class="line-numbers language-java" data-language="java"><code class="language-java">package Normal;import java.util.Scanner;import static java.lang.System.*;import static java.lang.Math.*;&#x2F;&#x2F;通过静态引用可以实现简写public class ImportTest &#123;    public static void main(String[] args) &#123;        Scanner in &#x3D; new Scanner(System.in);        int a &#x3D; in.nextInt();        double b &#x3D; sqrt(a);&#x2F;&#x2F;原为Math.sqrt        out.println(&quot;Hello World&quot;);&#x2F;&#x2F;原为System.out.println        out.println(a+&quot; &quot;+b);        exit(0);&#x2F;&#x2F;原为System.exit    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>但是这样写其实是有争议的，毕竟影响了代码的清晰度</p><p>不过，确实简化了很多</p><br/><h4 id="将类装入包、包的作用域"><a href="#将类装入包、包的作用域" class="headerlink" title="将类装入包、包的作用域"></a>将类装入包、包的作用域</h4><br/><p>在将类装入包之后，想要运行，需要使用package指令</p><p>如果不适用private，就会破坏封装性，任何包都可以调用</p><br/><h3 id="类路径"><a href="#类路径" class="headerlink" title="类路径"></a>类路径</h3><br/><p>javac编译器总是在当前的目录中查找文件</p><p>在unix中是禁止使用*以防止shell命令进一步扩展</p><p>也就是所谓的scr之下</p><p>使用idea的我不会有那么多的麻烦事，这里只是作为了解</p><p><br/>用 -classpath（或-cp）选项指定类路径</p><br/><pre class="line-numbers language-java" data-language="java"><code class="language-java">java -classpath &#x2F;home&#x2F;user&#x2F;classdir:.:&#x2F;home&#x2F;user&#x2F;archives.jar MyProgjava -classpath c:\classdir;.;c:\archives\archive.jar MyProg<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><br/><h3 id="文档注释"><a href="#文档注释" class="headerlink" title="文档注释"></a>文档注释</h3><br/><pre class="line-numbers language-java" data-language="java"><code class="language-java">通过&#x2F;** *&#x2F;来插入注释<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br/><h4 id="方法注释"><a href="#方法注释" class="headerlink" title="方法注释"></a>方法注释</h4><br/><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;** * @param byPercent 工资上升的数值百分比 * @return &lt;html&gt; *     &lt;head&gt; *         &lt;title&gt; *             B20032025 *         &lt;&#x2F;title&gt; *     &lt;&#x2F;head&gt; *     &lt;body&gt; *         &lt;input type&#x3D;&quot;text&quot;&gt; *     &lt;&#x2F;body&gt; * &lt;&#x2F;html&gt; * @see &lt;a href&#x3D;&quot;https:&#x2F;&#x2F;www.runoob.com&#x2F;&quot;&gt;helper&lt;&#x2F;a&gt; *&#x2F;    public void raiseSalary(double byPercent)&#123;double raise &#x3D; this.salary * byPercent &#x2F; 100;this.salary +&#x3D; raise;&#125;&#x2F;&#x2F;简单举例<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><table><thead><tr><th>@param</th><th>对当前方法变量的描述，所有方法的@param方法必须放在一起</th></tr></thead><tbody><tr><td>@return</td><td>对当前方法添加返回值部分，可以添加HTML标记，可以跨越多行</td></tr><tr><td>@throw</td><td>表示这个方法可能抛出的异常</td></tr></tbody></table><br/><h4 id="通用注释"><a href="#通用注释" class="headerlink" title="通用注释"></a>通用注释</h4><br/><table><thead><tr><th>@author</th><th>产生一个“作者”条目，可以使用多个@author标记同一个作者</th></tr></thead><tbody><tr><td>@version</td><td>产生一个“版本”条目，后面可以是对当前版本的任何描述</td></tr><tr><td>@since</td><td>产生一个“始于”条目，后面可以是对引入特征版本的描述</td></tr><tr><td>@deprecated</td><td>对类、方法或变量添加一个不再使用的注释</td></tr><tr><td>@see</td><td>在“see also“部分添加一个超级链接</td></tr></tbody></table><br/><p>下面介绍@seed的两种情况</p><p>1.@see Employee#raiseSalary(double)</p><p>建立一个链接到Employee类的raiseSalary(double)方法的超链接</p><p><strong><u>这里用#来连接，而非.</u></strong></p><p>2.</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@see &lt;a href&#x3D;&quot;https:&#x2F;&#x2F;www.runoob.com&#x2F;&quot;&gt; helper &lt;&#x2F;a&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br/><h3 id="类设计技巧总结"><a href="#类设计技巧总结" class="headerlink" title="类设计技巧总结"></a>类设计技巧总结</h3><br/><p>1.保证使用private，即私有化</p><p>2.一定不要对数据（局部变量）初始化</p><p>3.不要使用过多的基本类型</p><p>4.不是所有的与都需要独立的域访问器和域更改器</p><p>5.将职责过多的类进行分解</p><p>6.类名见名知意</p><p>7.优先使用不可变的类</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>双开学习JAVA p2</title>
      <link href="2021/01/24/%E5%8F%8C%E5%BC%80%E5%AD%A6%E4%B9%A0JAVA-p2/"/>
      <url>2021/01/24/%E5%8F%8C%E5%BC%80%E5%AD%A6%E4%B9%A0JAVA-p2/</url>
      
        <content type="html"><![CDATA[<h3 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h3><br/><p>对于输入，首先构造一个Scanner对象，并与“标准输入流”System.in</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">Scanner in&#x3D;new Scanner(System.in);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>想要读取整数就用nextInt方法，同理浮点型就是nextDouble</p><br/><h4 id="next-与-nextLine-区别"><a href="#next-与-nextLine-区别" class="headerlink" title="next() 与 nextLine() 区别"></a>next() 与 nextLine() 区别</h4><br/><p>next():</p><ul><li>1、一定要读取到有效字符后才可以结束输入</li><li>2、对输入有效字符之前遇到的空白，next() 方法会自动将其去掉</li><li>3、只有输入有效字符后才将其后面输入的空白作为分隔符或者结束符</li><li>4、next() 不能得到带有空格的字符串</li></ul><p>nextLine()：</p><ul><li>1、以Enter为结束符,也就是说 nextLine()方法返回的是输入回车之前的所有字符</li><li>2、可以获得空白</li></ul><br/><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.util.Scanner;public class Hello &#123;    public static void main(String[] args) &#123;        Scanner in&#x3D;new Scanner(System.in);        int a&#x3D;in.nextInt();&#x2F;&#x2F;以空格作为结束        String b&#x3D;in.nextLine();&#x2F;&#x2F;以回车作为结束        System.out.println(&quot;您是&quot;+b+&quot;您今年&quot;+a+&quot;岁&quot;);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><table><thead><tr><th align="center">关键词</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">hasNext()</td><td align="center">检测输入中是否还有其他单词</td></tr><tr><td align="center">hasNextInt()/hasNextDouble</td><td align="center">检测是否还有表示整数或浮点数的下一个字符序列</td></tr><tr><td align="center">Console console()</td><td align="center">如果有可能进行交互操作，就通过控制台窗口为交互的用户返回一个Console对象，否则返回null</td></tr></tbody></table><br/><h4 id="古老（格式化）输出"><a href="#古老（格式化）输出" class="headerlink" title="古老（格式化）输出"></a>古老（格式化）输出</h4><br/><p>Java中保留了printf的输出方式</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">System.out.printf()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.util.Scanner;public class Hello &#123;    public static void main(String[] args) &#123;        Scanner in&#x3D;new Scanner(System.in);        int a&#x3D;in.nextInt();        String b&#x3D;in.nextLine();        System.out.printf(&quot;您是%s,您今年%d岁&quot;,b,a);&#x2F;&#x2F;格式跟c&#x2F;c++一致    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>可以使用静态的String.format方法创建一个格式化的字符串而不输出</p><br/><pre class="line-numbers language-java" data-language="java"><code class="language-java">String message&#x3D;String.format(&quot;您是%s,您今年%d岁&quot;,b,a);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br/><p>printf也可以打印Date()函数</p><br/><pre class="line-numbers language-java" data-language="java"><code class="language-java">System.out.printf(&quot;%tc&quot;,new Date());<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br/><p>这里便不展开了</p><br/><h4 id="文件输入与输出"><a href="#文件输入与输出" class="headerlink" title="文件输入与输出"></a>文件输入与输出</h4><br/><p>读取文件需要用File对象构造一个Scanner对象</p><br/><pre class="line-numbers language-java" data-language="java"><code class="language-java">Scanner in&#x3D;new Scanner(Paths.get(&quot;myfile.txt&quot;),&quot;UTF-8&quot;);&#x2F;&#x2F;左边表示文件的地址，可直接用Paths.get方法获取地址<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>要想写入文件，就需要构造一个PrintWriter对象</p><p><strong>$\textcolor{red}{在构造器中，只需要提供文件名}$</strong></p><br/><pre class="line-numbers language-java" data-language="java"><code class="language-java">PrintWriter out&#x3D;new PrintWriter(&quot;myfile.txt&quot;,&quot;UTF-8&quot;);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br/><p>如果文件不存在便会创建该文件</p><p>可以通过System.out使用print,pirntln,printf命令</p><br/><p>可以构造一个带有字符串参数的Scanner，但是**$\textcolor{red}{引号里面的值将是数据而非文件}$**</p><br/><pre class="line-numbers language-java" data-language="java"><code class="language-java">Scanner in &#x3D; new Scanner(&quot;myfile.txt&quot;);&#x2F;&#x2F;里面仅仅是个字符串数据<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br/><p>如果文件调用不存在，会发生严重的错误</p><p>这些错误系统默认它们比”被零除“还要严重</p><p>之后会提及对异常的处理</p><br/><h3 id="控制程序"><a href="#控制程序" class="headerlink" title="控制程序"></a>控制程序</h3><br/><p>Java没有goto语句，但是break可以带标签</p><br/><h4 id="块作用域"><a href="#块作用域" class="headerlink" title="块作用域"></a>块作用域</h4><br/><p>块即为大括号括起来的若干条简单语句</p><p>一个块可以嵌套在另一个块中</p><br/><pre class="line-numbers language-java" data-language="java"><code class="language-java">public static void main(String[] args)&#123;int n;&#123;int k;&#x2F;&#x2F;k只在这里被定义int n;&#x2F;&#x2F;Java中不能重复定义；++中允许此操作，内部的变量会替换外部的变量&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>块基本上是用于循环或者判断</p><br/><h4 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h4><br/><p>判断两个浮点数是否相等时，需要格外小心</p><p>因为0.1无法用精确地用二进制表示</p><br/><p>$\textcolor{red}{重点来介绍switch}$</p><p>至于switch语句，由于如果忘加break很容易出现严重错误，不会在程序中使用</p><p>但是可以加上-Xlint:fallthrough选项</p><br/><pre class="line-numbers language-java" data-language="java"><code class="language-java">java -Xlint:fallthrough Test.java&#x2F;&#x2F;如果出现case后面没加break，会报错<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br/><p>switch中，如果使用枚举，不必指明枚举名</p><br/><h4 id="中断控制流程的语句"><a href="#中断控制流程的语句" class="headerlink" title="中断控制流程的语句"></a>中断控制流程的语句</h4><br/><p>break的标签用法</p><br/><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.util.Scanner;public class Hello &#123;    public static void main(String[] args) &#123;        Scanner in &#x3D; new Scanner(System.in);        int n&#x3D;0,i;        read_data:        for (i&#x3D;0;i&lt;10;i++)&#123;            while (n!&#x3D;999)&#123;                i++;                if(i&#x3D;&#x3D;10)&#123;                    break read_data;&#x2F;&#x2F;注意这里执行后跳到程序结束                &#125;            &#125;        &#125;        System.out.println(i);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>同样的continue也可以完成标签操作</p><p>执行后跳转到程序的开头</p><br/><h4 id="大数值"><a href="#大数值" class="headerlink" title="大数值"></a>大数值</h4><br/><p>当整形的范围和浮点精度不能满足需求的时候，就会用到两十分重要的类</p><table><thead><tr><th>BigInteger</th><th>实现了任意精度的整数运算</th></tr></thead><tbody><tr><td>BigDecimal</td><td>实现了任意精度的浮点数运算</td></tr></tbody></table><br/><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.math.BigInteger;public class Bigdata &#123;    public static void main(String[] args) &#123;        BigInteger a&#x3D;BigInteger.valueOf(100);&#x2F;&#x2F;通过使用静态方法valueOf将数值转化为大数值        BigInteger b&#x3D;BigInteger.valueOf(5);        BigInteger c&#x3D;a.add(b);        BigInteger d&#x3D;a.multiply(b);        BigInteger e&#x3D;a.subtract(b);        BigInteger f&#x3D;a.divide(b);        &#x2F;&#x2F;转化为大数值之后，不能使用平时的算数运算符        &#x2F;&#x2F;以上演示了加减乘除的运用        System.out.println(c);        System.out.println(d);        System.out.println(e);        System.out.println(f);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><table><thead><tr><th>mod()</th><th>返回这个整数和另一个大整数的和、差、积、商以及余数</th></tr></thead><tbody><tr><td>compareTo()</td><td>返回这个大整数与另一个大整数相等，返回0；如果小于，返回负数；否则，返回正数</td></tr></tbody></table><br/><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><br/><pre class="line-numbers language-java" data-language="java"><code class="language-java">int []a;&#x2F;&#x2F;声明了整形数组int a[];&#x2F;&#x2F;声明数组时，这两种都可以a&#x3D;new int[100];&#x2F;&#x2F;为数组分配空间int arr[] &#x3D; new int[]&#123;1, 2, 3, 5, 25&#125;;int arr2[] &#x3D; &#123;34, 23 ,12, 6&#125;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>当创建字符串数组的，初始化时，每个元素的内容都是null</p><p>Java的数组相比于c语言，提供了长度可变的选择，即数组的长度可以是一个变量</p><br/><pre class="line-numbers language-java" data-language="java"><code class="language-java">Scanner in &#x3D; new Scanner(System.in);int n &#x3D; in.nextInt();int[] a &#x3D; new int[n];<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><br/><p>从数组的定义可以看出，Java的数组系统会分配内存给它们的</p><p>这些内存分配不需要像c++一样在最后用delete函数取消掉</p><p>所以，Java的数组提供了很大的自由空间</p><br/><h4 id="for-each循环"><a href="#for-each循环" class="headerlink" title="for each循环"></a>for each循环</h4><br/><pre class="line-numbers language-java" data-language="java"><code class="language-java">for(variable:collection)statement&#x2F;&#x2F;通用语法<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Foreach &#123;    public static void main(String[] args) &#123;        int []a &#x3D; new int[100];        for (int element:a)&#123;            System.out.println(element);        &#125;        for (int i&#x3D;0;i&lt;100;i++)&#123;            System.out.println(a);        &#125;        &#x2F;&#x2F;上面两者的作用都是一样的，都是遍历a中的元素，但是foreach更为简介方便且不需要填入下标    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>当然有一个更简单的方法，通过Arrays类</p><br/><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.util.Arrays;public class Foreach &#123;    public static void main(String[] args) &#123;        int []a &#x3D; new int[10];        System.out.println(Arrays.toString(a));&#x2F;&#x2F;输出的数会用括号括着，用逗号隔开    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><h4 id="初始化和匿名数组"><a href="#初始化和匿名数组" class="headerlink" title="初始化和匿名数组"></a>初始化和匿名数组</h4><br/><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class None &#123;    public static void main(String[] args) &#123;        int[] a&#x3D;&#123;1,2,3,4,5&#125;;&#x2F;&#x2F;创建对象并同时赋予初始值        a &#x3D; new int[] &#123;6,7,8,9&#125;;&#x2F;&#x2F;可以使用 new elementType[]创建一个匿名数组，使得可以不创建新变量进行初始化        int[] b;        b &#x3D; new int[0];&#x2F;&#x2F;Java允许长度为0的数组存在，通过匿名数组创建    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><h4 id="数组拷贝"><a href="#数组拷贝" class="headerlink" title="数组拷贝"></a>数组拷贝</h4><br/><p>copyOf(arr, int newlength)，是对应数组获得该长度的数值（可以用来做其他操作）</p><p>如果想要固定拷贝范围，可以使用copyOfRange(arr, int fromInde, int toIndex)</p><br/><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.util.Arrays;public class Copy &#123;    public static void main(String[] args) &#123;        int[] a &#x3D; &#123;1,2,3,4,5,6&#125;;        int[] b &#x3D; Arrays.copyOf(a,a.length);&#x2F;&#x2F;后一项为数组长度        a&#x3D;Arrays.copyOf(a,2*a.length);&#x2F;&#x2F;常常使用这个Arrays类的方法来讲数组扩大        System.out.println(Arrays.toString(a));        System.out.println(Arrays.toString(b));    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>（Java中对数组的定义，更像c++中直接定义数组指针</p><p>而非int a[100];</p><p>但是Java没有指针操作，无法通过a++来实现跳转到下一个元素）</p><br/><h4 id="命令行数组"><a href="#命令行数组" class="headerlink" title="命令行数组"></a>命令行数组</h4><br/><p>主函数的方法都是带一个String[] args的参数</p><p>说明可以接受字符串数组</p><p>如果以“java Message -g Hello World“的形式运行，数组中第一个值是”-g”</p><br/><h4 id="数组排序"><a href="#数组排序" class="headerlink" title="数组排序"></a>数组排序</h4><br/><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.util.Arrays;public class Command &#123;    public static void main(String[] args) &#123;        int[] a &#x3D; &#123;1,6,8,4,94,1536&#125;;        Arrays.sort(a);        System.out.println(Arrays.toString(a));    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><table><thead><tr><th align="center">函数名</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">type copyOfRange(type[] a,int start,int end)</td><td align="center">固定范围拷贝</td></tr><tr><td align="center">binarySearch(type[] a,type v)(binarySearch(type[] a,int start,int end,type v))</td><td align="center">采用二分法查找值v，查找成功就返回它的下标，否则便会返回一个负数（固定范围）</td></tr><tr><td align="center">fill(type[] a,type v)</td><td align="center">将数组中所有元素替换为v</td></tr><tr><td align="center">equals(type[] a,type[] b)</td><td align="center">如果两个数组完全相等返回true</td></tr></tbody></table><br/><h4 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h4><br/><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.util.Arrays;public class MoreDemension &#123;    public static void main(String[] args) &#123;        int[][] Str&#x3D;&#123;            &#123;1,2,3,4&#125;,&#123;5,6,7,8&#125;,&#123;2,4,0,0&#125;        &#125;;&#x2F;&#x2F;定义多维数组是不会对剩余的数值自动补零        for (int i&#x3D;0;i&lt;3;i++)&#123;            for (int j&#x3D;0;j&lt;4;j++)&#123;                System.out.println(Str[i][j]);            &#125;        &#125;        System.out.println(Arrays.deepToString(Str));        &#x2F;&#x2F;如果想使用foreach用法，需要两层嵌套        for(int[] element:Str)&#123;&#x2F;&#x2F;定义一个数组储存列            for (int value:element)&#123;                System.out.println(value);            &#125;        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>在定义一个行数已知，宽度未知的数组时。可以给每一行单独分配内存</p><br/><pre class="line-numbers language-java" data-language="java"><code class="language-java">int [][] a &#x3D; new int[N][];for (i &#x3D; 0; i &lt; N; i ++)&#123;a[i] &#x3D; new int[i + 1];            &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><h4 id="不规则数组"><a href="#不规则数组" class="headerlink" title="不规则数组"></a>不规则数组</h4><br/><pre class="line-numbers language-java" data-language="java"><code class="language-java">double[][] balances&#x3D;new double[10][6];&#x2F;&#x2F;java<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&#x2F;&#x2F;不同于double balances[10][6]&#x2F;&#x2F;C++double (*balance)[6]&#x3D;new double[10][6];<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>Java定义多维数组是分配一个是10个指针的数组</p><p>然后在每个指针中填满6个数字</p><p>Java在创建中不需要像c++一样，系统会自动执行循环</p><br/><h4 id="数组中的函数"><a href="#数组中的函数" class="headerlink" title="数组中的函数"></a>数组中的函数</h4><br/><pre class="line-numbers language-java" data-language="java"><code class="language-java">fill(int[] a, int value);&#x2F;&#x2F;将该int值，分配给数组中的所有元素fill(int[] a, int fromIndex, int toIndex, int value);&#x2F;&#x2F;在输入范围的元素填充对应值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>双开学习JAVA p1</title>
      <link href="2021/01/23/%E5%8F%8C%E5%BC%80%E5%AD%A6%E4%B9%A0JAVA-p1/"/>
      <url>2021/01/23/%E5%8F%8C%E5%BC%80%E5%AD%A6%E4%B9%A0JAVA-p1/</url>
      
        <content type="html"><![CDATA[<h3 id="补充完善的点"><a href="#补充完善的点" class="headerlink" title="补充完善的点"></a>补充完善的点</h3><br/><p>Java并不使用asc码，而是Unicode的编码形式</p><p>可以存储65536个字符，几乎包含了所有国家的文字</p><br/><table><thead><tr><th align="center">转义字符</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">\ddd</td><td align="center">1~3位八进制数据</td></tr><tr><td align="center">\uxxx</td><td align="center">4位十六进制数据</td></tr></tbody></table><br/><p>和单纯的c相比多了布尔类型</p><br/><p>合法的变量可以使用大小写、下划线、美元符号</p><p>（如果想要深度学习，建议去<a href="https://www.runoob.com/java/java-tutorial.html">菜鸟教程</a>，或者买本核心技术看看）</p><br/><h3 id="写Java时不得不了解的概念"><a href="#写Java时不得不了解的概念" class="headerlink" title="写Java时不得不了解的概念"></a>写Java时不得不了解的概念</h3><br/><h4 id="浮点类型"><a href="#浮点类型" class="headerlink" title="浮点类型"></a>浮点类型</h4><br/><p>float类型有一个后缀F或f（如3.14F）</p><p>没有后缀的浮点类型默认为double类型</p><p><strong>（可以用十六进制表示浮点类型数值，例如0.125可以表示成2^(-3)，也就是0x1p-3</strong></p><p><strong>这里注意，Java中指数表达使用的是p而非e，指数的基数是2而非10）</strong></p><br/><p>三个溢出或出错情况的浮点型</p><p><strong>无穷大，无穷小，和NAN（不是个数字）</strong></p><br/><h4 id="char和Unicode类型"><a href="#char和Unicode类型" class="headerlink" title="char和Unicode类型"></a>char和Unicode类型</h4><br/><p>Unicode其实就是画了个饼，打算将全世界各种语言分别进行编码，但是导致char不足以表达Unicode</p><p>所以引入前缀了U+来表示不同的语言</p><p><strong>建议不要在程序中使用char，除非需要处理UTF-16代码单元，最好使用字符串</strong></p><br/><h4 id="1-final"><a href="#1-final" class="headerlink" title="1.final"></a>1.final</h4><br/><p>在声明常量时，通常在前面加<code>final</code>关键词</p><p>而且，虽然不是必须的，常量往往都是大写字母</p><br/><pre class="line-numbers language-java" data-language="java"><code class="language-java">final double PI &#x3D; 3.1415926;final boolean BOOL &#x3D; true;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><br/><p>（当final定义的值时成员变量时，必须赋初值，不然会出错</p><p>并且，常量的值无法更改）</p><br/><h4 id="2-成员变量-amp-局部变量"><a href="#2-成员变量-amp-局部变量" class="headerlink" title="2.成员变量&amp;局部变量"></a>2.成员变量&amp;局部变量</h4><br/><pre class="line-numbers language-java" data-language="java"><code class="language-java">class var&#123;int x &#x3D; 45;static y &#x3D; 90;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>x为实例变量，y是静态变量（<code>类变量</code>）</p><p>类变量的范围可以跨越类，甚至能到达整个程序</p><p>可以以<code>&quot;类名.静态变量&quot;</code>的方式在其他类内使用</p><br/><p>成员变量可以和局部变量名称相同</p><p>但是如果在一个类中使用，局部变量为先</p><br/><h4 id="3-位运算符（对二进制）"><a href="#3-位运算符（对二进制）" class="headerlink" title="3.位运算符（对二进制）"></a>3.位运算符（对二进制）</h4><br/><p>首先明确一点，正负数的二进制有“本质”地不同点</p><p>位运算符的最常用的地方就是用来对密码进行一系列的加密，在多种原则的情况下，一般人很难判断出来</p><br/><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">700000111-811111000左边最高位是符号位，最高位是0表示整数，若为1表示负数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><h5 id="a-”按位与”-amp-”按位或”"><a href="#a-”按位与”-amp-”按位或”" class="headerlink" title="a.”按位与”&amp;”按位或”"></a>a.”按位与”&amp;”按位或”</h5><br/><p>“按位与”的运算符为<code>“&amp;”</code></p><p>如果两整形对应位都是1，结果才是1，否则都是0</p><p>（“按位或”就是<code>“|”</code>，自行理解）</p><br/><h5 id="b-”按位取反”"><a href="#b-”按位取反”" class="headerlink" title="b.”按位取反”"></a>b.”按位取反”</h5><br/><p>“按位取反”的运算符为<code>“~”</code></p><p>将操作数二进制中的1修改为0，0修改为1</p><br/><h5 id="c-”按位异或”"><a href="#c-”按位异或”" class="headerlink" title="c.”按位异或”"></a>c.”按位异或”</h5><br/><p>“按位异或”的运算符为<code>&quot;^&quot;</code></p><p>当两个操作数的二进制表示相同，结果为0，否则为1</p><br/><h5 id="移位操作"><a href="#移位操作" class="headerlink" title="移位操作"></a>移位操作</h5><br/><p><code>&lt;&lt;</code>：左移</p><p><code>&gt;&gt;</code>：右移</p><p><code>&gt;&gt;&gt;</code>：无符号右移</p><br/><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><br/><h4 id="子串"><a href="#子串" class="headerlink" title="子串"></a>子串</h4><br/><p>String可以通过substring来提取一个字符串的子串</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Hello &#123;    public static void main(String[] args) &#123;        String a&#x3D;&quot;Hello World&quot;;        String b&#x3D;a.substring(0,3);        System.out.println(b);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>string.substring(a,b);</p><p><strong>调用子串的长度为b-a</strong></p><br/><h4 id="拼接"><a href="#拼接" class="headerlink" title="拼接"></a>拼接</h4><br/><p>和大多数程序设计语言一样，Java允许使用+号连接两个字符串</p><p>当然，在输出语句System.out.println()中，也适用</p><br/><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Hello &#123;    public static void main(String[] args) &#123;        String a&#x3D;&quot;cxy &quot;;&#x2F;&#x2F;如果这里是个整形，也是没有问题的        String b&#x3D;&quot;super boy&quot;;        String c&#x3D;a+b;        System.out.println(c);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><h4 id="Java字符串的特点"><a href="#Java字符串的特点" class="headerlink" title="Java字符串的特点"></a>Java字符串的特点</h4><br/><p>Java的字符串是不能进行更改的</p><p>只能够通过创建子串再进行拼接，创建新的字符串达到相对修改</p><p><strong>虽然效率低，但是使得字符串可以共享</strong></p><p>（Java的字符串并不是数组，更像c/c++中的指针）</p><br/><h4 id="区分是否相等"><a href="#区分是否相等" class="headerlink" title="区分是否相等"></a>区分是否相等</h4><br/><p>使用equals()函数</p><p>如果想忽略大小写的差异使用equalsIgnoreCase()方法</p><br/><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Hello &#123;    public static void main(String[] args) &#123;        String a&#x3D;&quot;Super Boy&quot;;        String b&#x3D;&quot;super boy&quot;;        if(a.equals(b))&#123;            System.out.println(&quot;完全相等&quot;);        &#125;if (a.equalsIgnoreCase(b))&#123;            System.out.println(&quot;相等，但有大小写之分&quot;);        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><h4 id="空串和Null串"><a href="#空串和Null串" class="headerlink" title="空串和Null串"></a>空串和Null串</h4><br/><p>空串是长度为0的字符串；null则是一个特殊的值，表示没有任何对象与其关联</p><br/><pre class="line-numbers language-java" data-language="java"><code class="language-java">if(str!&#x3D;null&amp;&amp;str.length()!&#x3D;0)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br/><h4 id="String类函数"><a href="#String类函数" class="headerlink" title="String类函数"></a>String类函数</h4><br/><pre class="line-numbers language-java" data-language="java"><code class="language-java">String str;str.trim();&#x2F;&#x2F;返回字符串的副本，忽略前导空格和尾部空格str.replace(&quot;a&quot;, &quot;b&quot;);&#x2F;&#x2F;将str中的a替换成bstr.startsWith();&#x2F;&#x2F;判断字符串的前缀是否为参数指定的字符串str.endWith();&#x2F;&#x2F;判断字符串是否以给定的子字符串结束str.split(a, 1)&#x2F;&#x2F;将字符串a拆分1次<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><h4 id="码点和代码单元"><a href="#码点和代码单元" class="headerlink" title="码点和代码单元"></a>码点和代码单元</h4><br/><p>char类型是UTF-16表示的Unicode码点的代码单元</p><p>lenth方法返回的只是给定字符串所需的代码单元数量</p><p>想要得到实际的长度，需要用codePointCount(0,str.length())</p><table><thead><tr><th>charAt()</th><th>返回n位置的代码单元</th><th>n介于0~str.length之间</th></tr></thead><tbody><tr><td>codePointAt()</td><td>得到第n个码点</td><td>str.offsetByCodePoints(0,n)将码点跳转到n处</td></tr></tbody></table><p>其他具体的，这里就不再说了，感觉自己不怎么会用到</p><br/><h4 id="构建字符串"><a href="#构建字符串" class="headerlink" title="构建字符串"></a>构建字符串</h4><br/><p>不断连接字符串的效率和成本都比较高，因此通常构建一个空的字符串构造器</p><br/><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Hello &#123;    public static void main(String[] args) &#123;        StringBuilder builder&#x3D;new StringBuilder();&#x2F;&#x2F;创建空的字符串构造器        String ch&#x3D;&quot;hello&quot;;        char str1&#x3D;&#39; &#39;;        char str2&#x3D;&#39;c&#39;;        builder.append(ch);&#x2F;&#x2F;追加一个字符串并返回this        builder.append(str1);&#x2F;&#x2F;追加一个代码单元并返回this        builder.append(str2);        String a&#x3D;builder.toString();&#x2F;&#x2F;返回一个与构建器内容相同的字符串        System.out.println(a);    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>剩下几个比较重要的方法如下</p><table><thead><tr><th align="center">函数</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">StringBuilder appendCodePoint(int cp)</td><td align="center">追加一个代码点，并将其转换为一个或两个代码单元并返回this</td></tr><tr><td align="center">setCharAt(int i,char c)</td><td align="center">将第i个代码单元设置为c</td></tr><tr><td align="center">StringBuilder insert(int offset,String str)</td><td align="center">在offset位置插入一个字符串并返回this</td></tr><tr><td align="center">StringBuilder insert(int offset,Char c)</td><td align="center">在offset位置插入一个代码单元并返回this</td></tr><tr><td align="center">StringBuilder delete(int startIndex,int endIndex)</td><td align="center">删除从startIndex到endIndex的代码单元并返回this</td></tr></tbody></table><br/><h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><br/><p>static方法一般称作静态方法，由于静态方法不依赖于任何对象就可以进行访问，因此对于静态方法来说，是没有this的，因为它不依附于任何对象，既然都没有对象，就谈不上this了。并且由于这个特性，在静态方法中不能访问类的非静态成员变量和非静态成员方法，因为非静态成员方法/变量都是必须依赖具体的对象才能够被调用</p><br/><p>与C/C++中的static不同，Java中的static关键字不会影响到变量或者方法的作用域。在Java中能够影响到访问权限的只有private、public、protected（包括包访问权限）这几个关键字</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>php p3</title>
      <link href="2021/01/15/php-p3/"/>
      <url>2021/01/15/php-p3/</url>
      
        <content type="html"><![CDATA[<h2 id="Mysql操作"><a href="#Mysql操作" class="headerlink" title="Mysql操作"></a>Mysql操作</h2><br/><h3 id="连接mysql"><a href="#连接mysql" class="headerlink" title="连接mysql"></a>连接mysql</h3><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">&lt;?php$servername &#x3D; &quot;localhost&quot;;&#x2F;&#x2F;服务器名字$username &#x3D; &quot;username&quot;;$password &#x3D; &quot;password&quot;; try &#123;    $conn &#x3D; new PDO(&quot;mysql:host&#x3D;$servername;&quot;, $username, $password);    echo &quot;连接成功&quot;; &#125;catch(PDOException $e)&#123;    echo $e-&gt;getMessage();&#125;?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><h3 id="持久化连接"><a href="#持久化连接" class="headerlink" title="持久化连接"></a>持久化连接</h3><br/><p>很多 web 应用程序通过使用到数据库服务的持久连接获得好处。</p><p>持久连接在脚本结束后不会被关闭，且被缓存，当另一个使用相同凭证的脚本连接请求时被重用。</p><p>持久连接缓存可以避免每次脚本需要与数据库回话时建立一个新连接的开销，从而让 web 应用程序更快。</p><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">&lt;?php$dbh &#x3D; new PDO(&#39;mysql:host&#x3D;localhost;dbname&#x3D;test&#39;, $user, $pass, array(    PDO::ATTR_PERSISTENT &#x3D;&gt; true));?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><h3 id="关闭连接"><a href="#关闭连接" class="headerlink" title="关闭连接"></a><strong>关闭连接</strong></h3><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">$conn &#x3D; null;&#x2F;&#x2F;pdo<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br/><h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">&lt;?php$servername &#x3D; &quot;localhost&quot;;$username &#x3D; &quot;username&quot;;$password &#x3D; &quot;password&quot;;try &#123;    $conn &#x3D; new PDO(&quot;mysql:host&#x3D;$servername&quot;, $username, $password);    &#x2F;&#x2F; 设置 PDO 错误模式为异常    $conn-&gt;setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);    $sql &#x3D; &quot;CREATE DATABASE myDBPDO&quot;;    &#x2F;&#x2F; 使用 exec() ，因为没有结果返回    $conn-&gt;exec($sql);    echo &quot;数据库创建成功&lt;br&gt;&quot;;&#125;catch(PDOException $e)&#123;    echo $sql . &quot;&lt;br&gt;&quot; . $e-&gt;getMessage();&#125;$conn &#x3D; null;?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>使用 PDO 的最大好处是在数据库查询过程出现问题时可以使用异常类来 处理问题。如果 try{ } 代码块出现异常，脚本会停止执行并会跳到第一个 catch(){ } 代码块执行代码。 在以上捕获的代码块中我们输出了 SQL 语句并生成错误信息。</p><br/><h3 id="创建数据表"><a href="#创建数据表" class="headerlink" title="创建数据表"></a>创建数据表</h3><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">&lt;?php$servername &#x3D; &quot;localhost&quot;;$username &#x3D; &quot;username&quot;;$password &#x3D; &quot;password&quot;;$dbname &#x3D; &quot;backend&quot;; try &#123;    $conn &#x3D; new PDO(&quot;mysql:host&#x3D;$servername;dbname&#x3D;$dbname&quot;, $username, $password);    &#x2F;&#x2F; 设置 PDO 错误模式，用于抛出异常    $conn-&gt;setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);     &#x2F;&#x2F; 使用 sql 创建数据表    $sql &#x3D; &quot;CREATE TABLE &#96;test_users&#96;(        &#96;id&#96; int(11) NOT NULL AUTO_INCREMENT,      &#96;name&#96; varchar(255) DEFAULT NULL,      &#96;number&#96; varchar(255) DEFAULT NULL,      &#96;password&#96; varchar(255) DEFAULT NULL,      &#96;content&#96; text DEFAULT NULL,      PRIMARY KEY (&#96;id&#96;)) ENGINE &#x3D; InnoDB DEFAULT CHARSET &#x3D; utf8;&quot;;     &#x2F;&#x2F; 使用 exec() ，没有结果返回     $conn-&gt;exec($sql);    echo &quot;数据表 test_users 创建成功&quot;;&#125;catch(PDOException $e)&#123;    echo $sql . &quot;&lt;br&gt;&quot; . $e-&gt;getMessage();&#125;?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><h3 id="向表中插入数据"><a href="#向表中插入数据" class="headerlink" title="向表中插入数据"></a>向表中插入数据</h3><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">&lt;?php$servername &#x3D; &quot;localhost&quot;;$username &#x3D; &quot;username&quot;;$password &#x3D; &quot;password&quot;;$dbname &#x3D; &quot;backend&quot;; try &#123;    $conn &#x3D; new PDO(&quot;mysql:host&#x3D;$servername;dbname&#x3D;$dbname&quot;, $username, $password);    &#x2F;&#x2F; 设置 PDO 错误模式，用于抛出异常    $conn-&gt;setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);    $sql &#x3D; &quot;INSERT INTO test_users (name, number, password,content)    VALUES (&#39;车厘子&#39;, &#39;B19030313&#39;, &#39;123456&#39;,&#39;说点啥好呢&#39;)&quot;;    &#x2F;&#x2F; 使用 exec() ，没有结果返回     $conn-&gt;exec($sql);    echo &quot;新记录插入成功&quot;;&#125;catch(PDOException $e)&#123;    echo $sql . &quot;&lt;br&gt;&quot; . $e-&gt;getMessage();&#125; $conn &#x3D; null;?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><h3 id="插入多条数据"><a href="#插入多条数据" class="headerlink" title="插入多条数据"></a>插入多条数据</h3><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">&lt;?php$servername &#x3D; &quot;localhost&quot;;$username &#x3D; &quot;root&quot;;$password &#x3D; &quot;123456&quot;;$dbname &#x3D; &quot;backend&quot;; try &#123;    $conn &#x3D; new PDO(&quot;mysql:host&#x3D;$servername;dbname&#x3D;$dbname&quot;, $username, $password);    &#x2F;&#x2F; set the PDO error mode to exception    $conn-&gt;setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);     &#x2F;&#x2F; 开始事务    $conn-&gt;beginTransaction();    &#x2F;&#x2F; SQL 语句    $conn-&gt;exec(&quot;INSERT INTO test_users (name, number, password,content)     VALUES (&#39;John&#39;, &#39;B19030314&#39;, &#39;123456&#39;,&#39;啊这&#39;)&quot;);    $conn-&gt;exec(&quot;INSERT INTO test_users (name, number, password,content)     VALUES (&#39;Mary&#39;, &#39;B19030315&#39;, &#39;123456&#39;,&#39;啊这&#39;)&quot;);    $conn-&gt;exec(&quot;INSERT INTO  test_users(name, number, password,content)     VALUES (&#39;Julie&#39;, &#39;B19030318&#39;, &#39;123456&#39;,&#39;啊这&#39;)&quot;);     &#x2F;&#x2F; 提交事务    $conn-&gt;commit();    echo &quot;新记录插入成功&quot;;&#125;catch(PDOException $e)&#123;    &#x2F;&#x2F; 如果执行失败回滚    $conn-&gt;rollback();    echo $sql . &quot;&lt;br&gt;&quot; . $e-&gt;getMessage();&#125; $conn &#x3D; null;?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><h3 id="mysql预处理语句"><a href="#mysql预处理语句" class="headerlink" title="mysql预处理语句"></a>mysql预处理语句</h3><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">&lt;?php$servername &#x3D; &quot;localhost&quot;;$username &#x3D; &quot;root&quot;;$password &#x3D; &quot;123456&quot;;$dbname &#x3D; &quot;backend&quot;; try &#123;    $conn &#x3D; new PDO(&quot;mysql:host&#x3D;$servername;dbname&#x3D;$dbname&quot;, $username, $password);    &#x2F;&#x2F; 设置 PDO 错误模式为异常    $conn-&gt;setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);     &#x2F;&#x2F; 预处理 SQL 并绑定参数    $stmt &#x3D; $conn-&gt;prepare(&quot;INSERT INTO test_users (name, number, password,content)     VALUES (:name, :number, :password,:content)&quot;);    $stmt-&gt;bindParam(&#39;:name&#39;, $name);    $stmt-&gt;bindParam(&#39;:number&#39;, $number);    $stmt-&gt;bindParam(&#39;:password&#39;, $password);    $stmt-&gt;bindParam(&#39;:content&#39;, $content);     &#x2F;&#x2F; 插入行    $name &#x3D; &quot;jc&quot;;    $number &#x3D; &quot;B19030321&quot;;    $password &#x3D; &quot;123456&quot;;    $content&#x3D;&quot;啊这啊这&quot;;    $stmt-&gt;execute();     &#x2F;&#x2F; 插入其他行    $name &#x3D; &quot;xiaoshuai&quot;;    $number &#x3D; &quot;B19030322&quot;;    $password &#x3D; &quot;123456&quot;;    $content&#x3D;&quot;啊这啊这&quot;;    $stmt-&gt;execute();     &#x2F;&#x2F; 插入其他行    $name &#x3D; &quot;kaikai&quot;;    $number &#x3D; &quot;B19030323&quot;;    $password &#x3D; &quot;123456&quot;;    $content&#x3D;&quot;啊这啊这&quot;;    $stmt-&gt;execute();     echo &quot;新记录插入成功&quot;;&#125;catch(PDOException $e)&#123;    echo &quot;Error: &quot; . $e-&gt;getMessage();&#125;$conn &#x3D; null;?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><h3 id="读取数据"><a href="#读取数据" class="headerlink" title="读取数据"></a><strong>读取数据</strong></h3><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">&lt;?phpecho &quot;&lt;table style&#x3D;&#39;border: solid 1px black;&#39;&gt;&quot;;echo &quot;&lt;tr&gt;&lt;th&gt;id&lt;&#x2F;th&gt;&lt;th&gt;name&lt;&#x2F;th&gt;&lt;th&gt;number&lt;&#x2F;th&gt;&lt;th&gt;content&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&quot;; class TableRows extends RecursiveIteratorIterator &#123;    function __construct($it) &#123;         parent::__construct($it, self::LEAVES_ONLY);     &#125;     function current() &#123;        return &quot;&lt;td style&#x3D;&#39;width:150px;border:1px solid black;&#39;&gt;&quot; . parent::current(). &quot;&lt;&#x2F;td&gt;&quot;;    &#125;     function beginChildren() &#123;         echo &quot;&lt;tr&gt;&quot;;     &#125;      function endChildren() &#123;         echo &quot;&lt;&#x2F;tr&gt;&quot; . &quot;\n&quot;;    &#125; &#125;  $servername &#x3D; &quot;localhost&quot;;$username &#x3D; &quot;root&quot;;$password &#x3D; &quot;123456&quot;;$dbname &#x3D; &quot;backend&quot;; try &#123;    $conn &#x3D; new PDO(&quot;mysql:host&#x3D;$servername;dbname&#x3D;$dbname&quot;, $username, $password);    $conn-&gt;setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);    $stmt &#x3D; $conn-&gt;prepare(&quot;SELECT id, name, number,content FROM test_users&quot;);     $stmt-&gt;execute();     &#x2F;&#x2F; 设置结果集为关联数组    $result &#x3D; $stmt-&gt;setFetchMode(PDO::FETCH_ASSOC);     foreach(new TableRows(new RecursiveArrayIterator($stmt-&gt;fetchAll()))as $k&#x3D;&gt;$v) &#123;         echo $v;    &#125;&#125;catch(PDOException $e) &#123;    echo &quot;Error: &quot; . $e-&gt;getMessage();&#125;$conn &#x3D; null;echo &quot;&lt;&#x2F;table&gt;&quot;;?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">&lt;?php$servername &#x3D; &quot;localhost&quot;;$username &#x3D; &quot;root&quot;;$password &#x3D; &quot;123456&quot;;$dbname &#x3D; &quot;backend&quot;;try&#123;    $obj &#x3D; new PDO(&quot;mysql:host&#x3D;$servername;dbname&#x3D;$dbname&quot;,&quot;$username&quot;,&quot;$password&quot;);&#x2F;&#x2F;生成PDO示例    $obj -&gt;setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);&#x2F;&#x2F;设置以异常的形式报错    $obj -&gt;setAttribute(PDO::ATTR_DEFAULT_FETCH_MODE , PDO::FETCH_ASSOC );&#x2F;&#x2F;设置fetch时返回数据形式为数组    $ps &#x3D; $obj-&gt;prepare(&quot;SELECT *  FROM &#96;test_users&#96; WHERE &#96;name&#96; &#x3D; ?&quot;);&#x2F;&#x2F;生成一个PDOStatement实例    $ps-&gt;bindValue(1 , &quot;John&quot;);&#x2F;&#x2F;第一个？处的参数换成 文章，不需要附加任何处理    $ps-&gt;execute(); &#x2F;&#x2F;正式执行。    $res &#x3D; $ps-&gt;fetchAll();&#x2F;&#x2F;得到查询结果print_r($res);&#125; catch(Exception $e)&#123;exit($e-&gt;getMessage());&#125;?&gt;    &#x2F;&#x2F;体会query和prepare的异同    &lt;?php$servername &#x3D; &quot;localhost&quot;;$username &#x3D; &quot;root&quot;;$password &#x3D; &quot;123456&quot;;$dbname &#x3D; &quot;backend&quot;;try&#123;    $obj &#x3D; new PDO(&quot;mysql:host&#x3D;$servername;dbname&#x3D;$dbname&quot;,&quot;$username&quot;,&quot;$password&quot;);&#x2F;&#x2F;生成PDO示例    $obj -&gt;setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);&#x2F;&#x2F;设置以异常的形式报错    $obj -&gt;setAttribute(PDO::ATTR_DEFAULT_FETCH_MODE , PDO::FETCH_ASSOC );&#x2F;&#x2F;设置fetch时返回数据形式为数组    $ps &#x3D; $obj-&gt;query(&quot;SELECT *  FROM &#96;test_users&#96; WHERE &#96;name&#96; &#x3D; &#39;John&#39;&quot;);&#x2F;&#x2F;生成一个PDOStatement实例    $res &#x3D; $ps-&gt;fetchAll();&#x2F;&#x2F;得到查询结果    print_r($res);&#125; catch(Exception $e)&#123;    exit($e-&gt;getMessage());&#125;?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">&lt;?php$servername &#x3D; &quot;localhost&quot;;$username &#x3D; &quot;root&quot;;$password &#x3D; &quot;123456&quot;;$dbname &#x3D; &quot;backend&quot;;try&#123;    $obj &#x3D; new PDO(&quot;mysql:host&#x3D;$servername;dbname&#x3D;$dbname&quot;,&quot;$username&quot;,&quot;$password&quot;);&#x2F;&#x2F;生成PDO示例    $obj -&gt;setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);&#x2F;&#x2F;设置以异常的形式报错    $obj -&gt;setAttribute(PDO::ATTR_DEFAULT_FETCH_MODE , PDO::FETCH_ASSOC );&#x2F;&#x2F;设置fetch时返回数据形式为数组    $ps &#x3D; $obj-&gt;query(&quot;DELETE FROM &#96;test_users&#96; WHERE &#96;name&#96; &#x3D; &#39;John&#39;&quot;);&#x2F;&#x2F;生成一个PDOStatement实例&#125; catch(Exception $e)&#123;    exit($e-&gt;getMessage());&#125;?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">&lt;?php$servername &#x3D; &quot;localhost&quot;;$username &#x3D; &quot;root&quot;;$password &#x3D; &quot;123456&quot;;$dbname &#x3D; &quot;backend&quot;;try&#123;    $obj &#x3D; new PDO(&quot;mysql:host&#x3D;$servername;dbname&#x3D;$dbname&quot;,&quot;$username&quot;,&quot;$password&quot;);&#x2F;&#x2F;生成PDO示例    $obj -&gt;setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);&#x2F;&#x2F;设置以异常的形式报错    $obj -&gt;setAttribute(PDO::ATTR_DEFAULT_FETCH_MODE , PDO::FETCH_ASSOC );&#x2F;&#x2F;设置fetch时返回数据形式为数组    $ps &#x3D; $obj-&gt;query(&quot;UPDATE &#96;test_users&#96; SET &#96;password&#96; &#x3D; &#39;12345&#39; WHERE &#96;name&#96; &#x3D; &#39;Mary&#39;&quot;);&#x2F;&#x2F;生成一个PDOStatement实例&#125; catch(Exception $e)&#123;    exit($e-&gt;getMessage());&#125;?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><h2 id="魔术变量"><a href="#魔术变量" class="headerlink" title="魔术变量"></a>魔术变量</h2><br/><p>PHP 向它运行的任何脚本提供了大量的预定义常量。</p><p>不过很多常量都是由不同的扩展库定义的，只有在加载了这些扩展库时才会出现，或者动态加载后，或者在编译时已经包括进去了。</p><p>有八个魔术常量它们的值随着它们在代码中的位置改变而改变。</p><p>例如 <strong>LINE</strong> 的值就依赖于它在脚本中所处的行来决定。这些特殊的常量不区分大小写，如下：</p><br/><h3 id="LINE"><a href="#LINE" class="headerlink" title="__LINE__"></a><code>__LINE__</code></h3><br/><p>文件中的当前行号。</p><pre class="line-numbers language-php" data-language="php"><code class="language-php">&lt;?php     echo &#39;这是第 &quot; &#39;  . __LINE__ . &#39; &quot; 行&#39;; ?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><br/><p>这是第 “ 2 ” 行</p><br/><h3 id="FILE"><a href="#FILE" class="headerlink" title="__FILE__"></a><code>__FILE__</code></h3><br/><p>文件的完整路径和文件名。如果用在被包含文件中，则返回被包含的文件名。</p><p>自 PHP 4.0.2 起，<strong>FILE</strong> 总是包含一个绝对路径（如果是符号连接，则是解析后的绝对路径），而在此之前的版本有时会包含一个相对路径</p><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">&lt;?php     echo &#39;该文件位于 &quot; &#39;  . __FILE__ . &#39; &quot; &#39;; ?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><br/><p>该文件位于 “ E:\wamp\www\test\index.php ”</p><br/><h3 id="DIR"><a href="#DIR" class="headerlink" title="__DIR__"></a><code>__DIR__</code></h3><br/><p>文件所在的目录。如果用在被包括文件中，则返回被包括的文件所在的目录</p><p>它等价于 dirname(<strong>FILE</strong>)。除非是根目录，否则目录中名不包括末尾的斜杠（PHP 5.3.0中新增）</p><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">&lt;?php     echo &#39;该文件位于 &quot; &#39;  . __DIR__ . &#39; &quot; &#39;; ?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><br/><p>该文件位于 “ E:\wamp\www\test ”</p><br/><h3 id="FUNCTION"><a href="#FUNCTION" class="headerlink" title="__FUNCTION__"></a><code>__FUNCTION__</code></h3><br/><p>函数名称（PHP 4.3.0 新加）。自 PHP 5 起本常量返回该函数被定义时的名字（区分大小写）。在 PHP 4 中该值总是小写字母的</p><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">&lt;?php     function test() &#123;        echo  &#39;函数名为：&#39; . __FUNCTION__ ; &#125; test(); ?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>函数名为：test</p><br/><h3 id="CLASS"><a href="#CLASS" class="headerlink" title="__CLASS__"></a><code>__CLASS__</code></h3><br/><p>类的名称（PHP 4.3.0 新加）。自 PHP 5 起本常量返回该类被定义时的名字（区分大小写）</p><p>在 PHP 4 中该值总是小写字母的。类名包括其被声明的作用区域（例如 Foo\Bar）。注意自 PHP 5.4 起 <strong>CLASS</strong> 对 trait 也起作用。当用在 trait 方法中时，<strong>CLASS</strong> 是调用 trait 方法的类的名字</p><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">&lt;?php     class test &#123;       function _print() &#123;            echo &#39;类名为：&#39;  . __CLASS__ . &quot;&lt;br&gt;&quot;;            echo  &#39;函数名为：&#39; . __FUNCTION__ ;        &#125; &#125; $t &#x3D; new test(); $t-&gt;_print(); ?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>类名为：test<br>函数名为：_print</p><br/><h3 id="TRAIT"><a href="#TRAIT" class="headerlink" title="__TRAIT__"></a><code>__TRAIT__</code></h3><br/><p>Trait 的名字（PHP 5.4.0 新加）。自 PHP 5.4.0 起，PHP 实现了代码复用的一个方法，称为 traits</p><p>Trait 名包括其被声明的作用区域（例如 Foo\Bar）</p><p>从基类继承的成员被插入的 SayWorld Trait 中的 MyHelloWorld 方法所覆盖。其行为 MyHelloWorld 类中定义的方法一致。优先顺序是当前类中的方法会覆盖 trait 方法，而 trait 方法又覆盖了基类中的方法</p><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">&lt;?php     class Base &#123;        public function sayHello() &#123;                    echo &#39;Hello &#39;;            &#125; &#125;  trait SayWorld &#123;            public function sayHello() &#123;                    parent::sayHello();                    echo &#39;World!&#39;;            &#125;     &#125;  class MyHelloWorld extends Base &#123;            use SayWorld;     &#125;  $o &#x3D; new MyHelloWorld(); $o-&gt;sayHello(); ?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>Hello World!</p><br/><h3 id="METHOD"><a href="#METHOD" class="headerlink" title="__METHOD__"></a><code>__METHOD__</code></h3><br/><p>类的方法名（PHP 5.0.0 新加）。返回该方法被定义时的名字（区分大小写）。</p><pre class="line-numbers language-php" data-language="php"><code class="language-php">&lt;?php     function test() &#123;        echo  &#39;函数名为：&#39; . __METHOD__ ; &#125; test(); ?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>函数名为：test</p><br/><h3 id="NAMESPACE"><a href="#NAMESPACE" class="headerlink" title="__NAMESPACE__"></a><code>__NAMESPACE__</code></h3><br/><p>当前命名空间的名称（区分大小写）。此常量是在编译时定义的（PHP 5.3.0 新增）。</p><pre class="line-numbers language-php" data-language="php"><code class="language-php">&lt;?php     namespace MyProject;  echo &#39;命名空间为：&quot;&#39;, __NAMESPACE__, &#39;&quot;&#39;; &#x2F;&#x2F; 输出 &quot;MyProject&quot; ?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><br/><p>命名空间为：”MyProject”</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>php p2</title>
      <link href="2021/01/13/php-p2/"/>
      <url>2021/01/13/php-p2/</url>
      
        <content type="html"><![CDATA[<h3 id="php一些好玩的地方"><a href="#php一些好玩的地方" class="headerlink" title="php一些好玩的地方"></a><strong>php一些好玩的地方</strong></h3><br/><p><strong>php中的一些语法比较简单随意</strong></p><p><strong>echo语句中使用单引号或双引号都没什么特别大的影响</strong></p><p><strong>echo语句中的几个变量可以由’.’号连接</strong></p><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">&lt;?php$a&#x3D;&#39;final&#39;;$b&#x3D;&#39;the game&#39;;echo $a.&#39; nice &#39;.$b;?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p><strong>输出结果</strong></p><p><strong>final nice the game</strong></p><p><strong>也可以换一种直接嵌套的方式</strong></p><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">&lt;?php$a&#x3D;&#39;final&#39;;$b&#x3D;&#39;the game&#39;;echo $a.&#39; nice &#39;.$b.&#39;&lt;br&gt;&#39;;echo &quot;$a nice $b&quot;;?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p><strong>注意：此时echo中应当使用双引号</strong></p><p><strong>echo后面可以不加引号使用语句块表示输出结果</strong></p><p><strong>（Java与其类似，所以后端为什么不用Java来写（x）</strong></p><br/><h3 id="php面向对象的用法"><a href="#php面向对象的用法" class="headerlink" title="php面向对象的用法"></a><strong>php面向对象的用法</strong></h3><br/><p>面向对象，自然会有这样那样的共性，从c++开创先河之后，其他的语言不过是为了迎合某些程序员的喜好罢了</p><p><strong>（好像面向对象的语言都是一个吊样）(小声逼逼)</strong></p><br/><h4 id="基本的类和对象，实例化介绍"><a href="#基本的类和对象，实例化介绍" class="headerlink" title="基本的类和对象，实例化介绍"></a><strong>基本的类和对象，实例化介绍</strong></h4><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">&#x2F;&#x2F;function.php&lt;?php$a&#x3D;&#39;final&#39;;$b&#x3D;&#39;the game&#39;;echo $a.&#39; nice &#39;.$b.&#39;&lt;br&gt;&#39;;echo &quot;$a nice $b&quot;;class Hello&#123;    function sayHello()&#123;        echo &#39;Hello PHP&#39;;    &#125;&#125;?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">&lt;?phprequire &#39;function.php&#39;;$a&#x3D;new Hello();$a-&gt;sayHello();?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>调用后的结果即为</p><p>final nice the game<br>final nice the gameHello PHP</p><p>当调用多个数据库有相同命名的类和对象的解决办法</p><p><strong>php5.0加入了<u>命名空间</u>的概念，使其能够辨别不同的数据库</strong>（c++就开始了）</p><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">&#x2F;&#x2F;创建一个function.php&lt;?phpnamespace base;$a&#x3D;&#39;final&#39;;$b&#x3D;&#39;the game&#39;;echo $a.&#39; nice &#39;.$b.&#39;&lt;br&gt;&#39;;echo &quot;$a nice $b &lt;br&gt;&quot;;class Hello&#123;    function sayHello()&#123;        echo &#39;Hello cxy&#39;.&#39;&lt;br&gt;&#39;;    &#125;&#125;?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">&#x2F;&#x2F;创建一个namespace.php&lt;?phpnamespace hello;class Hello&#123;    function sayHello()&#123;        echo &#39;Hello darling&#39;;    &#125;&#125;?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">&#x2F;&#x2F;主程序调用（use.php）&lt;?phprequire &#39;function.php&#39;;require &#39;namespace.php&#39;;$a&#x3D;new \base\Hello;$a-&gt;sayHello();$b&#x3D;new \hello\Hello;$b-&gt;sayHello();?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>结果</p><p>final nice the game<br>final nice the game<br>Hello cxy<br>Hello darling</p><p>构造方法简介（<u>即实例化的时候执行的语句块</u>）</p><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">&#x2F;&#x2F;建立文件way.php&lt;?phpclass Man&#123;    public function __construct()&#123;        echo &#39;mission complete&#39;;    &#125;&#125;?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">&lt;?phprequire &#39;way.php&#39;;$a&#x3D;new Man();?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><br/><p>结果</p><p>mission complete</p><p><strong>无需调用，实例化时直接执行</strong></p><br/><h4 id="带参构造方法使用"><a href="#带参构造方法使用" class="headerlink" title="带参构造方法使用"></a><strong>带参构造方法使用</strong></h4><br/><p><strong>首先说明一点，$this代表自身的对象</strong></p><p><strong>当变量用private修饰时，就不能直接调用了</strong></p><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">&#x2F;&#x2F;创建文件way.php&lt;?phpclass Man&#123;    public function __construct($age,$name)&#123;        $this-&gt;_age&#x3D;$age;        $this-&gt;_name&#x3D;$name;    &#125;    public function getAge()&#123;        return $this-&gt;_age;    &#125;    public function getName()&#123;        return $this-&gt;_name;    &#125;    private $_age,$_name;&#125;?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>通过<code>$_age </code>, <code>$_name</code> 两个变量储存参数的值</p><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">&#x2F;&#x2F;调用文件use.php&lt;?phprequire &#39;way.php&#39;;$a&#x3D;new Man(10,&#39;cxy&#39;);echo $a-&gt;getAge();echo $a-&gt;getName();?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>输出结果</p><p>10cxy</p><br/><h4 id="成员方法和类方法"><a href="#成员方法和类方法" class="headerlink" title="成员方法和类方法"></a><strong>成员方法和类方法</strong></h4><br/><p>成员方法需要通过实例化进行访问</p><p>如同上面的public function getName()只能这么访问</p><p>类方法（静态方法,静态常量）</p><p>public static function getName()</p><p>const MAX_MAN_NUM=200</p><p>没有必要实例化进行使用只需要使用冒号来进行调用（<u>本身已经进行过一次处理了</u>）</p><p>主要是用来描述类的属性</p><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">&#x2F;&#x2F;创建文件way.php&lt;?phpclass Man&#123;    public function __construct($age,$name)&#123;        $this-&gt;_age&#x3D;$age;        $this-&gt;_name&#x3D;$name;        Man::$man++;        if(Man::$man&gt;Man::man_max)&#123;&#x2F;&#x2F;使用冒号进行调用            throw new Exception(&quot;no room for it&quot;);&#x2F;&#x2F;当超出某一条件时，跳出报错        &#125;     &#125;    public function getAge()&#123;        return $this-&gt;_age;    &#125;    public function getName()&#123;        return $this-&gt;_name;    &#125;    public static function sayHello()&#123;        echo &#39;hi!&#39;;    &#125;    private $_age,$_name;    private static $man&#x3D;0;    const man_max&#x3D;200;&#x2F;&#x2F;定义常量&#125;?&gt;&#x2F;&#x2F;到这里你可能会觉得，php的写法更像java，php在这基础上引入某些更加方便地特性<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">&#x2F;&#x2F;创建文件way.php&lt;?phprequire &#39;way.php&#39;;Man::sayHello();for($i&#x3D;0;$i&lt;200;$i++)&#123;&#x2F;&#x2F;将200换成Man::man_max也是可以的    new Man(10,&#39;cxy&#39;);&#125;?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>页面成功显示出hi</p><p>如果将代码改成以下</p><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">&lt;?phprequire &#39;way.php&#39;;Man::sayHello();for($i&#x3D;0;$i&lt;&#x3D;200;$i++)&#123;&#x2F;&#x2F;多添加了一个等号    new Man(10,&#39;cxy&#39;);&#125;?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>页面报错</p><p>Fatal error: Uncaught Exception: no room for it in D:\phpstudy_pro\WWW\<a href="http://www.wdnmd.com/way.php:8">www.wdnmd.com\way.php:8</a> Stack trace: #0 D:\phpstudy_pro\WWW\<a href="http://www.wdnmd.com/use.php(5)">www.wdnmd.com\use.php(5)</a>: Man-&gt;__construct(10, ‘cxy’) #1 {main} thrown in D:\phpstudy_pro\WWW\<a href="http://www.wdnmd.com/way.php">www.wdnmd.com\way.php</a> on line 8</p><p>此时表示，变量Man::$man已经超过Man::man_max</p><br/><h4 id="类的继承和方法重写"><a href="#类的继承和方法重写" class="headerlink" title="类的继承和方法重写"></a>类的继承和方法重写</h4><br/><p>如同孩子继承父亲，类是可以相互继承的</p><p>如果是子类调用父类，则会使用parent</p><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">&#x2F;&#x2F;创建父类animal.php&lt;?phpclass animal&#123;    public function __construct($age,$name,$sex)&#123;        $this-&gt;_age&#x3D;$age;        $this-&gt;_name&#x3D;$name;        $this-&gt;_sex&#x3D;$sex;    &#125;    public function getAge()&#123;        return $this-&gt;_age;    &#125;    public function getName()&#123;        return $this-&gt;_name;    &#125;    public function getSex()&#123;        return $this-&gt;_sex;    &#125;    public function sayHi()&#123;        echo $this-&gt;_name.&#39; say hi&#39;;    &#125;    private $_age,$_name,$_sex;&#125;?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">&#x2F;&#x2F;创建其子类dog.php&lt;?phprequire &#39;animal.php&#39;;class dog extends animal&#123;    public function __construct($age,$name,$sex)&#123;        parent::__construct($age,$name,$sex);    &#125;    public function sayHi()&#123;&#x2F;&#x2F;对父类的方法进行重写，定义相同名称的方法        parent::sayHi();&#x2F;&#x2F;如果想要保留原本的方法，即使用该语句        echo &#39;&lt;br&gt;&#39;;        echo $this-&gt;getName().&#39; say hi &#39;.$this-&gt;getAge();    &#125;&#125;?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">&#x2F;&#x2F;使用例子main.php&lt;?phprequire &#39;dog.php&#39;;$a&#x3D;new dog(10,&#39;fwh&#39;,&#39;male&#39;);$a-&gt;sayHi();?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>结果显示如下</p><p>fwh say hi<br>fwh say hi 10**</p><br/><h3 id="time-amp-date"><a href="#time-amp-date" class="headerlink" title="time()&amp;date()"></a>time()&amp;date()</h3><br/><p>time()函数表示自1970年到现在的秒数</p><p>date()便可以根据输入的内容显示相应东西（vscode有相对应的提示）</p><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">&lt;?phpecho time().&#39;&lt;br&gt;&#39;;echo date(&#39;r&#39;);?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><br/><p>输出结果</p><p>1610450808<br>Tue, 12 Jan 2021 19:26:48 +0800**</p><br/><h3 id="json格式文件"><a href="#json格式文件" class="headerlink" title="json格式文件"></a>json格式文件</h3><br/><p>首先先介绍json格式中常用的东西</p><p>格式如下</p><br/><pre class="line-numbers language-json" data-language="json"><code class="language-json">[1,2,5,7,&quot;hello&quot;,[2,4,6]]&#123;&quot;h&quot;:&quot;hello&quot;,&quot;w&quot;:&quot;world&quot;&#125;&#x2F;&#x2F;这种格式称为键值对<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><br/><p>语法</p><br/><pre class="line-numbers language-json" data-language="json"><code class="language-json">&#123;&quot;k&quot;:&quot;v&quot;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br/><p><strong>”key“:”value“（简易的对象写法）</strong></p><p>使用json_encode()来将php的数组转化为json形式</p><p>同理，使用json_decode()来讲json形式转化为php数组</p><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">&lt;?php$a&#x3D;array(&#39;0&#39;,&#39;1&#39;,&#39;2&#39;,&quot;hello&quot;,array(3,2,1));$obj&#x3D;json_encode($a);echo $obj.&#39;&lt;br&gt;&#39;;$jsonStr&#x3D;&#39;&#123;&quot;h&quot;:&quot;Hello&quot;,&quot;w&quot;:&quot;World&quot;,&quot;0&quot;:[1,2,3]&#125;&#39;;&#x2F;&#x2F;将json转化为数组$jbo&#x3D;json_decode($jsonStr);print_r($jbo);echo &#39;&lt;br&gt;&#39;.$jbo-&gt;h;&#x2F;&#x2F;调用其中某一个键值对?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>输出结果 </p><p>[“0”,”1”,”2”,”hello”,[3,2,1]]<br>stdClass Object ( [h] =&gt; Hello [w] =&gt; World [0] =&gt; Array ( [0] =&gt; 1 [1] =&gt; 2 [2] =&gt; 3 ) )<br>Hello**</p><p><strong>注意json格式中内容的里面的单引号</strong></p><br/><h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a><strong>文件操作</strong></h3><br/><p>无需像c语言一样先定义变量的类型（函数基本相同）</p><p>注意：当使用@fopen函数时，如果发生警告便不会输出</p><p>windows平台一般不会出现权限警告的问题</p><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">&lt;?php$f&#x3D;@fopen(&#39;data&#39;,&#39;w+&#39;);if($f&#x3D;&#x3D;0)&#123;    echo &#39;file error&#39;;&#125;else&#123;    fwrite($f,&#39;Hello PHP&#39;);    echo &#39;success&#39;;&#125;fclose($f);?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>可能是php协议的问题，导致文件无法被创建</p><p>除了类似于c语言的循环输出文件内容，php提供了一个内置函数</p><p>file_get_comtent(file name)</p><p>直接输出文件内容</p><br/><h3 id="图片操作"><a href="#图片操作" class="headerlink" title="图片操作"></a>图片操作</h3><br/><p><strong>php图片主要可以用来生成验证码，压缩图片，限制上传大小，处理水印等</strong></p><p><a href="https://www.runoob.com/php/php-image-gd.html">菜鸟教程</a>有关内容</p><br/><h4 id="图片处理函数（自己查手册）"><a href="#图片处理函数（自己查手册）" class="headerlink" title="图片处理函数（自己查手册）"></a>图片处理函数（自己查手册）</h4><br/><h5 id="imagecrate"><a href="#imagecrate" class="headerlink" title="imagecrate()"></a>imagecrate()</h5><p>里面传入长宽参数  </p><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">&lt;?php$a&#x3D;imagecreate(300,400);?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><br/><p><strong>但单单使用此函数会报错或者不显示</strong></p><p><strong>因为没有确定它的颜色</strong></p><br/><h5 id="imagecolorallocate"><a href="#imagecolorallocate" class="headerlink" title="imagecolorallocate()"></a>imagecolorallocate()</h5><br/><p>imagecolorallocatealpha()（调整图像颜色和透明度）</p><p>里面传入创建好的图片变量和rgb颜色参数，配合imagecreate()一起使用</p><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">&lt;?php$a&#x3D;imagecreate(300,400);imagecolorallocate($a,200,200,300);?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><br/><h5 id="imagepng"><a href="#imagepng" class="headerlink" title="imagepng()"></a>imagepng()</h5><br/><p>进行图片输出（以png格式）</p><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">&lt;?php$a&#x3D;imagecreate(300,400);imagecolorallocate($a,200,200,300);header(&#39;Content-type:image&#x2F;png&#39;);imagepng($a);?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>MIME TYPE的基本解释可以在我的其他博客中看到</p><p>可能考虑再搞个前端的typora什么的。只要不咕咕咕就行（bushi</p><br/><h5 id="imageellipse"><a href="#imageellipse" class="headerlink" title="imageellipse()"></a>imageellipse()</h5><br/><p>再原有图像上创建一个椭圆（圆）</p><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">&lt;?php$a&#x3D;imagecreate(300,400);imagecolorallocate($a,200,200,200);header(&#39;Content-type:image&#x2F;png&#39;);imageellipse($a,200,200,60,60,imagecolorallocate($a,100,100,200));imagepng($a);?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>前两个参数是指圆的中心点的位置</p><p>后两个参数是指圆的宽和高，如果相同就是圆</p><p>最后则是圆的颜色</p><br/><h5 id="imagecreatefromjpeg"><a href="#imagecreatefromjpeg" class="headerlink" title="imagecreatefromjpeg()"></a>imagecreatefromjpeg()</h5><br/><p>直接调用文件中的图片显示再页面上</p><pre class="line-numbers language-php" data-language="php"><code class="language-php">&lt;?php$image&#x3D;imagecreatefromjpeg(&#39;preview.jpg&#39;);&#x2F;&#x2F;函数中的参数为文件，这里我直接将图片复制到了本地header(&#39;Content-type:image&#x2F;jpeg&#39;);imagejpeg($image);&#x2F;&#x2F;header(&#39;Content-type:image&#x2F;png&#39;);&#x2F;&#x2F;imagepng($image);&#x2F;&#x2F;这样写函数同样也是正确的，图像的显示格式取绝你定的头?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><h4 id="图片水印处理"><a href="#图片水印处理" class="headerlink" title="图片水印处理"></a>图片水印处理</h4><br/><p>使用的函数为imagestring()</p><p>在图像指定地点添加一段字符串</p><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">&lt;?php$image&#x3D;imagecreatefromjpeg(&#39;preview.jpg&#39;);header(&#39;Content-type:image&#x2F;jpeg&#39;);imagestring($image,30,1,1,&#39;two wives of cxy&#39;,imagecolorallocate($image,0,100,100));imagejpeg($image);?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>前三个参数分别是字体大小和它们的x，y坐标</p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>php p1</title>
      <link href="2021/01/11/php-p1/"/>
      <url>2021/01/11/php-p1/</url>
      
        <content type="html"><![CDATA[<h3 id="Require和include"><a href="#Require和include" class="headerlink" title="Require和include"></a>Require和include</h3><br/><p>Require和include都是表示依赖，而include不显示报错</p><p>对应的include-once和require-once只调用文件中的一个，调用过就执行下一个</p><br/><p>举例说明：</p><pre class="line-numbers language-php" data-language="php"><code class="language-php">&#x2F;&#x2F;newstart.php文件&lt;?php    function sayHello()&#123;    echo &#39;I know where you are!&#39;;&#125;echo &#39;Hello Fucker&#39;;?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">&lt;?phprequire &#39;newstart.php&#39;;require &#39;newstart.php&#39;;sayHello();?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>以上应用实例是错误的，因为调用定义了两次的函数</p><p>此时就用使用require-once，<u>只对单一语句调用一次</u></p><br/><p>以下是正确写法</p><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">&lt;?php    require-once &#39;newstart.php&#39;;require-once &#39;newstart.php&#39;;sayHellp();?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>第一个语句调用函数</p><p>第二个语句调用echo语句</p><br/><h3 id="对于数组的一些函数和PHP的有关特点"><a href="#对于数组的一些函数和PHP的有关特点" class="headerlink" title="对于数组的一些函数和PHP的有关特点"></a>对于数组的一些函数和PHP的有关特点</h3><br/><p>php的数组十分自由</p><p>只需定义</p><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">$cxy&#x3D;array();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br/><p><strong>里面的键名不只是可以为数字也可以是字母</strong></p><p>定义的办法有两种</p><p>分开定义法</p><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">$cxy&#x3D;array();$cxy[0]&#x3D;&#39;hello world&#39;;$cxy[1]&#x3D;&#39;I want you&#39;;$cxy[2]&#x3D;&#39;the end is near&#39;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><br/><p>内部定义法</p><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">$cxy&#x3D;array(‘&quot;0&quot;&#x3D;&gt;&quot;5&quot;,&quot;1&quot;&#x3D;&quot;nice&quot;,&quot;2&quot;&#x3D;&quot;y&quot;);&#x2F;&#x2F;php的数组中可以存放所有格式的内容，包括字符串，字符，数字<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><br/><h3 id="php数组有关的函数"><a href="#php数组有关的函数" class="headerlink" title="php数组有关的函数"></a>php数组有关的函数</h3><br/><p>相关网站：<a href="https://www.runoob.com/php/php-ref-array.html">菜鸟教程php手册</a></p><br/><p>1.11</p><h4 id="array-unique"><a href="#array-unique" class="headerlink" title="array_unique()"></a>array_unique()</h4><br/><p>array_unique() 函数用于移除数组中重复的值。如果两个或更多个数组值相同，只保留第一个值，其他的值被移除。</p><p><strong>被保留的数组将保留第一个项的键名类型</strong></p><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">&lt;?php$a&#x3D;array(&quot;a&quot;&#x3D;&gt;&quot;red&quot;,&quot;b&quot;&#x3D;&gt;&quot;green&quot;,&quot;c&quot;&#x3D;&gt;&quot;red&quot;);print_r(array_unique($a));?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><br/><p>结果如下</p><p>Array ( [a] =&gt; red [b] =&gt; green )</p><br/><p>语法</p><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">array_unique(array);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br/><h4 id="array-values"><a href="#array-values" class="headerlink" title="array_values()"></a>array_values()</h4><br/><p>array_values() 函数返回包含数组中所有的值的数组。</p><p>被返回的数组将使用数值键，从 0 开始且以 1 递增</p><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">&lt;?php$a&#x3D;array(&quot;Name&quot;&#x3D;&gt;&quot;Peter&quot;,&quot;Age&quot;&#x3D;&gt;&quot;41&quot;,&quot;Country&quot;&#x3D;&gt;&quot;USA&quot;);print_r(array_values($a));?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><br/><p>结果如下</p><p>Array ( [0] =&gt; Peter [1] =&gt; 41 [2] =&gt; USA )</p><br/><p>语法</p><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">array_values(array)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br/><p>1.12</p><h4 id="array-push"><a href="#array-push" class="headerlink" title="array_push()"></a>array_push()</h4><br/><p>array_push() 函数向数组尾部插入一个或多个元素</p><p><strong>可以添加一个或者多个值，即使数组有字符串键名，您所添加的元素将是数字键名</strong></p><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">&lt;?php$a&#x3D;array(&quot;red&quot;,&quot;green&quot;);array_push($a,&quot;blue&quot;,&quot;yellow&quot;);print_r($a);?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>运行结果</p><p>Array ( [0] =&gt; red [1] =&gt; green [2] =&gt; blue [3] =&gt; yellow )</p><p>返回值：返回新数组的元素个数</p><br/><p>语法</p><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">array_push(array,value1,value2...)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br/><h4 id="array-reverse"><a href="#array-reverse" class="headerlink" title="array_reverse()"></a>array_reverse()</h4><br/><p>array_reverse() 函数返回翻转顺序的数组</p><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">&lt;?php$a&#x3D;array(&quot;a&quot;&#x3D;&gt;&quot;Volvo&quot;,&quot;b&quot;&#x3D;&gt;&quot;BMW&quot;,&quot;c&quot;&#x3D;&gt;&quot;Toyota&quot;);print_r(array_reverse($a));?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><br/><p>运行结果</p><p>Array ( [c] =&gt; Toyota [b] =&gt; BMW [a] =&gt; Volvo ) </p><br/><p>语法</p><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">array_reverse(array,preserve)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br/><h4 id="array-pad"><a href="#array-pad" class="headerlink" title="array_pad()"></a>array_pad()</h4><br/><p>array_pad() 函数将指定数量的带有指定值的元素插入到数组中。</p><p><strong>如果将 size 参数设置为负数，该函数会在原始数组之前插入新的元素</strong></p><p><strong>如果 size 参数小于原始数组的长度，该函数不会删除任何元素</strong></p><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">&lt;?php$a&#x3D;array(&quot;red&quot;,&quot;green&quot;);print_r(array_pad($a,5,&quot;blue&quot;));?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><br/><p>运行结果</p><p>Array ( [0] =&gt; red [1] =&gt; green [2] =&gt; blue [3] =&gt; blue [4] =&gt; blue )</p><br/><p>语法</p><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">array_pad(array,size,value)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br/><h4 id="array-shift"><a href="#array-shift" class="headerlink" title="array_shift()"></a>array_shift()</h4><br/><p>array_shift() 函数用于<strong>删除数组中的第一个元素，并返回被删除的元素</strong></p><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">&lt;?php$a&#x3D;array(0&#x3D;&gt;&quot;red&quot;,1&#x3D;&gt;&quot;green&quot;,2&#x3D;&gt;&quot;blue&quot;);echo array_shift($a).&quot;&lt;br&gt;&quot;;print_r ($a);?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>运行结果</p><p>red<br>Array ( [0] =&gt; green [1] =&gt; blue )</p><br/><p>语法</p><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">array_shift(array)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>（同理array_unshift()函数则是在开头插入一个数）</p><br/><h4 id="count-（sizeof-）"><a href="#count-（sizeof-）" class="headerlink" title="count()（sizeof()）"></a>count()（sizeof()）</h4><br/><p>返回数组中元素的数目</p><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">&lt;?php$cars&#x3D;array(&quot;Volvo&quot;,&quot;BMW&quot;,&quot;Toyota&quot;);echo count($cars);?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><br/><p>运行结果</p><p>3</p><br/><p>语法</p><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">count(array,mode)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br/><p><strong>mode可选0或1</strong></p><p><strong>0是默认选项，不计算多维数组</strong></p><p><strong>1则计算多维数组</strong></p><br/><p>1.14（咕咕咕了一天）</p><p>1.15（又咕咕咕了一天）</p><p>1.16</p><br/><h4 id="array-key"><a href="#array-key" class="headerlink" title="array_key()"></a>array_key()</h4><br/><p><strong>array_keys() 函数返回包含数组中所有键名的一个新数组</strong></p><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">&lt;?php$a&#x3D;array(&quot;Volvo&quot;&#x3D;&gt;&quot;XC90&quot;,&quot;BMW&quot;&#x3D;&gt;&quot;X5&quot;,&quot;Toyota&quot;&#x3D;&gt;&quot;Highlander&quot;);print_r(array_keys($a));?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><br/><p>运行结果</p><p>Array ( [0] =&gt; Volvo [1] =&gt; BMW [2] =&gt; Toyota )</p><br/><p>语法</p><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">array_keys(array,value,strict)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br/><table><thead><tr><th><em>array</em></th><th>必需。规定数组。</th></tr></thead><tbody><tr><td><em>value</em></td><td>可选。您可以指定键值，然后只有该键值对应的键名会被返回。</td></tr><tr><td><strong><em>strict</em></strong></td><td><strong>可选。与 value 参数一起使用。可能的值：true - 返回带有指定键值的键名。依赖类型，数字 5 与字符串 “5” 是不同的。false - 默认值。不依赖类型，数字 5 与字符串 “5” 是相同的。</strong></td></tr></tbody></table><br/><h4 id="array-slice"><a href="#array-slice" class="headerlink" title="array_slice()"></a>array_slice()</h4><br/><p>array_slice() 函数返回数组中的选定部分</p><p><strong>如果数组有字符串键名，所返回的数组将保留键名</strong></p><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">&lt;?php$a&#x3D;array(&quot;red&quot;,&quot;green&quot;,&quot;blue&quot;,&quot;yellow&quot;,&quot;brown&quot;);print_r(array_slice($a,2));?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><br/><p>运行结果</p><p>Array ( [0] =&gt; blue [1] =&gt; yellow [2] =&gt; brown )</p><br/><p><strong>特殊情况</strong></p><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">&lt;?php$a&#x3D;array(&quot;a&quot;&#x3D;&gt;&quot;red&quot;,&quot;b&quot;&#x3D;&gt;&quot;green&quot;,&quot;c&quot;&#x3D;&gt;&quot;blue&quot;,&quot;d&quot;&#x3D;&gt;&quot;yellow&quot;,&quot;e&quot;&#x3D;&gt;&quot;brown&quot;);print_r(array_slice($a,1,2));$a&#x3D;array(&quot;0&quot;&#x3D;&gt;&quot;red&quot;,&quot;1&quot;&#x3D;&gt;&quot;green&quot;,&quot;2&quot;&#x3D;&gt;&quot;blue&quot;,&quot;3&quot;&#x3D;&gt;&quot;yellow&quot;,&quot;4&quot;&#x3D;&gt;&quot;brown&quot;);print_r(array_slice($a,1,2));?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><br/><p>运行结果</p><p>Array ( [b] =&gt; green [c] =&gt; blue ) </p><p>Array ( [0] =&gt; green [1] =&gt; blue )</p><br/><p>语法</p><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">array_slice(array,start,length,preserve)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br/><table><thead><tr><th><em>array</em></th><th>必需。规定数组。</th></tr></thead><tbody><tr><td><em>start</em></td><td>必需。数值。规定取出元素的开始位置。 0 = 第一个元素。 如果该值设置为正数，则从前往后开始取。如果该值设置为负数，则从后向前取 start 绝对值。 -2 意味着从数组的倒数第二个元素开始。</td></tr><tr><td><em>length</em></td><td>可选。数值。规定被返回数组的长度。 如果该值设置为整数，则返回该数量的元素。如果该值设置为负数，则函数将在举例数组末端这么远的地方终止取出。如果该值未设置，则返回从 start 参数设置的位置开始直到数组末端的所有元素</td></tr><tr><td><strong><em>preserve</em></strong></td><td><strong>可选。规定函数是保留键名还是重置键名。可能的值：true - 保留键名false - 默认。重置键名（特殊情况自动保留键名）</strong></td></tr></tbody></table><br/><h4 id="对数组中指针操作的函数"><a href="#对数组中指针操作的函数" class="headerlink" title="对数组中指针操作的函数"></a>对数组中指针操作的函数</h4><br/><ul><li><a href="https://www.runoob.com/php/func-array-current.html">current()</a> - 返回数组中的当前元素的值。</li><li><a href="https://www.runoob.com/php/func-array-end.html">end()</a> - 将内部指针指向数组中的最后一个元素，并输出</li><li><a href="https://www.runoob.com/php/func-array-next.html">next()</a> - 将内部指针指向数组中的下一个元素，并输出</li><li><a href="https://www.runoob.com/php/func-array-prev.html">prev()</a> - 将内部指针指向数组中的上一个元素，并输出</li><li><a href="https://www.runoob.com/php/func-array-reset.html">reset()</a> - 将内部指针指向数组中的第一个元素，并输出</li></ul><br/><p>each()在PHP 7.2.0中被弃用了</p><br/><h4 id="对数组进行排序的函数"><a href="#对数组进行排序的函数" class="headerlink" title="对数组进行排序的函数"></a>对数组进行排序的函数</h4><br/><table><thead><tr><th><strong><a href="https://www.runoob.com/php/func-array-sort.html">sort()</a></strong></th><th><strong>对数值数组进行升序排序</strong></th></tr></thead><tbody><tr><td><a href="https://www.runoob.com/php/func-array-uasort.html">uasort()</a></td><td>使用用户自定义的比较函数对数组中的键值进行排序</td></tr><tr><td><a href="https://www.runoob.com/php/func-array-uksort.html">uksort()</a></td><td>使用用户自定义的比较函数对数组中的键名进行排序</td></tr><tr><td><a href="https://www.runoob.com/php/func-array-usort.html">usort()</a></td><td>使用用户自定义的比较函数对数组进行排序</td></tr><tr><td><a href="https://www.runoob.com/php/func-array-rsort.html">rsort()</a></td><td>对数值数组进行降序排序</td></tr></tbody></table><br/><h4 id="range"><a href="#range" class="headerlink" title="range()"></a>range()</h4><br/><p>range() 函数创建一个包含指定范围的元素的数组。</p><p>该函数返回一个包含从 low 到 high 之间的元素的数组。</p><p><strong>如果 low 参数大于 high 参数，则创建的数组将是从 high 到 low。</strong></p><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">&lt;?php$number &#x3D; range(0,5);print_r ($number);?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><br/><p>运行结果</p><p>Array ( [0] =&gt; 0 [1] =&gt; 1 [2] =&gt; 2 [3] =&gt; 3 [4] =&gt; 4 [5] =&gt; 5 )</p><br/><p>语法</p><br/><pre class="line-numbers language-php" data-language="php"><code class="language-php">range(low,high,step)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br/><table><thead><tr><th><em>low</em></th><th>必需。规定数组元素的最小值</th></tr></thead><tbody><tr><td><em>high</em></td><td>必需。规定数组元素的最大值</td></tr><tr><td><em>step</em></td><td>可选。规定元素之间的步进制。默认是 1</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
